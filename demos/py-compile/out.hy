(import board) (import time) (import neopixel) (import random) (import audioio) (import array) (import audiobusio) (import math) (import (digitalio (DigitalInOut Direction Pull))) (setv pixpin board.NEOPIXEL) (setv numpix 10) (setv strip (neopixel.NeoPixel pixpin numpix :brightness 0.3 :auto_write False)) (setv already-played-list []) (defn already-played (id) (for (p already-played-list) (if (= p id) (return True))) (return False)) (defn play-file (to-play) (setv id (. to-play [1])) (if (already-played id) (return)) (already-played-list.append id) (setv filename (. to-play [0])) (print (+ "playing file " filename)) (setv f (open filename "rb")) (setv a (audioio.AudioOut board.A0 f)) (a.play) (while a.playing (setv dummy 0))) (setv CURVE 2) (setv SCALE_EXPONENT (math.pow 10 (* CURVE -0.1))) (setv NUM_SAMPLES 160) (defn constrain (value floor ceiling) (return (max floor (min value ceiling)))) (defn log_scale (input_value input_min input_max output_min output_max) (setv normalized_input_value (/ (- input_value input_min) (- input_max input_min))) (return (+ output_min (* (math.pow normalized_input_value SCALE_EXPONENT) (- output_max output_min))))) (defn normalized_rms (values) (setv minbuf (int (mean values))) (return (math.sqrt (/ (sum (list-comp (float (* (- sample minbuf) (- sample minbuf))) (sample values))) (len values))))) (defn mean (values) (return (/ (sum values) (len values)))) (defn mic-level () (mic.record samples (len samples)) (setv magnitude (normalized_rms samples)) (setv c (log_scale (constrain magnitude input_floor input_ceiling) input_floor input_ceiling 0 10)) c) (setv mic (audiobusio.PDMIn board.MICROPHONE_CLOCK board.MICROPHONE_DATA :frequency 16000 :bit_depth 16)) (setv samples (array.array "H" (* [0] NUM_SAMPLES))) (mic.record samples (len samples)) (setv input_floor (+ (normalized_rms samples) 10)) (setv input_ceiling (+ input_floor 500)) (setv peak 0) (setv SAMPLERATE 8000) (defn play-tone (beats freq) (setv length (int (/ SAMPLERATE freq))) (setv sine_wave (array.array "H" (* [0] length))) (for (i (range length)) (setv (. sine_wave [i]) (+ (* (int (* (math.sin (/ (* math.pi 2 i) 18)) (** 2 15)))) (** 2 15)))) (setv sample (audioio.AudioOut board.SPEAKER sine_wave)) (setv sample.frequency SAMPLERATE) (sample.play :loop True) (time.sleep beats) (sample.stop)) (defn set-lights (c) (do (for (n (range 10)) (set-light n c)))) (defn set-light (n c) (do (do (setv (. state ["hardware"] ["light"] [n]) c) state))) (defn color-from-volume () (do (if (< 5 (. state ["hardware"] ["mic-level"])) [0 0 255] [255 0 0]))) (defn flicker-fx () (do (set-lights [(max 0 (- (. (. state ["memory"] ["color"]) [0]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [1]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [2]) (int (+ 0 (* 255 (random.random))))))]))) (defn rimshot () (do (do (setv (. state ["hardware"] ["audio"]) [["clash2.wav" (random.random)]]) state))) (defn clash-fx () (do (play-tone 0.1 392.0) (play-tone 0.05 220.0) (for (n (range 2)) (set-lights [255 255 255]) (do (render state) (time.sleep 0.2)) (set-lights [255 0 0]) (do (render state) (time.sleep 0.2))))) (defn loud-noise () (do (< 5 (. state ["hardware"] ["mic-level"])))) (defn flash () (do (if (loud-noise) (clash-fx) (flicker-fx)))) (setv initial-memory {"color" [0 255 0] "duration" 2 "start-time" -1}) (defn update (state) (flash)) (setv start-time (time.monotonic)) (defn time-since-start () (- (time.monotonic) start-time)) (setv state {"hardware" {"light" [0 0 0 0 0 0 0 0 0 0] "audio" []} "memory" initial-memory}) (setv spkrenable (DigitalInOut board.SPEAKER_ENABLE)) (setv spkrenable.direction Direction.OUTPUT) (setv spkrenable.value True) (defn hardware-update (state) (global strip) (for (n (range 10)) (setv (. state ["hardware"] ["light"] [n]) (. strip [n]))) (do (setv (. state ["hardware"] ["audio"]) []) state) (do (setv (. state ["hardware"] ["mic-level"]) (mic-level)) state)) (defn render (state) (global strip) (for (n (range 10)) (setv (. strip [n]) (. state ["hardware"] ["light"] [n]))) (strip.show) (while (< 0 (len (. state ["hardware"] ["audio"]))) (do (play_file ((. (get state "hardware" "audio") pop)))))) (while True (hardware-update state) (update state) (render state))