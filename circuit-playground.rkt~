#lang racket
#lang racket

(require "./python.rkt")

(define test 
  (python
   (import (digitalio (DigitalInOut Direction Pull)))
   (import touchio)
   (import board)
   (import time)
   (import (adafruit_hid.keyboard (Keyboard)))
   (import (adafruit_hid.keycode (Keycode)))
   (import (adafruit_hid.keyboard_layout_us (KeyboardLayoutUS)))

   (setv buttonpins [hy-SQUARE board.BUTTON_A board.BUTTON_B])
   (setv buttons [hy-SQUARE ])
   (setv buttonkeys [hy-SQUARE Keycode.LEFT_ARROW Keycode.RIGHT_ARROW])
   (setv controlkey Keycode.SHIFT)

   (time.sleep 1)

   (setv kbd (Keyboard))
   (setv layout (KeyboardLayoutUS kbd))

   (for (pin buttonpins)
     (setv button (DigitalInOut pin))
     (setv button.direction Direction.INPUT)
     (setv button.pull Pull.DOWN)
     (buttons.append button))

   (setv led (DigitalInOut board.D13))
   (setv led.direction Direction.OUTPUT)

   (print "Waiting for button presses")

   (while True
          (for (button buttons)
            (if button.value
                (do
                    (print (% "Button #%d Pressed"  i))
                  (setv i (buttons.index button))
                  (setv led.value True)
                  (setv k (hy-DOT buttonkeys [hy-SQUARE i]))

                  (if (is (type k) str)
                      (layout.write k)
                      (kbd.press controlkey k))

                  (setv led.value False))
                (do
                    (setv i (buttons.index button))
                  (setv k (hy-DOT buttonkeys [hy-SQUARE i]))
                  (kbd.release controlkey  k)))))
   ))



(define test2
  (python

   (import time)
   (import board)
   (import neopixel)
   (import touchio)

   (setv pixpin board.NEOPIXEL)
   (setv numpix 10)

   (setv touch_A1 (touchio.TouchIn board.A1))

   (setv strip (neopixel.NeoPixel pixpin numpix :brightness 0.3 :auto_write False))

   (defn wheel [hy-SQUARE pos]
     (if (or (< pos 0) (> pos 255))
         (return [hy-SQUARE 0 0 0]))

     (if (< pos 85)
         (return [hy-SQUARE  (int (* pos 3))
                             (int (- 255 (* pos 3)))
                             0])

         (< pos 170)
         (do (setv pos (- pos 85))
           (return [hy-SQUARE  (int (- 255 (* pos 3)))
                               0
                               (int (* pos 3))]))


         (do
           (setv pos (- pos 170))
           (return [hy-SQUARE 0
                              (int (* pos 3))
                              (int (- 255 (* pos 3)))]))))


   (defn rainbow_cycle (wait)
     (for [j (range 255)]
       (for [i (range (len strip))]
         (setv idx (+ (int (/ (* i 256) (len strip))) j))
         (setv (hy-DOT strip [hy-SQUARE i]) (wheel (& idx 255))))
       (if touch_A1.value
           (strip.fill [hy-SQUARE  255 0 0]))
       (strip.write)
       (time.sleep wait)))


   (while True
          (rainbow_cycle 0.001))

   ))







