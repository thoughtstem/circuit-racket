#include "py/mpconfig.h"
#include "py/objint.h"
#include "py/objstr.h"
#include "py/emitglue.h"

#if MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE != 0
#error "incompatible MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE"
#endif

#if MICROPY_LONGINT_IMPL != 0
#error "incompatible MICROPY_LONGINT_IMPL"
#endif

#if MICROPY_PY_BUILTINS_FLOAT
typedef struct _mp_obj_float_t {
    mp_obj_base_t base;
    mp_float_t value;
} mp_obj_float_t;
#endif

#if MICROPY_PY_BUILTINS_COMPLEX
typedef struct _mp_obj_complex_t {
    mp_obj_base_t base;
    mp_float_t real;
    mp_float_t imag;
} mp_obj_complex_t;
#endif

enum {
    MP_QSTR_adafruit_bus_device_slash___init___dot_py = MP_QSTRnumber_of,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py,
    MP_QSTR_2_dot_0_dot_2,
    MP_QSTR___version__,
    MP_QSTR___repo__,
    MP_QSTR_I2CDevice,
    MP_QSTR_i2c,
    MP_QSTR_device_address,
    MP_QSTR_self,
    MP_QSTR_buf,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py,
    MP_QSTR_SPIDevice,
    MP_QSTR_extra_clocks,
    MP_QSTR_spi,
    MP_QSTR_chip_select,
    MP_QSTR_adafruit_lis3dh_dot_py,
    MP_QSTR_struct,
    MP_QSTR_4_dot_0_dot_0,
    MP_QSTR_REG_OUTADC1_L,
    MP_QSTR_REG_WHOAMI,
    MP_QSTR_REG_TEMPCFG,
    MP_QSTR_REG_CTRL1,
    MP_QSTR_REG_CTRL3,
    MP_QSTR_REG_CTRL4,
    MP_QSTR_REG_CTRL5,
    MP_QSTR_REG_OUT_X_L,
    MP_QSTR_REG_INT1SRC,
    MP_QSTR_REG_CLICKCFG,
    MP_QSTR_REG_CLICKSRC,
    MP_QSTR_REG_CLICKTHS,
    MP_QSTR_REG_TIMELIMIT,
    MP_QSTR_REG_TIMELATENCY,
    MP_QSTR_REG_TIMEWINDOW,
    MP_QSTR_RANGE_16_G,
    MP_QSTR_RANGE_8_G,
    MP_QSTR_RANGE_4_G,
    MP_QSTR_RANGE_2_G,
    MP_QSTR_DATARATE_1344_HZ,
    MP_QSTR_DATARATE_400_HZ,
    MP_QSTR_DATARATE_200_HZ,
    MP_QSTR_DATARATE_100_HZ,
    MP_QSTR_DATARATE_50_HZ,
    MP_QSTR_DATARATE_25_HZ,
    MP_QSTR_DATARATE_10_HZ,
    MP_QSTR_DATARATE_1_HZ,
    MP_QSTR_DATARATE_POWERDOWN,
    MP_QSTR_DATARATE_LOWPOWER_1K6HZ,
    MP_QSTR_DATARATE_LOWPOWER_5KHZ,
    MP_QSTR_LIS3DH,
    MP_QSTR_LIS3DH_I2C,
    MP_QSTR_LIS3DH_SPI,
    MP_QSTR_data_rate,
    MP_QSTR_acceleration,
    MP_QSTR_shake,
    MP_QSTR_read_adc_raw,
    MP_QSTR_read_adc_mV,
    MP_QSTR_tapped,
    MP_QSTR_time_limit,
    MP_QSTR_time_latency,
    MP_QSTR_time_window,
    MP_QSTR_click_cfg,
    MP_QSTR_set_tap,
    MP_QSTR__read_register_byte,
    MP_QSTR__read_register,
    MP_QSTR__write_register_byte,
    MP_QSTR__int1,
    MP_QSTR__int2,
    MP_QSTR_int1,
    MP_QSTR_int2,
    MP_QSTR_rate,
    MP_QSTR_range_value,
    MP_QSTR__lt_hhh,
    MP_QSTR_shake_threshold,
    MP_QSTR_avg_count,
    MP_QSTR_total_delay,
    MP_QSTR_x,
    MP_QSTR__lt_h,
    MP_QSTR_adc,
    MP_QSTR_tap,
    MP_QSTR_register,
    MP_QSTR_length,
    MP_QSTR_adafruit_bus_device_dot_i2c_device,
    MP_QSTR_i2c_device,
    MP_QSTR__i2c,
    MP_QSTR__buffer,
    MP_QSTR_adafruit_bus_device_dot_spi_device,
    MP_QSTR_spi_device,
    MP_QSTR__spi,
    MP_QSTR_cs,
    MP_QSTR_adafruit_thermistor_dot_py,
    MP_QSTR_Thermistor,
    MP_QSTR_high_side,
    MP_QSTR_series_resistor,
    MP_QSTR_nominal_resistance,
    MP_QSTR_nominal_temperature,
    MP_QSTR_b_coefficient,
    MP_QSTR_express_dot_py,
    MP_QSTR_adafruit_lis3dh,
    MP_QSTR_adafruit_thermistor,
    MP_QSTR_neopixel,
    MP_QSTR_Photocell,
    MP_QSTR_Express,
    MP_QSTR_cpx,
    MP_QSTR_light,
    MP_QSTR__photocell,
    MP_QSTR_detect_taps,
    MP_QSTR_touch_A1,
    MP_QSTR_touch_A2,
    MP_QSTR_touch_A3,
    MP_QSTR_touch_A4,
    MP_QSTR_touch_A5,
    MP_QSTR_touch_A6,
    MP_QSTR_touch_A7,
    MP_QSTR_adjust_touch_threshold,
    MP_QSTR_pixels,
    MP_QSTR_button_a,
    MP_QSTR_button_b,
    MP_QSTR_switch,
    MP_QSTR_red_led,
    MP_QSTR__sine_sample,
    MP_QSTR__generate_sample,
    MP_QSTR_play_tone,
    MP_QSTR_start_tone,
    MP_QSTR_stop_tone,
    MP_QSTR_play_file,
    MP_QSTR__a,
    MP_QSTR__b,
    MP_QSTR__switch,
    MP_QSTR__led,
    MP_QSTR_NeoPixel,
    MP_QSTR__pixels,
    MP_QSTR__temp,
    MP_QSTR__light,
    MP_QSTR__speaker_enable,
    MP_QSTR__sample,
    MP_QSTR__sine_wave,
    MP_QSTR__touch_A1,
    MP_QSTR__touch_A2,
    MP_QSTR__touch_A3,
    MP_QSTR__touch_A4,
    MP_QSTR__touch_A5,
    MP_QSTR__touch_A6,
    MP_QSTR__touch_A7,
    MP_QSTR__touch_threshold_adjustment,
    MP_QSTR__lis3dh,
    MP_QSTR__detect_taps,
    MP_QSTR_adjustment,
    MP_QSTR__touch_A,
    MP_QSTR_H,
    MP_QSTR_duration,
    MP_QSTR_rb,
    MP_QSTR_file_name,
    MP_QSTR_frozentest_dot_py,
    MP_QSTR_uPy,
    MP_QSTR_i,
    MP_QSTR_IRLib_P01_NECd_dot_py,
    MP_QSTR_IRrecvPCI,
    MP_QSTR_IRLibDecodeBase,
    MP_QSTR_IRLibProtocols,
    MP_QSTR_IRdecodeNEC,
    MP_QSTR_resetDecoder,
    MP_QSTR_decodeBuffer,
    MP_QSTR_MATCH,
    MP_QSTR_NEC,
    MP_QSTR_protocolNum,
    MP_QSTR_decodeGeneric,
    MP_QSTR_IRLib_P01_NECs_dot_py,
    MP_QSTR_IRLibSendBase,
    MP_QSTR_IRsendNEC,
    MP_QSTR_outPin,
    MP_QSTR_enableIROut,
    MP_QSTR_mark,
    MP_QSTR_space,
    MP_QSTR_transmit,
    MP_QSTR_sendGeneric,
    MP_QSTR_data,
    MP_QSTR_kHz,
    MP_QSTR_IRLib_P02_Sonyd_dot_py,
    MP_QSTR_IRdecodeSony,
    MP_QSTR_ignoreHeader,
    MP_QSTR_SONY,
    MP_QSTR_IRLib_P02_Sonys_dot_py,
    MP_QSTR_IRsendSony,
    MP_QSTR_IRLib_P03_RC5d_dot_py,
    MP_QSTR_IRdecodeRC5,
    MP_QSTR_offset,
    MP_QSTR_used,
    MP_QSTR_RCtime,
    MP_QSTR_RCLevel,
    MP_QSTR_RCMARK,
    MP_QSTR_RCSPACE,
    MP_QSTR_RC5,
    MP_QSTR_IRLib_P03_RC5s_dot_py,
    MP_QSTR_IRsendRC5,
    MP_QSTR_extent,
    MP_QSTR_numBits,
    MP_QSTR_IRLib_P04_RC6d_dot_py,
    MP_QSTR_IRdecodeRC6,
    MP_QSTR_RC6,
    MP_QSTR_IRLib_P04_RC6s_dot_py,
    MP_QSTR_IRsendRC6,
    MP_QSTR_sendRC6Bits,
    MP_QSTR_first,
    MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py,
    MP_QSTR_IRdecodePanasonic_Old,
    MP_QSTR_PANASONIC_OLD,
    MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py,
    MP_QSTR_IRsendPanasonic_Old,
    MP_QSTR_IRLib_P06_JVCd_dot_py,
    MP_QSTR_IRdecodeJVC,
    MP_QSTR_JVC,
    MP_QSTR_IRLib_P06_JVCs_dot_py,
    MP_QSTR_IRsendJVC,
    MP_QSTR_IRLib_P07_NECxd_dot_py,
    MP_QSTR_IRdecodeNECx,
    MP_QSTR_NECX,
    MP_QSTR_IRLib_P07_NECxs_dot_py,
    MP_QSTR_IRsendNECx,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py,
    MP_QSTR_IRdecodeSamsung36,
    MP_QSTR_getBits,
    MP_QSTR_lastOffset,
    MP_QSTR_SAMSUNG36,
    MP_QSTR_IRLib_P08_Samsung36s_dot_py,
    MP_QSTR_IRsendSamsung36,
    MP_QSTR_sendBits,
    MP_QSTR_IRLib_P09_GICabled_dot_py,
    MP_QSTR_IRdecodeGICable,
    MP_QSTR_GICABLE,
    MP_QSTR_IRLib_P09_GICables_dot_py,
    MP_QSTR_IRsendGICable,
    MP_QSTR_IRLib_P10_DirecTVd_dot_py,
    MP_QSTR_IRdecodeDirecTV,
    MP_QSTR_DIRECTV,
    MP_QSTR_IRLib_P10_DirecTVs_dot_py,
    MP_QSTR_IRsendDirecTV,
    MP_QSTR_longLeadOut,
    MP_QSTR_IRLib_P11_RCMMd_dot_py,
    MP_QSTR_RCMM_TOLERANCE,
    MP_QSTR_IRdecodeRCMM,
    MP_QSTR_ABS_MATCH,
    MP_QSTR_RCMM,
    MP_QSTR_IRLib_P11_RCMMs_dot_py,
    MP_QSTR_IRsendRCMM,
    MP_QSTR_sendRCMMBits,
    MP_QSTR_IRLibDecodeBase_dot_py,
    MP_QSTR_PERCENT_TOLERANCE,
    MP_QSTR_RCERROR,
    MP_QSTR_PERCENT_LOW,
    MP_QSTR_PERCENT_HIGH,
    MP_QSTR_us,
    MP_QSTR_dumpResults,
    MP_QSTR_v,
    MP_QSTR_t,
    MP_QSTR_UNKNOWN,
    MP_QSTR_Pnames,
    MP_QSTR_s_brace_open__brace_close_,
    MP_QSTR__space_,
    MP_QSTR__brace_open__colon_2d_brace_close__colon_m_brace_open__brace_close_,
    MP_QSTR__0x09_,
    MP_QSTR_verbose,
    MP_QSTR_expectedLength,
    MP_QSTR_headMark,
    MP_QSTR_headSpace,
    MP_QSTR_markData,
    MP_QSTR_spaceOne,
    MP_QSTR_spaceZero,
    MP_QSTR_IRLibProtocols_dot_py,
    MP_QSTR_CYKM,
    MP_QSTR_Sony,
    MP_QSTR_NECx,
    MP_QSTR_Samsung36,
    MP_QSTR_G_dot_I_dot_Cable,
    MP_QSTR_DirecTV,
    MP_QSTR_rcmm,
    MP_QSTR_IRLibSendBase_dot_py,
    MP_QSTR_irPWM,
    MP_QSTR_irSend,
    MP_QSTR_sendBuffer,
    MP_QSTR_usec,
    MP_QSTR_markOne,
    MP_QSTR_markZero,
    MP_QSTR_useStop,
    MP_QSTR_maxExtent,
    MP_QSTR_IRrecvPCI_dot_py,
    MP_QSTR_enableIRIn,
    MP_QSTR_getResults,
    MP_QSTR_recvPin,
    MP_QSTR_markExcess,
    MP_QSTR_recvBuffer,
    MP_QSTR_prevLength,
    MP_QSTR_lastTime,
    MP_QSTR_motor_dot_py,
    MP_QSTR_DCMotor,
    MP_QSTR_throttle,
    MP_QSTR__positive,
    MP_QSTR__negative,
    MP_QSTR_positive_pwm,
    MP_QSTR_negative_pwm,
    MP_QSTR_exception_type,
    MP_QSTR_exception_value,
    MP_QSTR_traceback,
    MP_QSTR_neopixel_dot_py,
    MP_QSTR_3_dot_0_dot_1,
    MP_QSTR_ORDER,
    MP_QSTR_bpp,
    MP_QSTR_brightness,
    MP_QSTR_auto_write,
    MP_QSTR__set_item,
    MP_QSTR_show,
    MP_QSTR_n,
    MP_QSTR__bracket_open_,
    MP_QSTR__comma__space_,
    MP_QSTR__bracket_close_,
    MP_QSTR_val,
    MP_QSTR__brightness,
    MP_QSTR_color,
    MP_QSTR_servo_dot_py,
    MP_QSTR__BaseServo,
    MP_QSTR_Servo,
    MP_QSTR_ContinuousServo,
    MP_QSTR_min_pulse,
    MP_QSTR_max_pulse,
    MP_QSTR__fraction,
    MP_QSTR__min_duty,
    MP_QSTR__duty_range,
    MP_QSTR__pwm_out,
    MP_QSTR_pwm_out,
    MP_QSTR_actuation_range,
    MP_QSTR_angle,
    MP_QSTR__actuation_range,
    MP_QSTR__pwm,
    MP_QSTR_new_angle,
    MP_QSTR_stepper_dot_py,
    MP_QSTR_FORWARD,
    MP_QSTR_BACKWARD,
    MP_QSTR_SINGLE,
    MP_QSTR_DOUBLE,
    MP_QSTR_INTERLEAVE,
    MP_QSTR_MICROSTEP,
    MP_QSTR_StepperMotor,
    MP_QSTR_microsteps,
    MP_QSTR_microstepping,
    MP_QSTR__update_coils,
    MP_QSTR_style,
    MP_QSTR_onestep,
    MP_QSTR__coil,
    MP_QSTR__current_microstep,
    MP_QSTR__microsteps,
    MP_QSTR__curve,
    MP_QSTR_ain1,
    MP_QSTR_ain2,
    MP_QSTR_bin1,
    MP_QSTR_bin2,
    MP_QSTR_tslib_dot_py,
    MP_QSTR_express,
    MP_QSTR_servo,
    MP_QSTR_IRLib_P01_NECd,
    MP_QSTR_IRLib_P01_NECs,
    MP_QSTR_send_ir,
    MP_QSTR_ir_receive,
    MP_QSTR_reset_receiver,
    MP_QSTR_set_servo_f,
    MP_QSTR_free_servo_pin,
    MP_QSTR_create_new_pwm,
    MP_QSTR_fetch_existing_pwm,
    MP_QSTR_get_pwm,
    MP_QSTR_pin_write_f,
    MP_QSTR_mic_level,
    MP_QSTR_mean,
    MP_QSTR_normalized_rms,
    MP_QSTR_log_scale,
    MP_QSTR_constrain,
    MP_QSTR_play_riff,
    MP_QSTR_set_lights,
    MP_QSTR_set_light,
    MP_QSTR_set_brightness,
    MP_QSTR_pick_random,
    MP_QSTR_pixpin,
    MP_QSTR_CURVE,
    MP_QSTR_SCALE_EXPONENT,
    MP_QSTR_NUM_SAMPLES,
    MP_QSTR_mic,
    MP_QSTR_samples,
    MP_QSTR_input_floor,
    MP_QSTR_input_ceiling,
    MP_QSTR_peak,
    MP_QSTR_SAMPLERATE,
    MP_QSTR_output_pins,
    MP_QSTR_pwms,
    MP_QSTR_MyDecodeClass,
    MP_QSTR_myDecoder,
    MP_QSTR_myReceiver,
    MP_QSTR_last_ir_number,
    MP_QSTR_current_ir_number,
    MP_QSTR_last_sent_time,
    MP_QSTR_last_recieved_address,
    MP_QSTR_mySend,
    MP_QSTR_SENDING,
    MP_QSTR_Results_bang__bang_,
    MP_QSTR_thresh,
    MP_QSTR_input_value,
    MP_QSTR_input_min,
    MP_QSTR_input_max,
    MP_QSTR_output_min,
    MP_QSTR_output_max,
    MP_QSTR_ceiling,
    MP_QSTR_riff,
    MP_QSTR_freq,
    MP_QSTR_beats,
    MP_QSTR_c,
    MP_QSTR_s,
};

extern const qstr_pool_t mp_qstr_const_pool;
const qstr_pool_t mp_qstr_frozen_const_pool = {
    (qstr_pool_t*)&mp_qstr_const_pool, // previous pool
    MP_QSTRnumber_of, // previous pool size
    412, // allocated entries
    412, // used entries
    {
        (const byte*)"\x13\x1f" "adafruit_bus_device/__init__.py",
        (const byte*)"\xb6\x21" "adafruit_bus_device/i2c_device.py",
        (const byte*)"\x15\x05" "2.0.2",
        (const byte*)"\x3f\x0b" "__version__",
        (const byte*)"\x8d\x08" "__repo__",
        (const byte*)"\x45\x09" "I2CDevice",
        (const byte*)"\x5d\x03" "i2c",
        (const byte*)"\x14\x0e" "device_address",
        (const byte*)"\x79\x04" "self",
        (const byte*)"\x74\x03" "buf",
        (const byte*)"\xa4\x21" "adafruit_bus_device/spi_device.py",
        (const byte*)"\x37\x09" "SPIDevice",
        (const byte*)"\x1b\x0c" "extra_clocks",
        (const byte*)"\xcf\x03" "spi",
        (const byte*)"\x60\x0b" "chip_select",
        (const byte*)"\x2c\x12" "adafruit_lis3dh.py",
        (const byte*)"\x12\x06" "struct",
        (const byte*)"\x11\x05" "4.0.0",
        (const byte*)"\xc0\x0d" "REG_OUTADC1_L",
        (const byte*)"\xdf\x0a" "REG_WHOAMI",
        (const byte*)"\x04\x0b" "REG_TEMPCFG",
        (const byte*)"\x12\x09" "REG_CTRL1",
        (const byte*)"\x10\x09" "REG_CTRL3",
        (const byte*)"\x17\x09" "REG_CTRL4",
        (const byte*)"\x16\x09" "REG_CTRL5",
        (const byte*)"\xd0\x0b" "REG_OUT_X_L",
        (const byte*)"\xea\x0b" "REG_INT1SRC",
        (const byte*)"\x46\x0c" "REG_CLICKCFG",
        (const byte*)"\xc6\x0c" "REG_CLICKSRC",
        (const byte*)"\xcb\x0c" "REG_CLICKTHS",
        (const byte*)"\x6a\x0d" "REG_TIMELIMIT",
        (const byte*)"\xd7\x0f" "REG_TIMELATENCY",
        (const byte*)"\xd3\x0e" "REG_TIMEWINDOW",
        (const byte*)"\xfa\x0a" "RANGE_16_G",
        (const byte*)"\x05\x09" "RANGE_8_G",
        (const byte*)"\x09\x09" "RANGE_4_G",
        (const byte*)"\x8f\x09" "RANGE_2_G",
        (const byte*)"\x07\x10" "DATARATE_1344_HZ",
        (const byte*)"\xd1\x0f" "DATARATE_400_HZ",
        (const byte*)"\x97\x0f" "DATARATE_200_HZ",
        (const byte*)"\xb4\x0f" "DATARATE_100_HZ",
        (const byte*)"\xa0\x0e" "DATARATE_50_HZ",
        (const byte*)"\x42\x0e" "DATARATE_25_HZ",
        (const byte*)"\xa4\x0e" "DATARATE_10_HZ",
        (const byte*)"\xb4\x0d" "DATARATE_1_HZ",
        (const byte*)"\xc5\x12" "DATARATE_POWERDOWN",
        (const byte*)"\xc2\x17" "DATARATE_LOWPOWER_1K6HZ",
        (const byte*)"\xb0\x16" "DATARATE_LOWPOWER_5KHZ",
        (const byte*)"\xcc\x06" "LIS3DH",
        (const byte*)"\x0b\x0a" "LIS3DH_I2C",
        (const byte*)"\x39\x0a" "LIS3DH_SPI",
        (const byte*)"\xa8\x09" "data_rate",
        (const byte*)"\xe7\x0c" "acceleration",
        (const byte*)"\x31\x05" "shake",
        (const byte*)"\xd5\x0c" "read_adc_raw",
        (const byte*)"\x6a\x0b" "read_adc_mV",
        (const byte*)"\xf1\x06" "tapped",
        (const byte*)"\x3a\x0a" "time_limit",
        (const byte*)"\x47\x0c" "time_latency",
        (const byte*)"\xa3\x0b" "time_window",
        (const byte*)"\x76\x09" "click_cfg",
        (const byte*)"\x1d\x07" "set_tap",
        (const byte*)"\xeb\x13" "_read_register_byte",
        (const byte*)"\x3e\x0e" "_read_register",
        (const byte*)"\x24\x14" "_write_register_byte",
        (const byte*)"\x18\x05" "_int1",
        (const byte*)"\x1b\x05" "_int2",
        (const byte*)"\xe7\x04" "int1",
        (const byte*)"\xe4\x04" "int2",
        (const byte*)"\x47\x04" "rate",
        (const byte*)"\x4e\x0b" "range_value",
        (const byte*)"\xd1\x04" "<hhh",
        (const byte*)"\x99\x0f" "shake_threshold",
        (const byte*)"\x69\x09" "avg_count",
        (const byte*)"\x4d\x0b" "total_delay",
        (const byte*)"\xdd\x01" "x",
        (const byte*)"\xd1\x02" "<h",
        (const byte*)"\x43\x03" "adc",
        (const byte*)"\xe0\x03" "tap",
        (const byte*)"\xac\x08" "register",
        (const byte*)"\x59\x06" "length",
        (const byte*)"\xb0\x1e" "adafruit_bus_device.i2c_device",
        (const byte*)"\x9a\x0a" "i2c_device",
        (const byte*)"\xc2\x04" "_i2c",
        (const byte*)"\x1a\x07" "_buffer",
        (const byte*)"\xe2\x1e" "adafruit_bus_device.spi_device",
        (const byte*)"\xc8\x0a" "spi_device",
        (const byte*)"\x50\x04" "_spi",
        (const byte*)"\xf5\x02" "cs",
        (const byte*)"\x50\x16" "adafruit_thermistor.py",
        (const byte*)"\xf0\x0a" "Thermistor",
        (const byte*)"\xef\x09" "high_side",
        (const byte*)"\x76\x0f" "series_resistor",
        (const byte*)"\x1f\x12" "nominal_resistance",
        (const byte*)"\x90\x13" "nominal_temperature",
        (const byte*)"\xad\x0d" "b_coefficient",
        (const byte*)"\xf8\x0a" "express.py",
        (const byte*)"\xab\x0f" "adafruit_lis3dh",
        (const byte*)"\x97\x13" "adafruit_thermistor",
        (const byte*)"\x69\x08" "neopixel",
        (const byte*)"\xcf\x09" "Photocell",
        (const byte*)"\x1f\x07" "Express",
        (const byte*)"\xce\x03" "cpx",
        (const byte*)"\xfb\x05" "light",
        (const byte*)"\x70\x0a" "_photocell",
        (const byte*)"\xeb\x0b" "detect_taps",
        (const byte*)"\x8f\x08" "touch_A1",
        (const byte*)"\x8c\x08" "touch_A2",
        (const byte*)"\x8d\x08" "touch_A3",
        (const byte*)"\x8a\x08" "touch_A4",
        (const byte*)"\x8b\x08" "touch_A5",
        (const byte*)"\x88\x08" "touch_A6",
        (const byte*)"\x89\x08" "touch_A7",
        (const byte*)"\x2a\x16" "adjust_touch_threshold",
        (const byte*)"\x9e\x06" "pixels",
        (const byte*)"\xed\x08" "button_a",
        (const byte*)"\xee\x08" "button_b",
        (const byte*)"\xb7\x06" "switch",
        (const byte*)"\x84\x07" "red_led",
        (const byte*)"\x72\x0c" "_sine_sample",
        (const byte*)"\xe8\x10" "_generate_sample",
        (const byte*)"\xce\x09" "play_tone",
        (const byte*)"\x2a\x0a" "start_tone",
        (const byte*)"\x32\x09" "stop_tone",
        (const byte*)"\x58\x09" "play_file",
        (const byte*)"\x5b\x02" "_a",
        (const byte*)"\x58\x02" "_b",
        (const byte*)"\x48\x07" "_switch",
        (const byte*)"\xb7\x04" "_led",
        (const byte*)"\x69\x08" "NeoPixel",
        (const byte*)"\x61\x07" "_pixels",
        (const byte*)"\x16\x05" "_temp",
        (const byte*)"\x24\x06" "_light",
        (const byte*)"\xff\x0f" "_speaker_enable",
        (const byte*)"\xfc\x07" "_sample",
        (const byte*)"\xd1\x0a" "_sine_wave",
        (const byte*)"\xb0\x09" "_touch_A1",
        (const byte*)"\xb3\x09" "_touch_A2",
        (const byte*)"\xb2\x09" "_touch_A3",
        (const byte*)"\xb5\x09" "_touch_A4",
        (const byte*)"\xb4\x09" "_touch_A5",
        (const byte*)"\xb7\x09" "_touch_A6",
        (const byte*)"\xb6\x09" "_touch_A7",
        (const byte*)"\xe7\x1b" "_touch_threshold_adjustment",
        (const byte*)"\x13\x07" "_lis3dh",
        (const byte*)"\x74\x0c" "_detect_taps",
        (const byte*)"\xea\x0a" "adjustment",
        (const byte*)"\x61\x08" "_touch_A",
        (const byte*)"\xed\x01" "H",
        (const byte*)"\x7b\x08" "duration",
        (const byte*)"\xd5\x02" "rb",
        (const byte*)"\x5b\x09" "file_name",
        (const byte*)"\xfe\x0d" "frozentest.py",
        (const byte*)"\xf9\x03" "uPy",
        (const byte*)"\xcc\x01" "i",
        (const byte*)"\x23\x11" "IRLib_P01_NECd.py",
        (const byte*)"\x66\x09" "IRrecvPCI",
        (const byte*)"\xc0\x0f" "IRLibDecodeBase",
        (const byte*)"\x1c\x0e" "IRLibProtocols",
        (const byte*)"\x3a\x0b" "IRdecodeNEC",
        (const byte*)"\xee\x0c" "resetDecoder",
        (const byte*)"\xa9\x0c" "decodeBuffer",
        (const byte*)"\x76\x05" "MATCH",
        (const byte*)"\x8d\x03" "NEC",
        (const byte*)"\x65\x0b" "protocolNum",
        (const byte*)"\x78\x0d" "decodeGeneric",
        (const byte*)"\xd4\x11" "IRLib_P01_NECs.py",
        (const byte*)"\xd0\x0d" "IRLibSendBase",
        (const byte*)"\x2a\x09" "IRsendNEC",
        (const byte*)"\xfc\x06" "outPin",
        (const byte*)"\xb1\x0b" "enableIROut",
        (const byte*)"\x70\x04" "mark",
        (const byte*)"\x21\x05" "space",
        (const byte*)"\x2f\x08" "transmit",
        (const byte*)"\x68\x0b" "sendGeneric",
        (const byte*)"\x15\x04" "data",
        (const byte*)"\xfc\x03" "kHz",
        (const byte*)"\x23\x12" "IRLib_P02_Sonyd.py",
        (const byte*)"\x99\x0c" "IRdecodeSony",
        (const byte*)"\xc2\x0c" "ignoreHeader",
        (const byte*)"\x6e\x04" "SONY",
        (const byte*)"\xd4\x12" "IRLib_P02_Sonys.py",
        (const byte*)"\x89\x0a" "IRsendSony",
        (const byte*)"\x0d\x11" "IRLib_P03_RC5d.py",
        (const byte*)"\x16\x0b" "IRdecodeRC5",
        (const byte*)"\x48\x06" "offset",
        (const byte*)"\x42\x04" "used",
        (const byte*)"\xa1\x06" "RCtime",
        (const byte*)"\x42\x07" "RCLevel",
        (const byte*)"\xe1\x06" "RCMARK",
        (const byte*)"\x70\x07" "RCSPACE",
        (const byte*)"\x21\x03" "RC5",
        (const byte*)"\xba\x11" "IRLib_P03_RC5s.py",
        (const byte*)"\x06\x09" "IRsendRC5",
        (const byte*)"\x73\x06" "extent",
        (const byte*)"\x5f\x07" "numBits",
        (const byte*)"\x89\x11" "IRLib_P04_RC6d.py",
        (const byte*)"\x15\x0b" "IRdecodeRC6",
        (const byte*)"\x22\x03" "RC6",
        (const byte*)"\x3e\x11" "IRLib_P04_RC6s.py",
        (const byte*)"\x05\x09" "IRsendRC6",
        (const byte*)"\x72\x0b" "sendRC6Bits",
        (const byte*)"\x9f\x05" "first",
        (const byte*)"\x31\x1b" "IRLib_P05_Panasonic_Oldd.py",
        (const byte*)"\x2c\x15" "IRdecodePanasonic_Old",
        (const byte*)"\x5b\x0d" "PANASONIC_OLD",
        (const byte*)"\x46\x1b" "IRLib_P05_Panasonic_Olds.py",
        (const byte*)"\x3c\x13" "IRsendPanasonic_Old",
        (const byte*)"\x93\x11" "IRLib_P06_JVCd.py",
        (const byte*)"\xcd\x0b" "IRdecodeJVC",
        (const byte*)"\xfa\x03" "JVC",
        (const byte*)"\xa4\x11" "IRLib_P06_JVCs.py",
        (const byte*)"\xdd\x09" "IRsendJVC",
        (const byte*)"\x9d\x12" "IRLib_P07_NECxd.py",
        (const byte*)"\x02\x0c" "IRdecodeNECx",
        (const byte*)"\x75\x04" "NECX",
        (const byte*)"\x2a\x12" "IRLib_P07_NECxs.py",
        (const byte*)"\x12\x0a" "IRsendNECx",
        (const byte*)"\xb7\x17" "IRLib_P08_Samsung36d.py",
        (const byte*)"\xe7\x11" "IRdecodeSamsung36",
        (const byte*)"\x1f\x07" "getBits",
        (const byte*)"\x82\x0a" "lastOffset",
        (const byte*)"\x90\x09" "SAMSUNG36",
        (const byte*)"\x40\x17" "IRLib_P08_Samsung36s.py",
        (const byte*)"\xf7\x0f" "IRsendSamsung36",
        (const byte*)"\x15\x08" "sendBits",
        (const byte*)"\xc4\x15" "IRLib_P09_GICabled.py",
        (const byte*)"\x55\x0f" "IRdecodeGICable",
        (const byte*)"\x62\x07" "GICABLE",
        (const byte*)"\x33\x15" "IRLib_P09_GICables.py",
        (const byte*)"\x45\x0d" "IRsendGICable",
        (const byte*)"\xb0\x15" "IRLib_P10_DirecTVd.py",
        (const byte*)"\x49\x0f" "IRdecodeDirecTV",
        (const byte*)"\x3e\x07" "DIRECTV",
        (const byte*)"\x87\x15" "IRLib_P10_DirecTVs.py",
        (const byte*)"\x59\x0d" "IRsendDirecTV",
        (const byte*)"\x0d\x0b" "longLeadOut",
        (const byte*)"\xbb\x12" "IRLib_P11_RCMMd.py",
        (const byte*)"\x82\x0e" "RCMM_TOLERANCE",
        (const byte*)"\x63\x0c" "IRdecodeRCMM",
        (const byte*)"\x19\x09" "ABS_MATCH",
        (const byte*)"\x34\x04" "RCMM",
        (const byte*)"\x4c\x12" "IRLib_P11_RCMMs.py",
        (const byte*)"\x73\x0a" "IRsendRCMM",
        (const byte*)"\x24\x0c" "sendRCMMBits",
        (const byte*)"\xe7\x12" "IRLibDecodeBase.py",
        (const byte*)"\x08\x11" "PERCENT_TOLERANCE",
        (const byte*)"\x2c\x07" "RCERROR",
        (const byte*)"\xf5\x0b" "PERCENT_LOW",
        (const byte*)"\xcf\x0c" "PERCENT_HIGH",
        (const byte*)"\xa3\x02" "us",
        (const byte*)"\x13\x0b" "dumpResults",
        (const byte*)"\xd3\x01" "v",
        (const byte*)"\xd1\x01" "t",
        (const byte*)"\x8d\x07" "UNKNOWN",
        (const byte*)"\xa1\x06" "Pnames",
        (const byte*)"\xf0\x03" "s{}",
        (const byte*)"\x85\x01" " ",
        (const byte*)"\x3e\x09" "{:2d}:m{}",
        (const byte*)"\xac\x01" "\x09",
        (const byte*)"\x1f\x07" "verbose",
        (const byte*)"\xc7\x0e" "expectedLength",
        (const byte*)"\x78\x08" "headMark",
        (const byte*)"\x29\x09" "headSpace",
        (const byte*)"\x40\x08" "markData",
        (const byte*)"\xc5\x08" "spaceOne",
        (const byte*)"\x43\x09" "spaceZero",
        (const byte*)"\xbb\x11" "IRLibProtocols.py",
        (const byte*)"\x59\x04" "CYKM",
        (const byte*)"\x0e\x04" "Sony",
        (const byte*)"\x55\x04" "NECx",
        (const byte*)"\x90\x09" "Samsung36",
        (const byte*)"\x42\x09" "G.I.Cable",
        (const byte*)"\xfe\x07" "DirecTV",
        (const byte*)"\x34\x04" "rcmm",
        (const byte*)"\xf7\x10" "IRLibSendBase.py",
        (const byte*)"\x14\x05" "irPWM",
        (const byte*)"\x62\x06" "irSend",
        (const byte*)"\xb9\x0a" "sendBuffer",
        (const byte*)"\x45\x04" "usec",
        (const byte*)"\xf4\x07" "markOne",
        (const byte*)"\x52\x08" "markZero",
        (const byte*)"\xde\x07" "useStop",
        (const byte*)"\x27\x09" "maxExtent",
        (const byte*)"\x01\x0c" "IRrecvPCI.py",
        (const byte*)"\x78\x0a" "enableIRIn",
        (const byte*)"\x89\x0a" "getResults",
        (const byte*)"\xb0\x07" "recvPin",
        (const byte*)"\xeb\x0a" "markExcess",
        (const byte*)"\xe7\x0a" "recvBuffer",
        (const byte*)"\xc8\x0a" "prevLength",
        (const byte*)"\x3a\x08" "lastTime",
        (const byte*)"\xa9\x08" "motor.py",
        (const byte*)"\xc9\x07" "DCMotor",
        (const byte*)"\x4d\x08" "throttle",
        (const byte*)"\x11\x09" "_positive",
        (const byte*)"\x59\x09" "_negative",
        (const byte*)"\xdb\x0c" "positive_pwm",
        (const byte*)"\x93\x0c" "negative_pwm",
        (const byte*)"\xd5\x0e" "exception_type",
        (const byte*)"\x06\x0f" "exception_value",
        (const byte*)"\xcf\x09" "traceback",
        (const byte*)"\xae\x0b" "neopixel.py",
        (const byte*)"\x17\x05" "3.0.1",
        (const byte*)"\x4b\x05" "ORDER",
        (const byte*)"\xc7\x03" "bpp",
        (const byte*)"\x4c\x0a" "brightness",
        (const byte*)"\xe8\x0a" "auto_write",
        (const byte*)"\x32\x09" "_set_item",
        (const byte*)"\x86\x04" "show",
        (const byte*)"\xcb\x01" "n",
        (const byte*)"\xfe\x01" "[",
        (const byte*)"\x89\x02" ", ",
        (const byte*)"\xf8\x01" "]",
        (const byte*)"\xfe\x03" "val",
        (const byte*)"\xb3\x0b" "_brightness",
        (const byte*)"\xd8\x05" "color",
        (const byte*)"\x5f\x08" "servo.py",
        (const byte*)"\xb2\x0a" "_BaseServo",
        (const byte*)"\x98\x05" "Servo",
        (const byte*)"\x95\x0f" "ContinuousServo",
        (const byte*)"\xef\x09" "min_pulse",
        (const byte*)"\xf1\x09" "max_pulse",
        (const byte*)"\x70\x09" "_fraction",
        (const byte*)"\x33\x09" "_min_duty",
        (const byte*)"\xa6\x0b" "_duty_range",
        (const byte*)"\x41\x08" "_pwm_out",
        (const byte*)"\xde\x07" "pwm_out",
        (const byte*)"\x7b\x0f" "actuation_range",
        (const byte*)"\x84\x05" "angle",
        (const byte*)"\xa4\x10" "_actuation_range",
        (const byte*)"\xf0\x04" "_pwm",
        (const byte*)"\x27\x09" "new_angle",
        (const byte*)"\xd7\x0a" "stepper.py",
        (const byte*)"\x7e\x07" "FORWARD",
        (const byte*)"\x0e\x08" "BACKWARD",
        (const byte*)"\x7f\x06" "SINGLE",
        (const byte*)"\xb0\x06" "DOUBLE",
        (const byte*)"\xda\x0a" "INTERLEAVE",
        (const byte*)"\x4d\x09" "MICROSTEP",
        (const byte*)"\x5b\x0c" "StepperMotor",
        (const byte*)"\x3e\x0a" "microsteps",
        (const byte*)"\xfd\x0d" "microstepping",
        (const byte*)"\x6e\x0d" "_update_coils",
        (const byte*)"\xd2\x05" "style",
        (const byte*)"\xd3\x07" "onestep",
        (const byte*)"\xf3\x05" "_coil",
        (const byte*)"\x84\x12" "_current_microstep",
        (const byte*)"\xc1\x0b" "_microsteps",
        (const byte*)"\xad\x06" "_curve",
        (const byte*)"\x32\x04" "ain1",
        (const byte*)"\x31\x04" "ain2",
        (const byte*)"\xd1\x04" "bin1",
        (const byte*)"\xd2\x04" "bin2",
        (const byte*)"\x02\x08" "tslib.py",
        (const byte*)"\xff\x07" "express",
        (const byte*)"\x78\x05" "servo",
        (const byte*)"\x84\x0e" "IRLib_P01_NECd",
        (const byte*)"\x93\x0e" "IRLib_P01_NECs",
        (const byte*)"\x7d\x07" "send_ir",
        (const byte*)"\x2a\x0a" "ir_receive",
        (const byte*)"\xb6\x0e" "reset_receiver",
        (const byte*)"\x5c\x0b" "set_servo_f",
        (const byte*)"\x7b\x0e" "free_servo_pin",
        (const byte*)"\x57\x0e" "create_new_pwm",
        (const byte*)"\x40\x12" "fetch_existing_pwm",
        (const byte*)"\x46\x07" "get_pwm",
        (const byte*)"\x29\x0b" "pin_write_f",
        (const byte*)"\x2b\x09" "mic_level",
        (const byte*)"\xc2\x04" "mean",
        (const byte*)"\x57\x0e" "normalized_rms",
        (const byte*)"\x06\x09" "log_scale",
        (const byte*)"\xb4\x09" "constrain",
        (const byte*)"\x85\x09" "play_riff",
        (const byte*)"\xb5\x0a" "set_lights",
        (const byte*)"\x06\x09" "set_light",
        (const byte*)"\x91\x0e" "set_brightness",
        (const byte*)"\x90\x0b" "pick_random",
        (const byte*)"\xf3\x06" "pixpin",
        (const byte*)"\x12\x05" "CURVE",
        (const byte*)"\x51\x0e" "SCALE_EXPONENT",
        (const byte*)"\xf9\x0b" "NUM_SAMPLES",
        (const byte*)"\xa2\x03" "mic",
        (const byte*)"\x10\x07" "samples",
        (const byte*)"\x54\x0b" "input_floor",
        (const byte*)"\x4f\x0d" "input_ceiling",
        (const byte*)"\xfa\x04" "peak",
        (const byte*)"\x81\x0a" "SAMPLERATE",
        (const byte*)"\xc1\x0b" "output_pins",
        (const byte*)"\x7c\x04" "pwms",
        (const byte*)"\xd3\x0d" "MyDecodeClass",
        (const byte*)"\x6f\x09" "myDecoder",
        (const byte*)"\x28\x0a" "myReceiver",
        (const byte*)"\x17\x0e" "last_ir_number",
        (const byte*)"\x94\x11" "current_ir_number",
        (const byte*)"\x56\x0e" "last_sent_time",
        (const byte*)"\xd6\x15" "last_recieved_address",
        (const byte*)"\x6d\x06" "mySend",
        (const byte*)"\x99\x07" "SENDING",
        (const byte*)"\x5f\x09" "Results!!",
        (const byte*)"\x75\x06" "thresh",
        (const byte*)"\xe7\x0b" "input_value",
        (const byte*)"\x86\x09" "input_min",
        (const byte*)"\x98\x09" "input_max",
        (const byte*)"\x2f\x0a" "output_min",
        (const byte*)"\x31\x0a" "output_max",
        (const byte*)"\x66\x07" "ceiling",
        (const byte*)"\x9e\x04" "riff",
        (const byte*)"\xe5\x04" "freq",
        (const byte*)"\xe4\x05" "beats",
        (const byte*)"\xc6\x01" "c",
        (const byte*)"\xd6\x01" "s",
    },
};

// frozen bytecode for file adafruit_bus_device/__init__.py, scope adafruit_bus_device___init___<module>
STATIC const byte bytecode_data_adafruit_bus_device___init____lt_module_gt_[16] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_adafruit_bus_device_slash___init___dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash___init___dot_py >> 8,
    0x00, 0x00, 0xff,
    0x11, 
    0x5b, 
};
const mp_raw_code_t raw_code_adafruit_bus_device___init____lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device___init____lt_module_gt_,
        .const_table = NULL,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 16,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__[102] = {
    0x09, 0x02, 0x00, 0x03, 0x00, 0x00, 0x10,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x3c, 0x23, 0x29, 0x26, 0x57, 0x52, 0x48, 0x25, 0x00, 0x00, 0xff,
    0x35, 0x00, 0x80, 
    0xb1, 
    0x1e, MP_QSTR_try_lock & 0xff, MP_QSTR_try_lock >> 8,
    0x66, 0x00, 
    0x37, 0xf7, 0x7f, 
    0x40, 0x2c, 0x00, 
    0x3f, 0x0e, 0x00, 
    0xb1, 
    0x1e, MP_QSTR_writeto & 0xff, MP_QSTR_writeto >> 8,
    0xb2, 
    0x17, 0x03, 
    0x66, 0x02, 
    0x32, 
    0x44, 
    0x35, 0x19, 0x80, 
    0x30, 
    0x1c, MP_QSTR_OSError & 0xff, MP_QSTR_OSError >> 8,
    0xf8, 
    0x37, 0x10, 0x80, 
    0x32, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x04, 
    0xb2, 
    0xe1, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x44, 
    0x11, 
    0xb1, 
    0x1e, MP_QSTR_unlock & 0xff, MP_QSTR_unlock >> 8,
    0x66, 0x00, 
    0x32, 
    0x41, 
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_i2c & 0xff, MP_QSTR_i2c >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_device_address & 0xff, MP_QSTR_device_address >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init___0 = {{&mp_type_bytes}, 5, 0, (const byte*)""};
STATIC const mp_obj_str_t const_obj_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init___1 = {{&mp_type_str}, 96, 28, (const byte*)"\x4e\x6f\x20\x49\x32\x43\x20\x64\x65\x76\x69\x63\x65\x20\x61\x74\x20\x61\x64\x64\x72\x65\x73\x73\x3a\x20\x25\x78"};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__[5] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_i2c),
    MP_ROM_QSTR(MP_QSTR_device_address),
    MP_ROM_PTR(&const_obj_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init___0),
    MP_ROM_PTR(&const_obj_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init___1),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 102,
        .n_obj = 2,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto[37] = {
    0x09, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR_readinto & 0xff, MP_QSTR_readinto >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x49, 0x80, 0x0c, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_i2c & 0xff, MP_QSTR_i2c >> 8,
    0x1e, MP_QSTR_readfrom_into & 0xff, MP_QSTR_readfrom_into >> 8,
    0xb0, 
    0x1d, MP_QSTR_device_address & 0xff, MP_QSTR_device_address >> 8,
    0xb1, 
    0x18, 
    0xb2, 
    0x67, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_buf),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x02,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 37,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write[37] = {
    0x09, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x58, 0x80, 0x0d, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_i2c & 0xff, MP_QSTR_i2c >> 8,
    0x1e, MP_QSTR_writeto & 0xff, MP_QSTR_writeto >> 8,
    0xb0, 
    0x1d, MP_QSTR_device_address & 0xff, MP_QSTR_device_address >> 8,
    0xb1, 
    0x18, 
    0xb2, 
    0x67, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_buf),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x02,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 37,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__[35] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x68, 0x23, 0x2c, 0x00, 0x00, 0xff,
    0x35, 0x00, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_i2c & 0xff, MP_QSTR_i2c >> 8,
    0x1e, MP_QSTR_try_lock & 0xff, MP_QSTR_try_lock >> 8,
    0x66, 0x00, 
    0x37, 0xf4, 0x7f, 
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 35,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__[29] = {
    0x04, 0x00, 0x01, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x6d, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_i2c & 0xff, MP_QSTR_i2c >> 8,
    0x1e, MP_QSTR_unlock & 0xff, MP_QSTR_unlock >> 8,
    0x66, 0x00, 
    0x32, 
    0x10, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x01,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 29,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice[65] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
    MP_QSTR_I2CDevice & 0xff, MP_QSTR_I2CDevice >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x8d, 0x1f, 0x80, 0x1b, 0x85, 0x0e, 0x85, 0x0f, 0x85, 0x10, 0x65, 0x40, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_I2CDevice & 0xff, MP_QSTR_I2CDevice >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_readinto & 0xff, MP_QSTR_readinto >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice[5] = {
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___init__),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_readinto),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice_write),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___enter__),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice___exit__),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 65,
        .n_obj = 0,
        .n_raw_code = 5,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/i2c_device.py, scope adafruit_bus_device_i2c_device_<module>
STATIC const byte bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt_[44] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_i2c_device_dot_py >> 8,
    0x81, 0x16, 0x60, 0x40, 0x26, 0x45, 0x00, 0x00, 0xff,
    0x16, MP_QSTR_2_dot_0_dot_2 & 0xff, MP_QSTR_2_dot_0_dot_2 >> 8,
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x00, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x01, 
    0x16, MP_QSTR_I2CDevice & 0xff, MP_QSTR_I2CDevice >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_I2CDevice & 0xff, MP_QSTR_I2CDevice >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_bus_device_i2c_device__lt_module_gt__0 = {{&mp_type_str}, 209, 64, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x42\x75\x73\x44\x65\x76\x69\x63\x65\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_i2c_device__lt_module_gt_[2] = {
    MP_ROM_PTR(&const_obj_adafruit_bus_device_i2c_device__lt_module_gt__0),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_i2c_device__lt_module_gt__I2CDevice),
};
const mp_raw_code_t raw_code_adafruit_bus_device_i2c_device__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_i2c_device__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_i2c_device__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 1,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/spi_device.py, scope adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__
STATIC const byte bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__[69] = {
    0x0b, 0x00, 0x08, 0x03, 0x04, 0x00, 0x0f,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py >> 8,
    0x81, 0x44, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x00, 0x00, 0xff,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0xb3, 
    0xb0, 
    0x26, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0xb4, 
    0xb0, 
    0x26, MP_QSTR_polarity & 0xff, MP_QSTR_polarity >> 8,
    0xb5, 
    0xb0, 
    0x26, MP_QSTR_phase & 0xff, MP_QSTR_phase >> 8,
    0xb6, 
    0xb0, 
    0x26, MP_QSTR_extra_clocks & 0xff, MP_QSTR_extra_clocks >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_chip_select & 0xff, MP_QSTR_chip_select >> 8,
    0xb0, 
    0x1d, MP_QSTR_chip_select & 0xff, MP_QSTR_chip_select >> 8,
    0x1e, MP_QSTR_switch_to_output & 0xff, MP_QSTR_switch_to_output >> 8,
    0x16, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x12, 
    0x66, 0x82, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__[7] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_spi),
    MP_ROM_QSTR(MP_QSTR_chip_select),
    MP_ROM_QSTR(MP_QSTR_baudrate),
    MP_ROM_QSTR(MP_QSTR_polarity),
    MP_ROM_QSTR(MP_QSTR_phase),
    MP_ROM_QSTR(MP_QSTR_extra_clocks),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 69,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/spi_device.py, scope adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__
STATIC const byte bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__[81] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py >> 8,
    0x81, 0x4d, 0x23, 0x2c, 0x38, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x35, 0x00, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0x1e, MP_QSTR_try_lock & 0xff, MP_QSTR_try_lock >> 8,
    0x66, 0x00, 
    0x37, 0xf4, 0x7f, 
    0xb0, 
    0x1d, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0x1e, MP_QSTR_configure & 0xff, MP_QSTR_configure >> 8,
    0x16, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0xb0, 
    0x1d, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0x16, MP_QSTR_polarity & 0xff, MP_QSTR_polarity >> 8,
    0xb0, 
    0x1d, MP_QSTR_polarity & 0xff, MP_QSTR_polarity >> 8,
    0x16, MP_QSTR_phase & 0xff, MP_QSTR_phase >> 8,
    0xb0, 
    0x1d, MP_QSTR_phase & 0xff, MP_QSTR_phase >> 8,
    0x66, 0x86, 0x00, 
    0x32, 
    0x10, 
    0xb0, 
    0x1d, MP_QSTR_chip_select & 0xff, MP_QSTR_chip_select >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb0, 
    0x1d, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 81,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/spi_device.py, scope adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__
STATIC const byte bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__[118] = {
    0x0a, 0x00, 0x01, 0x01, 0x00, 0x00, 0x13,
    MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py >> 8,
    0x81, 0x55, 0x28, 0x29, 0x27, 0x26, 0x27, 0x2b, 0x24, 0x27, 0x35, 0x2a, 0x00, 0x00, 0xff,
    0x12, 
    0xb0, 
    0x1d, MP_QSTR_chip_select & 0xff, MP_QSTR_chip_select >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb0, 
    0x1d, MP_QSTR_extra_clocks & 0xff, MP_QSTR_extra_clocks >> 8,
    0x80, 
    0xf1, 
    0x37, 0x3f, 0x80, 
    0x1c, MP_QSTR_bytearray & 0xff, MP_QSTR_bytearray >> 8,
    0x81, 
    0x64, 0x01, 
    0xc2, 
    0x14, 0x81, 0x7f, 
    0xb2, 
    0x80, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR_extra_clocks & 0xff, MP_QSTR_extra_clocks >> 8,
    0x88, 
    0xdf, 
    0xc3, 
    0xb0, 
    0x1d, MP_QSTR_extra_clocks & 0xff, MP_QSTR_extra_clocks >> 8,
    0x88, 
    0xe1, 
    0x80, 
    0xf5, 
    0x37, 0x04, 0x80, 
    0xb3, 
    0x81, 
    0xe9, 
    0xc3, 
    0xb3, 
    0x80, 
    0x35, 0x0f, 0x80, 
    0x30, 
    0xc4, 
    0xb0, 
    0x1d, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0x1e, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0xb2, 
    0x66, 0x01, 
    0x32, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xeb, 0x7f, 
    0x32, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR_spi & 0xff, MP_QSTR_spi >> 8,
    0x1e, MP_QSTR_unlock & 0xff, MP_QSTR_unlock >> 8,
    0x66, 0x00, 
    0x32, 
    0x10, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x01,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 118,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/spi_device.py, scope adafruit_bus_device_spi_device__lt_module_gt__SPIDevice
STATIC const byte bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice[78] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    MP_QSTR_SPIDevice & 0xff, MP_QSTR_SPIDevice >> 8,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py >> 8,
    0x8d, 0x20, 0x80, 0x23, 0x7f, 0x60, 0x60, 0x85, 0x08, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_SPIDevice & 0xff, MP_QSTR_SPIDevice >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x14, 0x86, 0x8d, 0x20, 
    0x16, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0x54, 
    0x80, 
    0x16, MP_QSTR_polarity & 0xff, MP_QSTR_polarity >> 8,
    0x54, 
    0x80, 
    0x16, MP_QSTR_phase & 0xff, MP_QSTR_phase >> 8,
    0x54, 
    0x80, 
    0x16, MP_QSTR_extra_clocks & 0xff, MP_QSTR_extra_clocks >> 8,
    0x54, 
    0x61, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice[3] = {
    MP_ROM_PTR(&raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___init__),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___enter__),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice___exit__),
};
STATIC const mp_raw_code_t raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 78,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file adafruit_bus_device/spi_device.py, scope adafruit_bus_device_spi_device_<module>
STATIC const byte bytecode_data_adafruit_bus_device_spi_device__lt_module_gt_[44] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py & 0xff, MP_QSTR_adafruit_bus_device_slash_spi_device_dot_py >> 8,
    0x81, 0x17, 0x60, 0x40, 0x26, 0x45, 0x00, 0x00, 0xff,
    0x16, MP_QSTR_2_dot_0_dot_2 & 0xff, MP_QSTR_2_dot_0_dot_2 >> 8,
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x00, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x01, 
    0x16, MP_QSTR_SPIDevice & 0xff, MP_QSTR_SPIDevice >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_SPIDevice & 0xff, MP_QSTR_SPIDevice >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_bus_device_spi_device__lt_module_gt__0 = {{&mp_type_str}, 209, 64, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x42\x75\x73\x44\x65\x76\x69\x63\x65\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_adafruit_bus_device_spi_device__lt_module_gt_[2] = {
    MP_ROM_PTR(&const_obj_adafruit_bus_device_spi_device__lt_module_gt__0),
    MP_ROM_PTR(&raw_code_adafruit_bus_device_spi_device__lt_module_gt__SPIDevice),
};
const mp_raw_code_t raw_code_adafruit_bus_device_spi_device__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_bus_device_spi_device__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_bus_device_spi_device__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 1,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH___init__
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH___init__[172] = {
    0x08, 0x00, 0x00, 0x03, 0x00, 0x02, 0x17,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x46, 0x28, 0x27, 0x49, 0x2b, 0x4b, 0x49, 0x45, 0x4b, 0x4b, 0x69, 0x25, 0x25, 0x27, 0x30, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0x8f, 
    0x66, 0x01, 
    0xc3, 
    0xb3, 
    0x14, 0x33, 
    0xf5, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_RuntimeError & 0xff, MP_QSTR_RuntimeError >> 8,
    0x17, 0x03, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa4, 
    0x14, 0x81, 0x00, 
    0x66, 0x02, 
    0x32, 
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_sleep & 0xff, MP_QSTR_sleep >> 8,
    0x17, 0x04, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa0, 
    0x87, 
    0x66, 0x02, 
    0x32, 
    0x87, 
    0xb0, 
    0x26, MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa3, 
    0x14, 0x81, 0x08, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x9f, 
    0x14, 0x81, 0x00, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa4, 
    0x88, 
    0x66, 0x02, 
    0x32, 
    0xb1, 
    0xb0, 
    0x26, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR__int2 & 0xff, MP_QSTR__int2 >> 8,
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x37, 0x20, 0x80, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Direction & 0xff, MP_QSTR_Direction >> 8,
    0x1d, MP_QSTR_INPUT & 0xff, MP_QSTR_INPUT >> 8,
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x26, MP_QSTR_direction & 0xff, MP_QSTR_direction >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Pull & 0xff, MP_QSTR_Pull >> 8,
    0x1d, MP_QSTR_UP & 0xff, MP_QSTR_UP >> 8,
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x26, MP_QSTR_pull & 0xff, MP_QSTR_pull >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH___init___0 = {{&mp_type_str}, 176, 22, (const byte*)"\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x66\x69\x6e\x64\x20\x4c\x49\x53\x33\x44\x48\x21"};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH___init___1 = {{&mp_type_float}, 0.01};
#endif
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH___init__[5] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_int1),
    MP_ROM_QSTR(MP_QSTR_int2),
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH___init___0),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH___init___1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbca3d70a),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 172,
        .n_obj = 2,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate[33] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0c,
    MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x60, 0x60, 0x20, 0x28, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0xa0, 
    0x66, 0x01, 
    0xc1, 
    0xb1, 
    0x84, 
    0xdb, 
    0x8f, 
    0xd9, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 33,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2[50] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0c,
    MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x69, 0x28, 0x26, 0x26, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0xa0, 
    0x66, 0x01, 
    0xc2, 
    0xb2, 
    0x14, 0xfe, 0x0f, 
    0xe6, 
    0xc2, 
    0xb2, 
    0xb1, 
    0x84, 
    0xda, 
    0xe4, 
    0xc2, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa0, 
    0xb2, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_rate),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 50,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_range
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range[32] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x70, 0x40, 0x28, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0xa3, 
    0x66, 0x01, 
    0xc1, 
    0xb1, 
    0x84, 
    0xdb, 
    0x83, 
    0xd9, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_range = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_range
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range2[49] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0c,
    MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x77, 0x28, 0x25, 0x26, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0xa3, 
    0x66, 0x01, 
    0xc2, 
    0xb2, 
    0x14, 0x4f, 
    0xe6, 
    0xc2, 
    0xb2, 
    0xb1, 
    0x84, 
    0xda, 
    0xe4, 
    0xc2, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa3, 
    0xb2, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range2[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_range_value),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_range2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range2,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_range2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 49,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration[135] = {
    0x0d, 0x00, 0x00, 0x01, 0x00, 0x00, 0x15,
    MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0x7e, 0x20, 0x22, 0x25, 0x26, 0x27, 0x26, 0x27, 0x26, 0x27, 0x26, 0x48, 0x5a, 0x00, 0x00, 0xff,
    0x81, 
    0xc1, 
    0xb0, 
    0x1d, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0xc2, 
    0xb2, 
    0x83, 
    0xf2, 
    0x37, 0x07, 0x80, 
    0x14, 0x8a, 0x55, 
    0xc1, 
    0x35, 0x28, 0x80, 
    0xb2, 
    0x82, 
    0xf2, 
    0x37, 0x07, 0x80, 
    0x14, 0xa0, 0x00, 
    0xc1, 
    0x35, 0x1b, 0x80, 
    0xb2, 
    0x81, 
    0xf2, 
    0x37, 0x07, 0x80, 
    0x14, 0xbf, 0x7e, 
    0xc1, 
    0x35, 0x0e, 0x80, 
    0xb2, 
    0x80, 
    0xf2, 
    0x37, 0x08, 0x80, 
    0x14, 0x80, 0xff, 0x7c, 
    0xc1, 
    0x35, 0x00, 0x80, 
    0x1c, MP_QSTR_struct & 0xff, MP_QSTR_struct >> 8,
    0x1e, MP_QSTR_unpack & 0xff, MP_QSTR_unpack >> 8,
    0x16, MP_QSTR__lt_hhh & 0xff, MP_QSTR__lt_hhh >> 8,
    0xb0, 
    0x1e, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0x14, 0x81, 0x28, 
    0x86, 
    0x66, 0x02, 
    0x66, 0x02, 
    0x59, 0x03, 
    0xc3, 
    0xc4, 
    0xc5, 
    0xb3, 
    0xb1, 
    0xe0, 
    0x17, 0x01, 
    0xde, 
    0xb4, 
    0xb1, 
    0xe0, 
    0x17, 0x02, 
    0xde, 
    0xb5, 
    0xb1, 
    0xe0, 
    0x17, 0x03, 
    0xde, 
    0x50, 0x03, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_0 = {{&mp_type_float}, 9.806000000000001};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_1 = {{&mp_type_float}, 9.806000000000001};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_2 = {{&mp_type_float}, 9.806000000000001};
#endif
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc19ce562),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc19ce562),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration_2),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc19ce562),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 135,
        .n_obj = 3,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_shake_<genexpr>
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_[35] = {
    0x09, 0x00, 0x04, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR__lt_genexpr_gt_ & 0xff, MP_QSTR__lt_genexpr_gt_ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x89, 0xa5, 0x00, 0x00, 0xff,
    0x18, 
    0xb1, 
    0x18, 
    0x18, 
    0x43, 0x0a, 0x00, 
    0xc2, 
    0xb2, 
    0x1a, 0x00, 
    0xe0, 
    0x5d, 
    0x32, 
    0x35, 0xf3, 0x7f, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_[2] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x04,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 35,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_shake_<lambda>
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_[20] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR__lt_lambda_gt_ & 0xff, MP_QSTR__lt_lambda_gt_ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0xa6, 0x00, 0x00, 0xff,
    0xb0, 
    0xb0, 
    0xde, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_[1] = {
    MP_ROM_QSTR(MP_QSTR_x),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 20,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_shake
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake[127] = {
    0x10, 0x00, 0x00, 0x04, 0x00, 0x03, 0x12,
    MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x82, 0x8f, 0x80, 0x0b, 0x26, 0x88, 0x08, 0x38, 0x37, 0x2e, 0x36, 0x00, 0x00, 0x02, 0xff,
    0x80, 
    0x80, 
    0x80, 
    0x50, 0x03, 
    0xc4, 
    0x1a, 0x02, 
    0x80, 
    0x35, 0x29, 0x80, 
    0x30, 
    0xc5, 
    0x1c, MP_QSTR_tuple & 0xff, MP_QSTR_tuple >> 8,
    0x1c, MP_QSTR_map & 0xff, MP_QSTR_map >> 8,
    0x1c, MP_QSTR_sum & 0xff, MP_QSTR_sum >> 8,
    0x1c, MP_QSTR_zip & 0xff, MP_QSTR_zip >> 8,
    0xb4, 
    0xb0, 
    0x1d, MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    0x64, 0x02, 
    0x64, 0x02, 
    0x64, 0x01, 
    0xc4, 
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_sleep & 0xff, MP_QSTR_sleep >> 8,
    0xb3, 
    0x1a, 0x02, 
    0xe0, 
    0x66, 0x01, 
    0x32, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xd1, 0x7f, 
    0x32, 
    0x32, 
    0x1c, MP_QSTR_tuple & 0xff, MP_QSTR_tuple >> 8,
    0xb2, 
    0x62, 0x04, 0x01, 
    0xb4, 
    0x42, 
    0x64, 0x01, 
    0x64, 0x01, 
    0xc6, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_sqrt & 0xff, MP_QSTR_sqrt >> 8,
    0x1c, MP_QSTR_sum & 0xff, MP_QSTR_sum >> 8,
    0x1c, MP_QSTR_map & 0xff, MP_QSTR_map >> 8,
    0x60, 0x05, 
    0xb6, 
    0x64, 0x02, 
    0x64, 0x01, 
    0x66, 0x01, 
    0xc7, 
    0xb7, 
    0xb1, 
    0xf1, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake[6] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_shake_threshold),
    MP_ROM_QSTR(MP_QSTR_avg_count),
    MP_ROM_QSTR(MP_QSTR_total_delay),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_genexpr_gt_),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake__lt_lambda_gt_),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_shake,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 127,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw[72] = {
    0x0a, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0c,
    MP_QSTR_read_adc_raw & 0xff, MP_QSTR_read_adc_raw >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0xaa, 0x60, 0x2c, 0x49, 0x00, 0x00, 0xff,
    0xb1, 
    0x81, 
    0xf0, 
    0x36, 0x06, 0x80, 
    0xb1, 
    0x83, 
    0xf1, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x02, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x1c, MP_QSTR_struct & 0xff, MP_QSTR_struct >> 8,
    0x1e, MP_QSTR_unpack & 0xff, MP_QSTR_unpack >> 8,
    0x16, MP_QSTR__lt_h & 0xff, MP_QSTR__lt_h >> 8,
    0xb0, 
    0x1e, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0x88, 
    0xb1, 
    0x81, 
    0xdd, 
    0x82, 
    0xde, 
    0xdc, 
    0x14, 0x81, 0x00, 
    0xd7, 
    0x82, 
    0x66, 0x02, 
    0x66, 0x02, 
    0x80, 
    0x21, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw_0 = {{&mp_type_str}, 9, 27, (const byte*)"\x41\x44\x43\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x61\x20\x76\x61\x6c\x75\x65\x20\x31\x20\x74\x6f\x20\x33\x21"};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_adc),
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw_0),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 72,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV[48] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0d,
    MP_QSTR_read_adc_mV & 0xff, MP_QSTR_read_adc_mV >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0xb3, 0x60, 0x20, 0x88, 0x0b, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_read_adc_raw & 0xff, MP_QSTR_read_adc_raw >> 8,
    0xb1, 
    0x66, 0x01, 
    0xc2, 
    0x14, 0x8e, 0x08, 
    0xb2, 
    0x14, 0x81, 0xfe, 0x00, 
    0xdc, 
    0x14, 0xf8, 0x7c, 
    0x14, 0x83, 0xfc, 0x00, 
    0xe0, 
    0xde, 
    0xdc, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_adc),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 48,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_tapped
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped[57] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_tapped & 0xff, MP_QSTR_tapped >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0xc6, 0x80, 0x12, 0x31, 0x22, 0x29, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x37, 0x0c, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0x14, 0x39, 
    0x66, 0x01, 
    0xc1, 
    0xb1, 
    0x14, 0x80, 0x40, 
    0xd9, 
    0x80, 
    0xf1, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 57,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap[223] = {
    0x0d, 0x00, 0x08, 0x03, 0x04, 0x00, 0x1e,
    MP_QSTR_set_tap & 0xff, MP_QSTR_set_tap >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x81, 0xdf, 0x80, 0x0e, 0x32, 0x29, 0x2e, 0x49, 0x28, 0x4c, 0x2d, 0x2a, 0x42, 0x4d, 0x26, 0x26, 0x22, 0x26, 0x42, 0x2a, 0x2e, 0x2a, 0x2a, 0x00, 0x00, 0xff,
    0xb1, 
    0x80, 
    0xf0, 
    0x36, 0x06, 0x80, 
    0xb1, 
    0x82, 
    0xf1, 
    0x37, 0x0f, 0x80, 
    0xb6, 
    0x11, 
    0xf7, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x07, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb2, 
    0x14, 0x80, 0x7f, 
    0xf1, 
    0x36, 0x06, 0x80, 
    0xb2, 
    0x80, 
    0xf0, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x08, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb0, 
    0x1e, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0xa2, 
    0x66, 0x01, 
    0xc7, 
    0xb1, 
    0x80, 
    0xf2, 
    0x37, 0x1f, 0x80, 
    0xb6, 
    0x11, 
    0xf7, 
    0x37, 0x19, 0x80, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa2, 
    0xb7, 
    0x14, 0xfe, 0x7f, 
    0xd9, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x38, 
    0x80, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xa2, 
    0xb7, 
    0x14, 0x81, 0x00, 
    0xd7, 
    0x66, 0x02, 
    0x32, 
    0xb6, 
    0x11, 
    0xf7, 
    0x37, 0x10, 0x80, 
    0xb1, 
    0x81, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x95, 
    0xc6, 
    0xb1, 
    0x82, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0xaa, 
    0xc6, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x38, 
    0xb6, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x3a, 
    0x14, 0x81, 0x00, 
    0xb2, 
    0xd7, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x3b, 
    0xb3, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x3c, 
    0xb4, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x14, 0x3d, 
    0xb5, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap_0 = {{&mp_type_str}, 9, 60, (const byte*)"\x54\x61\x70\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x30\x20\x28\x64\x69\x73\x61\x62\x6c\x65\x64\x29\x2c\x20\x31\x20\x28\x73\x69\x6e\x67\x6c\x65\x20\x74\x61\x70\x29\x2c\x20\x6f\x72\x20\x32\x20\x28\x64\x6f\x75\x62\x6c\x65\x20\x74\x61\x70\x29\x21"};
STATIC const mp_obj_str_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap_1 = {{&mp_type_str}, 34, 30, (const byte*)"\x54\x68\x72\x65\x73\x68\x6f\x6c\x64\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x20\x28\x30\x2d\x31\x32\x37\x29"};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap[9] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_tap),
    MP_ROM_QSTR(MP_QSTR_threshold),
    MP_ROM_QSTR(MP_QSTR_time_limit),
    MP_ROM_QSTR(MP_QSTR_time_latency),
    MP_ROM_QSTR(MP_QSTR_time_window),
    MP_ROM_QSTR(MP_QSTR_click_cfg),
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap_0),
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap_1),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 223,
        .n_obj = 2,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte[27] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x09, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0xb1, 
    0x81, 
    0x66, 0x02, 
    0x80, 
    0x21, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 27,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH__read_register
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register[23] = {
    0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x0f, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_NotImplementedError & 0xff, MP_QSTR_NotImplementedError >> 8,
    0x5c, 0x01, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_length),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte[23] = {
    0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x14, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_NotImplementedError & 0xff, MP_QSTR_NotImplementedError >> 8,
    0x5c, 0x01, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH[201] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25,
    MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x8d, 0x43, 0x20, 0x8a, 0x1a, 0x8a, 0x09, 0x8d, 0x07, 0x8a, 0x07, 0x8d, 0x07, 0x8a, 0x12, 0x8c, 0x1b, 0x85, 0x09, 0x85, 0x12, 0x8a, 0x19, 0x7e, 0x80, 0x27, 0x65, 0x20, 0x65, 0x60, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x11, 
    0x11, 
    0x50, 0x02, 
    0x18, 
    0x61, 0x01, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x02, 
    0x64, 0x01, 
    0x24, MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    0x1b, MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x03, 
    0x64, 0x01, 
    0x24, MP_QSTR_data_rate & 0xff, MP_QSTR_data_rate >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x04, 
    0x64, 0x01, 
    0x24, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1b, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x05, 
    0x64, 0x01, 
    0x24, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x06, 
    0x64, 0x01, 
    0x24, MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    0x9e, 
    0x8a, 
    0x17, 0x00, 
    0x50, 0x03, 
    0x18, 
    0x61, 0x07, 
    0x24, MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    0x60, 0x08, 
    0x24, MP_QSTR_read_adc_raw & 0xff, MP_QSTR_read_adc_raw >> 8,
    0x60, 0x09, 
    0x24, MP_QSTR_read_adc_mV & 0xff, MP_QSTR_read_adc_mV >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0a, 
    0x64, 0x01, 
    0x24, MP_QSTR_tapped & 0xff, MP_QSTR_tapped >> 8,
    0x18, 
    0x53, 0x00, 
    0x8a, 
    0x16, MP_QSTR_time_limit & 0xff, MP_QSTR_time_limit >> 8,
    0x54, 
    0x94, 
    0x16, MP_QSTR_time_latency & 0xff, MP_QSTR_time_latency >> 8,
    0x54, 
    0x14, 0x81, 0x7f, 
    0x16, MP_QSTR_time_window & 0xff, MP_QSTR_time_window >> 8,
    0x54, 
    0x11, 
    0x16, MP_QSTR_click_cfg & 0xff, MP_QSTR_click_cfg >> 8,
    0x54, 
    0x61, 0x0b, 
    0x24, MP_QSTR_set_tap & 0xff, MP_QSTR_set_tap >> 8,
    0x60, 0x0c, 
    0x24, MP_QSTR__read_register_byte & 0xff, MP_QSTR__read_register_byte >> 8,
    0x60, 0x0d, 
    0x24, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0x60, 0x0e, 
    0x24, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_0 = {{&mp_type_float}, 0.1};
#endif
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH[15] = {
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__LIS3DH_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbe4cccce),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH___init__),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_data_rate2),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_range),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_range2),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_acceleration),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_shake),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_raw),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_read_adc_mV),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_tapped),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_set_tap),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register_byte),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__read_register),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH__write_register_byte),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 201,
        .n_obj = 1,
        .n_raw_code = 14,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__[73] = {
    0x0d, 0x00, 0x08, 0x03, 0x03, 0x00, 0x0c,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x1b, 0x29, 0x2c, 0x2a, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_adafruit_bus_device_dot_i2c_device & 0xff, MP_QSTR_adafruit_bus_device_dot_i2c_device >> 8,
    0x1d, MP_QSTR_i2c_device & 0xff, MP_QSTR_i2c_device >> 8,
    0xc6, 
    0xb6, 
    0x1e, MP_QSTR_I2CDevice & 0xff, MP_QSTR_I2CDevice >> 8,
    0xb2, 
    0xb3, 
    0x66, 0x02, 
    0xb1, 
    0x26, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x1c, MP_QSTR_bytearray & 0xff, MP_QSTR_bytearray >> 8,
    0x86, 
    0x64, 0x01, 
    0xb1, 
    0x26, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x1c, MP_QSTR_super & 0xff, MP_QSTR_super >> 8,
    0x1a, 0x00, 
    0xb1, 
    0x1f, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x16, MP_QSTR_int1 & 0xff, MP_QSTR_int1 >> 8,
    0xb4, 
    0x16, MP_QSTR_int2 & 0xff, MP_QSTR_int2 >> 8,
    0xb5, 
    0x66, 0x84, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__[6] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_i2c),
    MP_ROM_QSTR(MP_QSTR_address),
    MP_ROM_QSTR(MP_QSTR_int1),
    MP_ROM_QSTR(MP_QSTR_int2),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register[90] = {
    0x0d, 0x01, 0x00, 0x03, 0x00, 0x00, 0x0d,
    MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x21, 0x2b, 0x28, 0x34, 0x34, 0x00, 0x00, 0xff,
    0xb1, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x80, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x3d, 0x30, 0x00, 
    0xc3, 
    0xb3, 
    0x1e, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x81, 
    0x66, 0x84, 0x01, 
    0x32, 
    0xb3, 
    0x1e, MP_QSTR_readinto & 0xff, MP_QSTR_readinto >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0xb2, 
    0x66, 0x84, 0x01, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x5b, 
    0x44, 
    0x11, 
    0x3e, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_length),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 90,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte[75] = {
    0x0d, 0x01, 0x00, 0x03, 0x00, 0x00, 0x0c,
    MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x28, 0x2b, 0x2b, 0x28, 0x00, 0x00, 0xff,
    0xb1, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x80, 
    0x27, 
    0xb2, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x81, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x3d, 0x17, 0x00, 
    0xc3, 
    0xb3, 
    0x1e, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x82, 
    0x66, 0x84, 0x01, 
    0x32, 
    0x44, 
    0x11, 
    0x3e, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 75,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_I2C
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C[71] = {
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
    MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x9e, 0x18, 0x40, 0x79, 0x60, 0x85, 0x07, 0x00, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x98, 
    0x16, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x54, 
    0x11, 
    0x16, MP_QSTR_int1 & 0xff, MP_QSTR_int1 >> 8,
    0x54, 
    0x11, 
    0x16, MP_QSTR_int2 & 0xff, MP_QSTR_int2 >> 8,
    0x54, 
    0xb0, 
    0x63, 0x00, 0x01, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C[3] = {
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C___init__),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__read_register),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C__write_register_byte),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 71,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__[78] = {
    0x0e, 0x00, 0x08, 0x04, 0x03, 0x00, 0x0c,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x32, 0x29, 0x31, 0x2a, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_adafruit_bus_device_dot_spi_device & 0xff, MP_QSTR_adafruit_bus_device_dot_spi_device >> 8,
    0x1d, MP_QSTR_spi_device & 0xff, MP_QSTR_spi_device >> 8,
    0xc7, 
    0xb7, 
    0x1e, MP_QSTR_SPIDevice & 0xff, MP_QSTR_SPIDevice >> 8,
    0xb2, 
    0xb3, 
    0x16, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0xb4, 
    0x66, 0x82, 0x02, 
    0xb1, 
    0x26, MP_QSTR__spi & 0xff, MP_QSTR__spi >> 8,
    0x1c, MP_QSTR_bytearray & 0xff, MP_QSTR_bytearray >> 8,
    0x86, 
    0x64, 0x01, 
    0xb1, 
    0x26, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x1c, MP_QSTR_super & 0xff, MP_QSTR_super >> 8,
    0x1a, 0x00, 
    0xb1, 
    0x1f, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x16, MP_QSTR_int1 & 0xff, MP_QSTR_int1 >> 8,
    0xb5, 
    0x16, MP_QSTR_int2 & 0xff, MP_QSTR_int2 >> 8,
    0xb6, 
    0x66, 0x84, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__[7] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_spi),
    MP_ROM_QSTR(MP_QSTR_cs),
    MP_ROM_QSTR(MP_QSTR_baudrate),
    MP_ROM_QSTR(MP_QSTR_int1),
    MP_ROM_QSTR(MP_QSTR_int2),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 78,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register[120] = {
    0x0d, 0x01, 0x00, 0x03, 0x00, 0x00, 0x0f,
    MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x38, 0x26, 0x52, 0x2f, 0x28, 0x34, 0x34, 0x00, 0x00, 0xff,
    0xb2, 
    0x81, 
    0xf2, 
    0x37, 0x12, 0x80, 
    0xb1, 
    0x14, 0x81, 0x00, 
    0xd7, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x80, 
    0x27, 
    0x35, 0x0f, 0x80, 
    0xb1, 
    0x14, 0x81, 0x40, 
    0xd7, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x80, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR__spi & 0xff, MP_QSTR__spi >> 8,
    0x3d, 0x30, 0x00, 
    0xc3, 
    0xb3, 
    0x1e, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x81, 
    0x66, 0x84, 0x01, 
    0x32, 
    0xb3, 
    0x1e, MP_QSTR_readinto & 0xff, MP_QSTR_readinto >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0xb2, 
    0x66, 0x84, 0x01, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x5b, 
    0x44, 
    0x11, 
    0x3e, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_length),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 120,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte[79] = {
    0x0d, 0x01, 0x00, 0x03, 0x00, 0x00, 0x0c,
    MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x91, 0x42, 0x2f, 0x2b, 0x28, 0x00, 0x00, 0xff,
    0xb1, 
    0x14, 0x80, 0x7f, 
    0xd9, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x80, 
    0x27, 
    0xb2, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x81, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR__spi & 0xff, MP_QSTR__spi >> 8,
    0x3d, 0x17, 0x00, 
    0xc3, 
    0xb3, 
    0x1e, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0xb0, 
    0x1d, MP_QSTR__buffer & 0xff, MP_QSTR__buffer >> 8,
    0x16, MP_QSTR_start & 0xff, MP_QSTR_start >> 8,
    0x80, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x82, 
    0x66, 0x84, 0x01, 
    0x32, 
    0x44, 
    0x11, 
    0x3e, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_register),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 79,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh__lt_module_gt__LIS3DH_SPI
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI[74] = {
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
    MP_QSTR_LIS3DH_SPI & 0xff, MP_QSTR_LIS3DH_SPI >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x9e, 0x2f, 0x40, 0x7c, 0x60, 0x85, 0x0a, 0x00, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_LIS3DH_SPI & 0xff, MP_QSTR_LIS3DH_SPI >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x14, 0x86, 0x8d, 0x20, 
    0x16, MP_QSTR_baudrate & 0xff, MP_QSTR_baudrate >> 8,
    0x54, 
    0x11, 
    0x16, MP_QSTR_int1 & 0xff, MP_QSTR_int1 >> 8,
    0x54, 
    0x11, 
    0x16, MP_QSTR_int2 & 0xff, MP_QSTR_int2 >> 8,
    0x54, 
    0xb0, 
    0x63, 0x00, 0x01, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR__read_register & 0xff, MP_QSTR__read_register >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR__write_register_byte & 0xff, MP_QSTR__write_register_byte >> 8,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI[3] = {
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI___init__),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__read_register),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI__write_register_byte),
};
STATIC const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 74,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file adafruit_lis3dh.py, scope adafruit_lis3dh_<module>
STATIC const byte bytecode_data_adafruit_lis3dh__lt_module_gt_[319] = {
    0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x38,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_adafruit_lis3dh_dot_py & 0xff, MP_QSTR_adafruit_lis3dh_dot_py >> 8,
    0x61, 0x40, 0x80, 0x0b, 0x28, 0x28, 0x28, 0x23, 0x55, 0x4d, 0x50, 0x26, 0x65, 0x20, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x65, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x64, 0x20, 0x8b, 0xd5, 0x8e, 0x17, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x24, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x24, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x3f, 0x0c, 0x00, 
    0x80, 
    0x11, 
    0x68, MP_QSTR_struct & 0xff, MP_QSTR_struct >> 8,
    0x24, MP_QSTR_struct & 0xff, MP_QSTR_struct >> 8,
    0x44, 
    0x35, 0x16, 0x80, 
    0x30, 
    0x1b, MP_QSTR_ImportError & 0xff, MP_QSTR_ImportError >> 8,
    0xf8, 
    0x37, 0x0d, 0x80, 
    0x32, 
    0x80, 
    0x11, 
    0x68, MP_QSTR_ustruct & 0xff, MP_QSTR_ustruct >> 8,
    0x24, MP_QSTR_struct & 0xff, MP_QSTR_struct >> 8,
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x80, 
    0x16, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x50, 0x01, 
    0x68, MP_QSTR_micropython & 0xff, MP_QSTR_micropython >> 8,
    0x69, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x24, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x32, 
    0x16, MP_QSTR_4_dot_0_dot_0 & 0xff, MP_QSTR_4_dot_0_dot_0 >> 8,
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x00, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x88, 
    0x24, MP_QSTR_REG_OUTADC1_L & 0xff, MP_QSTR_REG_OUTADC1_L >> 8,
    0x8f, 
    0x24, MP_QSTR_REG_WHOAMI & 0xff, MP_QSTR_REG_WHOAMI >> 8,
    0x9f, 
    0x24, MP_QSTR_REG_TEMPCFG & 0xff, MP_QSTR_REG_TEMPCFG >> 8,
    0xa0, 
    0x24, MP_QSTR_REG_CTRL1 & 0xff, MP_QSTR_REG_CTRL1 >> 8,
    0xa2, 
    0x24, MP_QSTR_REG_CTRL3 & 0xff, MP_QSTR_REG_CTRL3 >> 8,
    0xa3, 
    0x24, MP_QSTR_REG_CTRL4 & 0xff, MP_QSTR_REG_CTRL4 >> 8,
    0xa4, 
    0x24, MP_QSTR_REG_CTRL5 & 0xff, MP_QSTR_REG_CTRL5 >> 8,
    0xa8, 
    0x24, MP_QSTR_REG_OUT_X_L & 0xff, MP_QSTR_REG_OUT_X_L >> 8,
    0x14, 0x31, 
    0x24, MP_QSTR_REG_INT1SRC & 0xff, MP_QSTR_REG_INT1SRC >> 8,
    0x14, 0x38, 
    0x24, MP_QSTR_REG_CLICKCFG & 0xff, MP_QSTR_REG_CLICKCFG >> 8,
    0x14, 0x39, 
    0x24, MP_QSTR_REG_CLICKSRC & 0xff, MP_QSTR_REG_CLICKSRC >> 8,
    0x14, 0x3a, 
    0x24, MP_QSTR_REG_CLICKTHS & 0xff, MP_QSTR_REG_CLICKTHS >> 8,
    0x14, 0x3b, 
    0x24, MP_QSTR_REG_TIMELIMIT & 0xff, MP_QSTR_REG_TIMELIMIT >> 8,
    0x14, 0x3c, 
    0x24, MP_QSTR_REG_TIMELATENCY & 0xff, MP_QSTR_REG_TIMELATENCY >> 8,
    0x14, 0x3d, 
    0x24, MP_QSTR_REG_TIMEWINDOW & 0xff, MP_QSTR_REG_TIMEWINDOW >> 8,
    0x83, 
    0x24, MP_QSTR_RANGE_16_G & 0xff, MP_QSTR_RANGE_16_G >> 8,
    0x82, 
    0x24, MP_QSTR_RANGE_8_G & 0xff, MP_QSTR_RANGE_8_G >> 8,
    0x81, 
    0x24, MP_QSTR_RANGE_4_G & 0xff, MP_QSTR_RANGE_4_G >> 8,
    0x80, 
    0x24, MP_QSTR_RANGE_2_G & 0xff, MP_QSTR_RANGE_2_G >> 8,
    0x89, 
    0x24, MP_QSTR_DATARATE_1344_HZ & 0xff, MP_QSTR_DATARATE_1344_HZ >> 8,
    0x87, 
    0x24, MP_QSTR_DATARATE_400_HZ & 0xff, MP_QSTR_DATARATE_400_HZ >> 8,
    0x86, 
    0x24, MP_QSTR_DATARATE_200_HZ & 0xff, MP_QSTR_DATARATE_200_HZ >> 8,
    0x85, 
    0x24, MP_QSTR_DATARATE_100_HZ & 0xff, MP_QSTR_DATARATE_100_HZ >> 8,
    0x84, 
    0x24, MP_QSTR_DATARATE_50_HZ & 0xff, MP_QSTR_DATARATE_50_HZ >> 8,
    0x83, 
    0x24, MP_QSTR_DATARATE_25_HZ & 0xff, MP_QSTR_DATARATE_25_HZ >> 8,
    0x82, 
    0x24, MP_QSTR_DATARATE_10_HZ & 0xff, MP_QSTR_DATARATE_10_HZ >> 8,
    0x81, 
    0x24, MP_QSTR_DATARATE_1_HZ & 0xff, MP_QSTR_DATARATE_1_HZ >> 8,
    0x80, 
    0x24, MP_QSTR_DATARATE_POWERDOWN & 0xff, MP_QSTR_DATARATE_POWERDOWN >> 8,
    0x88, 
    0x24, MP_QSTR_DATARATE_LOWPOWER_1K6HZ & 0xff, MP_QSTR_DATARATE_LOWPOWER_1K6HZ >> 8,
    0x89, 
    0x24, MP_QSTR_DATARATE_LOWPOWER_5KHZ & 0xff, MP_QSTR_DATARATE_LOWPOWER_5KHZ >> 8,
    0x20, 
    0x60, 0x01, 
    0x16, MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    0x1b, MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    0x20, 
    0x60, 0x03, 
    0x16, MP_QSTR_LIS3DH_SPI & 0xff, MP_QSTR_LIS3DH_SPI >> 8,
    0x1b, MP_QSTR_LIS3DH & 0xff, MP_QSTR_LIS3DH >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_LIS3DH_SPI & 0xff, MP_QSTR_LIS3DH_SPI >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_adafruit_lis3dh__lt_module_gt__0 = {{&mp_type_str}, 196, 61, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x4c\x49\x53\x33\x44\x48\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_adafruit_lis3dh__lt_module_gt_[4] = {
    MP_ROM_PTR(&const_obj_adafruit_lis3dh__lt_module_gt__0),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_I2C),
    MP_ROM_PTR(&raw_code_adafruit_lis3dh__lt_module_gt__LIS3DH_SPI),
};
const mp_raw_code_t raw_code_adafruit_lis3dh__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_lis3dh__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_lis3dh__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 319,
        .n_obj = 1,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file adafruit_thermistor.py, scope adafruit_thermistor__lt_module_gt__Thermistor___init__
STATIC const byte bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor___init__[61] = {
    0x0a, 0x00, 0x08, 0x06, 0x01, 0x00, 0x0e,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_adafruit_thermistor_dot_py & 0xff, MP_QSTR_adafruit_thermistor_dot_py >> 8,
    0x81, 0x3e, 0x2d, 0x25, 0x25, 0x25, 0x25, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x1e, MP_QSTR_AnalogIn & 0xff, MP_QSTR_AnalogIn >> 8,
    0xb1, 
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_series_resistor & 0xff, MP_QSTR_series_resistor >> 8,
    0xb3, 
    0xb0, 
    0x26, MP_QSTR_nominal_resistance & 0xff, MP_QSTR_nominal_resistance >> 8,
    0xb4, 
    0xb0, 
    0x26, MP_QSTR_nominal_temperature & 0xff, MP_QSTR_nominal_temperature >> 8,
    0xb5, 
    0xb0, 
    0x26, MP_QSTR_b_coefficient & 0xff, MP_QSTR_b_coefficient >> 8,
    0xb6, 
    0xb0, 
    0x26, MP_QSTR_high_side & 0xff, MP_QSTR_high_side >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_thermistor__lt_module_gt__Thermistor___init__[7] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pin),
    MP_ROM_QSTR(MP_QSTR_series_resistor),
    MP_ROM_QSTR(MP_QSTR_nominal_resistance),
    MP_ROM_QSTR(MP_QSTR_nominal_temperature),
    MP_ROM_QSTR(MP_QSTR_b_coefficient),
    MP_ROM_QSTR(MP_QSTR_high_side),
};
STATIC const mp_raw_code_t raw_code_adafruit_thermistor__lt_module_gt__Thermistor___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 6,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor___init__,
        .const_table = (mp_uint_t*)const_table_data_adafruit_thermistor__lt_module_gt__Thermistor___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_thermistor.py, scope adafruit_thermistor__lt_module_gt__Thermistor_temperature
STATIC const byte bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor_temperature[136] = {
    0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x15,
    MP_QSTR_temperature & 0xff, MP_QSTR_temperature >> 8,
    MP_QSTR_adafruit_thermistor_dot_py & 0xff, MP_QSTR_adafruit_thermistor_dot_py >> 8,
    0x81, 0x47, 0x20, 0x47, 0x2c, 0x2b, 0x6a, 0x53, 0x27, 0x2a, 0x27, 0x2d, 0x25, 0x45, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_high_side & 0xff, MP_QSTR_high_side >> 8,
    0x37, 0x21, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x14, 0x80, 0x40, 
    0xe0, 
    0xc1, 
    0x14, 0x87, 0x7f, 
    0xb0, 
    0x1d, MP_QSTR_series_resistor & 0xff, MP_QSTR_series_resistor >> 8,
    0xde, 
    0xb1, 
    0xe0, 
    0xc1, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_series_resistor & 0xff, MP_QSTR_series_resistor >> 8,
    0xea, 
    0xc1, 
    0x35, 0x13, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_series_resistor & 0xff, MP_QSTR_series_resistor >> 8,
    0x17, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xe0, 
    0x17, 0x02, 
    0xdd, 
    0xe0, 
    0xc1, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_nominal_resistance & 0xff, MP_QSTR_nominal_resistance >> 8,
    0xe0, 
    0xc2, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_log & 0xff, MP_QSTR_log >> 8,
    0xb2, 
    0x66, 0x01, 
    0xc2, 
    0xb2, 
    0xb0, 
    0x1d, MP_QSTR_b_coefficient & 0xff, MP_QSTR_b_coefficient >> 8,
    0xed, 
    0xc2, 
    0xb2, 
    0x17, 0x03, 
    0xb0, 
    0x1d, MP_QSTR_nominal_temperature & 0xff, MP_QSTR_nominal_temperature >> 8,
    0x17, 0x04, 
    0xdc, 
    0xe0, 
    0xe9, 
    0xc2, 
    0x17, 0x05, 
    0xb2, 
    0xe0, 
    0xc2, 
    0xb2, 
    0x17, 0x06, 
    0xea, 
    0xc2, 
    0xb2, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_0 = {{&mp_type_float}, 65535.00000000001};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_1 = {{&mp_type_float}, 1};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_2 = {{&mp_type_float}, 1};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_3 = {{&mp_type_float}, 273.15};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_4 = {{&mp_type_float}, 1};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_5 = {{&mp_type_float}, 273.15};
#endif
STATIC const mp_rom_obj_t const_table_data_adafruit_thermistor__lt_module_gt__Thermistor_temperature[7] = {
    MP_ROM_QSTR(MP_QSTR_self),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc7ffff02),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_2),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_3),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc4089332),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_4),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_adafruit_thermistor__lt_module_gt__Thermistor_temperature_5),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc4089332),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_adafruit_thermistor__lt_module_gt__Thermistor_temperature = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor_temperature,
        .const_table = (mp_uint_t*)const_table_data_adafruit_thermistor__lt_module_gt__Thermistor_temperature,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 136,
        .n_obj = 6,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file adafruit_thermistor.py, scope adafruit_thermistor__lt_module_gt__Thermistor
STATIC const byte bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor[56] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_Thermistor & 0xff, MP_QSTR_Thermistor >> 8,
    MP_QSTR_adafruit_thermistor_dot_py & 0xff, MP_QSTR_adafruit_thermistor_dot_py >> 8,
    0x8d, 0x39, 0x40, 0x8d, 0x0a, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_Thermistor & 0xff, MP_QSTR_Thermistor >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x12, 
    0x16, MP_QSTR_high_side & 0xff, MP_QSTR_high_side >> 8,
    0x54, 
    0x61, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_temperature & 0xff, MP_QSTR_temperature >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_thermistor__lt_module_gt__Thermistor[2] = {
    MP_ROM_PTR(&raw_code_adafruit_thermistor__lt_module_gt__Thermistor___init__),
    MP_ROM_PTR(&raw_code_adafruit_thermistor__lt_module_gt__Thermistor_temperature),
};
STATIC const mp_raw_code_t raw_code_adafruit_thermistor__lt_module_gt__Thermistor = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_thermistor__lt_module_gt__Thermistor,
        .const_table = (mp_uint_t*)const_table_data_adafruit_thermistor__lt_module_gt__Thermistor,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 56,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file adafruit_thermistor.py, scope adafruit_thermistor_<module>
STATIC const byte bytecode_data_adafruit_thermistor__lt_module_gt_[49] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_adafruit_thermistor_dot_py & 0xff, MP_QSTR_adafruit_thermistor_dot_py >> 8,
    0x81, 0x15, 0x80, 0x20, 0x28, 0x48, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x24, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_Thermistor & 0xff, MP_QSTR_Thermistor >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_Thermistor & 0xff, MP_QSTR_Thermistor >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_adafruit_thermistor__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_adafruit_thermistor__lt_module_gt__Thermistor),
};
const mp_raw_code_t raw_code_adafruit_thermistor__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_adafruit_thermistor__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_adafruit_thermistor__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 49,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Photocell___init__
STATIC const byte bytecode_data_express__lt_module_gt__Photocell___init__[31] = {
    0x05, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x3c, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x1e, MP_QSTR_AnalogIn & 0xff, MP_QSTR_AnalogIn >> 8,
    0xb1, 
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__photocell & 0xff, MP_QSTR__photocell >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Photocell___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Photocell___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Photocell___init__,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Photocell___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Photocell_light
STATIC const byte bytecode_data_express__lt_module_gt__Photocell_light[33] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_light & 0xff, MP_QSTR_light >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x41, 0x20, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__photocell & 0xff, MP_QSTR__photocell >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x14, 0x82, 0x4a, 
    0xde, 
    0x82, 
    0x90, 
    0xe2, 
    0xdf, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Photocell_light[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Photocell_light = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Photocell_light,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Photocell_light,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 33,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Photocell
STATIC const byte bytecode_data_express__lt_module_gt__Photocell[48] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_Photocell & 0xff, MP_QSTR_Photocell >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x8d, 0x39, 0x40, 0x65, 0x20, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_Photocell & 0xff, MP_QSTR_Photocell >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_light & 0xff, MP_QSTR_light >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Photocell[2] = {
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Photocell___init__),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Photocell_light),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Photocell = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Photocell,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Photocell,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 48,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express___init__
STATIC const byte bytecode_data_express__lt_module_gt__Express___init__[521] = {
    0x09, 0x01, 0x00, 0x01, 0x00, 0x00, 0x2c,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x4a, 0x32, 0x2f, 0x22, 0x32, 0x37, 0x32, 0x77, 0x32, 0x77, 0x32, 0x2a, 0x73, 0x3e, 0x6f, 0x32, 0x2f, 0x25, 0x85, 0x07, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x65, 0x38, 0x32, 0x23, 0x1f, 0x4a, 0x3a, 0x6d, 0x25, 0x00, 0x00, 0xff,
    0x16, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x1c, MP_QSTR_dir & 0xff, MP_QSTR_dir >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x64, 0x01, 
    0xf6, 
    0x37, 0x11, 0x80, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1d, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x17, 0x01, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x11, 
    0x5b, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_BUTTON_A & 0xff, MP_QSTR_BUTTON_A >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__a & 0xff, MP_QSTR__a >> 8,
    0xb0, 
    0x1d, MP_QSTR__a & 0xff, MP_QSTR__a >> 8,
    0x1e, MP_QSTR_switch_to_input & 0xff, MP_QSTR_switch_to_input >> 8,
    0x16, MP_QSTR_pull & 0xff, MP_QSTR_pull >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Pull & 0xff, MP_QSTR_Pull >> 8,
    0x1d, MP_QSTR_DOWN & 0xff, MP_QSTR_DOWN >> 8,
    0x66, 0x82, 0x00, 
    0x32, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_BUTTON_B & 0xff, MP_QSTR_BUTTON_B >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__b & 0xff, MP_QSTR__b >> 8,
    0xb0, 
    0x1d, MP_QSTR__b & 0xff, MP_QSTR__b >> 8,
    0x1e, MP_QSTR_switch_to_input & 0xff, MP_QSTR_switch_to_input >> 8,
    0x16, MP_QSTR_pull & 0xff, MP_QSTR_pull >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Pull & 0xff, MP_QSTR_Pull >> 8,
    0x1d, MP_QSTR_DOWN & 0xff, MP_QSTR_DOWN >> 8,
    0x66, 0x82, 0x00, 
    0x32, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_SLIDE_SWITCH & 0xff, MP_QSTR_SLIDE_SWITCH >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__switch & 0xff, MP_QSTR__switch >> 8,
    0xb0, 
    0x1d, MP_QSTR__switch & 0xff, MP_QSTR__switch >> 8,
    0x1e, MP_QSTR_switch_to_input & 0xff, MP_QSTR_switch_to_input >> 8,
    0x16, MP_QSTR_pull & 0xff, MP_QSTR_pull >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Pull & 0xff, MP_QSTR_Pull >> 8,
    0x1d, MP_QSTR_UP & 0xff, MP_QSTR_UP >> 8,
    0x66, 0x82, 0x00, 
    0x32, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_D13 & 0xff, MP_QSTR_D13 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__led & 0xff, MP_QSTR__led >> 8,
    0xb0, 
    0x1d, MP_QSTR__led & 0xff, MP_QSTR__led >> 8,
    0x1e, MP_QSTR_switch_to_output & 0xff, MP_QSTR_switch_to_output >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_neopixel & 0xff, MP_QSTR_neopixel >> 8,
    0x1e, MP_QSTR_NeoPixel & 0xff, MP_QSTR_NeoPixel >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_NEOPIXEL & 0xff, MP_QSTR_NEOPIXEL >> 8,
    0x8a, 
    0x66, 0x02, 
    0xb0, 
    0x26, MP_QSTR__pixels & 0xff, MP_QSTR__pixels >> 8,
    0x1c, MP_QSTR_adafruit_thermistor & 0xff, MP_QSTR_adafruit_thermistor >> 8,
    0x1e, MP_QSTR_Thermistor & 0xff, MP_QSTR_Thermistor >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_TEMPERATURE & 0xff, MP_QSTR_TEMPERATURE >> 8,
    0x14, 0x80, 0xce, 0x10, 
    0x14, 0x80, 0xce, 0x10, 
    0x99, 
    0x14, 0x9e, 0x6e, 
    0x66, 0x05, 
    0xb0, 
    0x26, MP_QSTR__temp & 0xff, MP_QSTR__temp >> 8,
    0x1c, MP_QSTR_Photocell & 0xff, MP_QSTR_Photocell >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_LIGHT & 0xff, MP_QSTR_LIGHT >> 8,
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR__light & 0xff, MP_QSTR__light >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_SPEAKER_ENABLE & 0xff, MP_QSTR_SPEAKER_ENABLE >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0xb0, 
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x1e, MP_QSTR_switch_to_output & 0xff, MP_QSTR_switch_to_output >> 8,
    0x16, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x10, 
    0x66, 0x82, 0x00, 
    0x32, 
    0x11, 
    0xb0, 
    0x26, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__sine_wave & 0xff, MP_QSTR__sine_wave >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A1 & 0xff, MP_QSTR__touch_A1 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A2 & 0xff, MP_QSTR__touch_A2 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A3 & 0xff, MP_QSTR__touch_A3 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A4 & 0xff, MP_QSTR__touch_A4 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A5 & 0xff, MP_QSTR__touch_A5 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A6 & 0xff, MP_QSTR__touch_A6 >> 8,
    0x11, 
    0xb0, 
    0x26, MP_QSTR__touch_A7 & 0xff, MP_QSTR__touch_A7 >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0x1c, MP_QSTR_busio & 0xff, MP_QSTR_busio >> 8,
    0x1e, MP_QSTR_I2C & 0xff, MP_QSTR_I2C >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_ACCELEROMETER_SCL & 0xff, MP_QSTR_ACCELEROMETER_SCL >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_ACCELEROMETER_SDA & 0xff, MP_QSTR_ACCELEROMETER_SDA >> 8,
    0x66, 0x02, 
    0xb0, 
    0x26, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_ACCELEROMETER_INTERRUPT & 0xff, MP_QSTR_ACCELEROMETER_INTERRUPT >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x3f, 0x20, 0x00, 
    0x1c, MP_QSTR_adafruit_lis3dh & 0xff, MP_QSTR_adafruit_lis3dh >> 8,
    0x1e, MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    0xb0, 
    0x1d, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x16, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x99, 
    0x16, MP_QSTR_int1 & 0xff, MP_QSTR_int1 >> 8,
    0xb0, 
    0x1d, MP_QSTR__int1 & 0xff, MP_QSTR__int1 >> 8,
    0x66, 0x84, 0x01, 
    0xb0, 
    0x26, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x44, 
    0x35, 0x23, 0x80, 
    0x30, 
    0x1c, MP_QSTR_TypeError & 0xff, MP_QSTR_TypeError >> 8,
    0xf8, 
    0x37, 0x1a, 0x80, 
    0x32, 
    0x1c, MP_QSTR_adafruit_lis3dh & 0xff, MP_QSTR_adafruit_lis3dh >> 8,
    0x1e, MP_QSTR_LIS3DH_I2C & 0xff, MP_QSTR_LIS3DH_I2C >> 8,
    0xb0, 
    0x1d, MP_QSTR__i2c & 0xff, MP_QSTR__i2c >> 8,
    0x16, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x99, 
    0x66, 0x82, 0x01, 
    0xb0, 
    0x26, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x1c, MP_QSTR_adafruit_lis3dh & 0xff, MP_QSTR_adafruit_lis3dh >> 8,
    0x1d, MP_QSTR_RANGE_8_G & 0xff, MP_QSTR_RANGE_8_G >> 8,
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x26, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x81, 
    0xb0, 
    0x26, MP_QSTR__detect_taps & 0xff, MP_QSTR__detect_taps >> 8,
    0x81, 
    0xb0, 
    0x26, MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_express__lt_module_gt__Express___init___0 = {{&mp_type_str}, 223, 18, (const byte*)"\x73\x70\x68\x69\x6e\x78\x2e\x65\x78\x74\x2e\x61\x75\x74\x6f\x64\x6f\x63"};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_PTR(&const_obj_express__lt_module_gt__Express___init___0),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express___init__,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 521,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_detect_taps
STATIC const byte bytecode_data_express__lt_module_gt__Express_detect_taps[23] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x82, 0x80, 0x0f, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__detect_taps & 0xff, MP_QSTR__detect_taps >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_detect_taps[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_detect_taps = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_detect_taps,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_detect_taps,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_detect_taps
STATIC const byte bytecode_data_express__lt_module_gt__Express_detect_taps2[122] = {
    0x0c, 0x01, 0x00, 0x02, 0x00, 0x00, 0x10,
    MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x95, 0x25, 0x23, 0x26, 0x3e, 0x26, 0x1f, 0x4b, 0x00, 0x00, 0xff,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR__detect_taps & 0xff, MP_QSTR__detect_taps >> 8,
    0x3f, 0x4b, 0x00, 
    0xb1, 
    0x81, 
    0xf2, 
    0x37, 0x1e, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x1e, MP_QSTR_set_tap & 0xff, MP_QSTR_set_tap >> 8,
    0xb1, 
    0x14, 0x80, 0x5a, 
    0x16, MP_QSTR_time_limit & 0xff, MP_QSTR_time_limit >> 8,
    0x84, 
    0x16, MP_QSTR_time_latency & 0xff, MP_QSTR_time_latency >> 8,
    0x14, 0x32, 
    0x16, MP_QSTR_time_window & 0xff, MP_QSTR_time_window >> 8,
    0x14, 0x81, 0x7f, 
    0x66, 0x86, 0x02, 
    0x32, 
    0xb1, 
    0x82, 
    0xf2, 
    0x37, 0x1d, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x1e, MP_QSTR_set_tap & 0xff, MP_QSTR_set_tap >> 8,
    0xb1, 
    0x14, 0x3c, 
    0x16, MP_QSTR_time_limit & 0xff, MP_QSTR_time_limit >> 8,
    0x8a, 
    0x16, MP_QSTR_time_latency & 0xff, MP_QSTR_time_latency >> 8,
    0x14, 0x32, 
    0x16, MP_QSTR_time_window & 0xff, MP_QSTR_time_window >> 8,
    0x14, 0x81, 0x7f, 
    0x66, 0x86, 0x02, 
    0x32, 
    0x44, 
    0x35, 0x0e, 0x80, 
    0x30, 
    0x1c, MP_QSTR_AttributeError & 0xff, MP_QSTR_AttributeError >> 8,
    0xf8, 
    0x37, 0x05, 0x80, 
    0x32, 
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_detect_taps2[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_detect_taps2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_detect_taps2,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_detect_taps2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 122,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_tapped
STATIC const byte bytecode_data_express__lt_module_gt__Express_tapped[60] = {
    0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_tapped & 0xff, MP_QSTR_tapped >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0xa0, 0x80, 0x2f, 0x23, 0x55, 0x00, 0x00, 0xff,
    0x3f, 0x0c, 0x00, 
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x1d, MP_QSTR_tapped & 0xff, MP_QSTR_tapped >> 8,
    0x5b, 
    0x44, 
    0x35, 0x17, 0x80, 
    0x30, 
    0x1c, MP_QSTR_AttributeError & 0xff, MP_QSTR_AttributeError >> 8,
    0xf8, 
    0x37, 0x0e, 0x80, 
    0x32, 
    0x1c, MP_QSTR_RuntimeError & 0xff, MP_QSTR_RuntimeError >> 8,
    0x17, 0x01, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_express__lt_module_gt__Express_tapped_0 = {{&mp_type_str}, 170, 87, (const byte*)"\x4f\x6f\x70\x73\x21\x20\x59\x6f\x75\x20\x6e\x65\x65\x64\x20\x61\x20\x6e\x65\x77\x65\x72\x20\x76\x65\x72\x73\x69\x6f\x6e\x20\x6f\x66\x20\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x20\x28\x32\x2e\x32\x2e\x30\x20\x6f\x72\x20\x67\x72\x65\x61\x74\x65\x72\x29\x20\x74\x6f\x20\x75\x73\x65\x20\x74\x68\x69\x73\x20\x66\x65\x61\x74\x75\x72\x65\x2e"};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_tapped[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_PTR(&const_obj_express__lt_module_gt__Express_tapped_0),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_tapped = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_tapped,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_tapped,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 60,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_acceleration
STATIC const byte bytecode_data_express__lt_module_gt__Express_acceleration[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0xd7, 0x80, 0x10, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x1d, MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_acceleration[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_acceleration = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_acceleration,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_acceleration,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_shake
STATIC const byte bytecode_data_express__lt_module_gt__Express_shake[67] = {
    0x08, 0x01, 0x00, 0x02, 0x00, 0x01, 0x0d,
    MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0xea, 0x80, 0x1d, 0x23, 0x5c, 0x00, 0x00, 0xff,
    0x3f, 0x13, 0x00, 
    0xb0, 
    0x1d, MP_QSTR__lis3dh & 0xff, MP_QSTR__lis3dh >> 8,
    0x1e, MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    0x16, MP_QSTR_shake_threshold & 0xff, MP_QSTR_shake_threshold >> 8,
    0xb1, 
    0x66, 0x82, 0x00, 
    0x5b, 
    0x44, 
    0x35, 0x17, 0x80, 
    0x30, 
    0x1c, MP_QSTR_AttributeError & 0xff, MP_QSTR_AttributeError >> 8,
    0xf8, 
    0x37, 0x0e, 0x80, 
    0x32, 
    0x1c, MP_QSTR_RuntimeError & 0xff, MP_QSTR_RuntimeError >> 8,
    0x17, 0x02, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_express__lt_module_gt__Express_shake_0 = {{&mp_type_str}, 170, 87, (const byte*)"\x4f\x6f\x70\x73\x21\x20\x59\x6f\x75\x20\x6e\x65\x65\x64\x20\x61\x20\x6e\x65\x77\x65\x72\x20\x76\x65\x72\x73\x69\x6f\x6e\x20\x6f\x66\x20\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x20\x28\x32\x2e\x32\x2e\x30\x20\x6f\x72\x20\x67\x72\x65\x61\x74\x65\x72\x29\x20\x74\x6f\x20\x75\x73\x65\x20\x74\x68\x69\x73\x20\x66\x65\x61\x74\x75\x72\x65\x2e"};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_shake[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_shake_threshold),
    MP_ROM_PTR(&const_obj_express__lt_module_gt__Express_shake_0),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_shake = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_shake,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_shake,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 67,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A1
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A1[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A1 & 0xff, MP_QSTR_touch_A1 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x0f, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A1 & 0xff, MP_QSTR__touch_A1 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A1 & 0xff, MP_QSTR_A1 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A1 & 0xff, MP_QSTR__touch_A1 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A1 & 0xff, MP_QSTR__touch_A1 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A1 & 0xff, MP_QSTR__touch_A1 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A1[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A1 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A1,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A1,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A2
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A2[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A2 & 0xff, MP_QSTR_touch_A2 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x23, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A2 & 0xff, MP_QSTR__touch_A2 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A2 & 0xff, MP_QSTR_A2 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A2 & 0xff, MP_QSTR__touch_A2 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A2 & 0xff, MP_QSTR__touch_A2 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A2 & 0xff, MP_QSTR__touch_A2 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A2[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A2,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A3
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A3[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A3 & 0xff, MP_QSTR_touch_A3 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x37, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A3 & 0xff, MP_QSTR__touch_A3 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A3 & 0xff, MP_QSTR_A3 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A3 & 0xff, MP_QSTR__touch_A3 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A3 & 0xff, MP_QSTR__touch_A3 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A3 & 0xff, MP_QSTR__touch_A3 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A3[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A3 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A3,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A3,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A4
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A4[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A4 & 0xff, MP_QSTR_touch_A4 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x4b, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A4 & 0xff, MP_QSTR__touch_A4 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A4 & 0xff, MP_QSTR_A4 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A4 & 0xff, MP_QSTR__touch_A4 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A4 & 0xff, MP_QSTR__touch_A4 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A4 & 0xff, MP_QSTR__touch_A4 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A4[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A4 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A4,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A4,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A5
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A5[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A5 & 0xff, MP_QSTR_touch_A5 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x5f, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A5 & 0xff, MP_QSTR__touch_A5 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A5 & 0xff, MP_QSTR_A5 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A5 & 0xff, MP_QSTR__touch_A5 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A5 & 0xff, MP_QSTR__touch_A5 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A5 & 0xff, MP_QSTR__touch_A5 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A5[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A5 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A5,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A5,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A6
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A6[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A6 & 0xff, MP_QSTR_touch_A6 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x73, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A6 & 0xff, MP_QSTR__touch_A6 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A6 & 0xff, MP_QSTR_A6 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A6 & 0xff, MP_QSTR__touch_A6 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A6 & 0xff, MP_QSTR__touch_A6 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A6 & 0xff, MP_QSTR__touch_A6 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A6[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A6 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A6,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A6,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_touch_A7
STATIC const byte bytecode_data_express__lt_module_gt__Express_touch_A7[73] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0e,
    MP_QSTR_touch_A7 & 0xff, MP_QSTR_touch_A7 >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x87, 0x80, 0x0d, 0x29, 0x32, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__touch_A7 & 0xff, MP_QSTR__touch_A7 >> 8,
    0x11, 
    0xf7, 
    0x37, 0x23, 0x80, 
    0x1c, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x1e, MP_QSTR_TouchIn & 0xff, MP_QSTR_TouchIn >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_A7 & 0xff, MP_QSTR_A7 >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR__touch_A7 & 0xff, MP_QSTR__touch_A7 >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A7 & 0xff, MP_QSTR__touch_A7 >> 8,
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb0, 
    0x1d, MP_QSTR__touch_A7 & 0xff, MP_QSTR__touch_A7 >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_touch_A7[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_touch_A7 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_touch_A7,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_touch_A7,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_adjust_touch_threshold_<listcomp>
STATIC const byte bytecode_data_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_[40] = {
    0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR__lt_listcomp_gt_ & 0xff, MP_QSTR__lt_listcomp_gt_ >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x99, 0xac, 0x00, 0x00, 0xff,
    0x51, 0x00, 
    0xb0, 
    0x47, 
    0x43, 0x10, 0x00, 
    0xc1, 
    0x16, MP_QSTR__touch_A & 0xff, MP_QSTR__touch_A >> 8,
    0x1c, MP_QSTR_str & 0xff, MP_QSTR_str >> 8,
    0xb1, 
    0x64, 0x01, 
    0xdc, 
    0x57, 0x14, 
    0x35, 0xed, 0x7f, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_[1] = {
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 40,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_adjust_touch_threshold
STATIC const byte bytecode_data_express__lt_module_gt__Express_adjust_touch_threshold[77] = {
    0x0b, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0f,
    MP_QSTR_adjust_touch_threshold & 0xff, MP_QSTR_adjust_touch_threshold >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0x9a, 0x80, 0x12, 0x30, 0x28, 0x24, 0x2e, 0x00, 0x00, 0xff,
    0x60, 0x02, 
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x81, 
    0x88, 
    0x64, 0x02, 
    0x64, 0x01, 
    0x47, 
    0x43, 0x1b, 0x00, 
    0xc2, 
    0x1c, MP_QSTR_getattr & 0xff, MP_QSTR_getattr >> 8,
    0xb0, 
    0xb2, 
    0x64, 0x02, 
    0xc3, 
    0xb3, 
    0x37, 0x0b, 0x80, 
    0xb3, 
    0x30, 
    0x1d, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0xb1, 
    0xe9, 
    0x33, 
    0x26, MP_QSTR_threshold & 0xff, MP_QSTR_threshold >> 8,
    0x35, 0xe2, 0x7f, 
    0xb0, 
    0x30, 
    0x1d, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0xb1, 
    0xe9, 
    0x33, 
    0x26, MP_QSTR__touch_threshold_adjustment & 0xff, MP_QSTR__touch_threshold_adjustment >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_adjust_touch_threshold[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_adjustment),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_adjust_touch_threshold__lt_listcomp_gt_),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_adjust_touch_threshold = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_adjust_touch_threshold,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_adjust_touch_threshold,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 77,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_pixels
STATIC const byte bytecode_data_express__lt_module_gt__Express_pixels[23] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0xb4, 0x80, 0x1a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__pixels & 0xff, MP_QSTR__pixels >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_pixels[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_pixels = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_pixels,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_pixels,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_button_a
STATIC const byte bytecode_data_express__lt_module_gt__Express_button_a[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_button_a & 0xff, MP_QSTR_button_a >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0xd2, 0x80, 0x0d, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__a & 0xff, MP_QSTR__a >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_button_a[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_button_a = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_button_a,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_button_a,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_button_b
STATIC const byte bytecode_data_express__lt_module_gt__Express_button_b[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_button_b & 0xff, MP_QSTR_button_b >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0xe3, 0x80, 0x0d, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__b & 0xff, MP_QSTR__b >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_button_b[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_button_b = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_button_b,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_button_b,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_switch
STATIC const byte bytecode_data_express__lt_module_gt__Express_switch[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_switch & 0xff, MP_QSTR_switch >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x91, 0xf4, 0x80, 0x10, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__switch & 0xff, MP_QSTR__switch >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_switch[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_switch = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_switch,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_switch,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_temperature
STATIC const byte bytecode_data_express__lt_module_gt__Express_temperature[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_temperature & 0xff, MP_QSTR_temperature >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x08, 0x80, 0x13, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__temp & 0xff, MP_QSTR__temp >> 8,
    0x1d, MP_QSTR_temperature & 0xff, MP_QSTR_temperature >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_temperature[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_temperature = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_temperature,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_temperature,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_light
STATIC const byte bytecode_data_express__lt_module_gt__Express_light[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_light & 0xff, MP_QSTR_light >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x1f, 0x80, 0x10, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__light & 0xff, MP_QSTR__light >> 8,
    0x1d, MP_QSTR_light & 0xff, MP_QSTR_light >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_light[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_light = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_light,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_light,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_red_led
STATIC const byte bytecode_data_express__lt_module_gt__Express_red_led[26] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_red_led & 0xff, MP_QSTR_red_led >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x33, 0x80, 0x10, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__led & 0xff, MP_QSTR__led >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_red_led[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_red_led = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_red_led,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_red_led,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_red_led
STATIC const byte bytecode_data_express__lt_module_gt__Express_red_led2[26] = {
    0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR_red_led & 0xff, MP_QSTR_red_led >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x47, 0x00, 0x00, 0xff,
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR__led & 0xff, MP_QSTR__led >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_red_led2[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_red_led2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_red_led2,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_red_led2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express__sine_sample
STATIC const byte bytecode_data_express__lt_module_gt__Express__sine_sample[79] = {
    0x0d, 0x00, 0x04, 0x01, 0x00, 0x00, 0x0c,
    MP_QSTR__sine_sample & 0xff, MP_QSTR__sine_sample >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x4b, 0x26, 0x24, 0x27, 0x00, 0x00, 0xff,
    0x82, 
    0x8f, 
    0xe2, 
    0x81, 
    0xdd, 
    0xc1, 
    0x82, 
    0x8f, 
    0xe2, 
    0xc2, 
    0xb0, 
    0x80, 
    0x35, 0x23, 0x80, 
    0x30, 
    0xc3, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb1, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_sin & 0xff, MP_QSTR_sin >> 8,
    0x82, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1d, MP_QSTR_pi & 0xff, MP_QSTR_pi >> 8,
    0xde, 
    0xb3, 
    0xb0, 
    0xe0, 
    0xde, 
    0x66, 0x01, 
    0xde, 
    0xb2, 
    0xdc, 
    0x64, 0x01, 
    0x5d, 
    0x32, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xd7, 0x7f, 
    0x32, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express__sine_sample[1] = {
    MP_ROM_QSTR(MP_QSTR_length),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express__sine_sample = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x04,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express__sine_sample,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express__sine_sample,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 79,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express__generate_sample
STATIC const byte bytecode_data_express__lt_module_gt__Express__generate_sample[84] = {
    0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR__generate_sample & 0xff, MP_QSTR__generate_sample >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x51, 0x2a, 0x22, 0x24, 0x38, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x11, 
    0xf7, 
    0xd6, 
    0x37, 0x02, 0x80, 
    0x11, 
    0x5b, 
    0x14, 0x80, 0x64, 
    0xc1, 
    0x1c, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x1e, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x16, MP_QSTR_H & 0xff, MP_QSTR_H >> 8,
    0x1c, MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    0x1e, MP_QSTR__sine_sample & 0xff, MP_QSTR__sine_sample >> 8,
    0xb1, 
    0x66, 0x01, 
    0x66, 0x02, 
    0xb0, 
    0x26, MP_QSTR__sine_wave & 0xff, MP_QSTR__sine_wave >> 8,
    0x1c, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x1e, MP_QSTR_AudioOut & 0xff, MP_QSTR_AudioOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_SPEAKER & 0xff, MP_QSTR_SPEAKER >> 8,
    0xb0, 
    0x1d, MP_QSTR__sine_wave & 0xff, MP_QSTR__sine_wave >> 8,
    0x66, 0x02, 
    0xb0, 
    0x26, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express__generate_sample[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express__generate_sample = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express__generate_sample,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express__generate_sample,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 84,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_play_tone
STATIC const byte bytecode_data_express__lt_module_gt__Express_play_tone[47] = {
    0x06, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0d,
    MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x58, 0x80, 0x10, 0x28, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_start_tone & 0xff, MP_QSTR_start_tone >> 8,
    0xb1, 
    0x66, 0x01, 
    0x32, 
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_sleep & 0xff, MP_QSTR_sleep >> 8,
    0xb2, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_stop_tone & 0xff, MP_QSTR_stop_tone >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_play_tone[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_frequency),
    MP_ROM_QSTR(MP_QSTR_duration),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_play_tone = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_play_tone,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_play_tone,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 47,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_start_tone
STATIC const byte bytecode_data_express__lt_module_gt__Express_start_tone[87] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0f,
    MP_QSTR_start_tone & 0xff, MP_QSTR_start_tone >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x6d, 0x80, 0x14, 0x28, 0x47, 0x37, 0x2a, 0x00, 0x00, 0xff,
    0x12, 
    0xb0, 
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb0, 
    0x1e, MP_QSTR__generate_sample & 0xff, MP_QSTR__generate_sample >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR__sine_wave & 0xff, MP_QSTR__sine_wave >> 8,
    0x64, 0x01, 
    0xb1, 
    0xde, 
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x26, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x1d, MP_QSTR_playing & 0xff, MP_QSTR_playing >> 8,
    0x36, 0x0f, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x1e, MP_QSTR_play & 0xff, MP_QSTR_play >> 8,
    0x16, MP_QSTR_loop & 0xff, MP_QSTR_loop >> 8,
    0x12, 
    0x66, 0x82, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_start_tone[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_frequency),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_start_tone = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_start_tone,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_start_tone,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 87,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_stop_tone
STATIC const byte bytecode_data_express__lt_module_gt__Express_stop_tone[60] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_stop_tone & 0xff, MP_QSTR_stop_tone >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0x89, 0x80, 0x12, 0x34, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x11, 
    0xf7, 
    0xd6, 
    0x37, 0x14, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x1d, MP_QSTR_playing & 0xff, MP_QSTR_playing >> 8,
    0x37, 0x0a, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x1e, MP_QSTR_stop & 0xff, MP_QSTR_stop >> 8,
    0x66, 0x00, 
    0x32, 
    0x10, 
    0xb0, 
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_stop_tone[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_stop_tone = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_stop_tone,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_stop_tone,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 60,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express_play_file
STATIC const byte bytecode_data_express__lt_module_gt__Express_play_file[82] = {
    0x09, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10,
    MP_QSTR_play_file & 0xff, MP_QSTR_play_file >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0xa1, 0xa0, 0x80, 0x12, 0x28, 0x58, 0x27, 0x23, 0x27, 0x00, 0x00, 0xff,
    0x12, 
    0xb0, 
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x1e, MP_QSTR_AudioOut & 0xff, MP_QSTR_AudioOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_SPEAKER & 0xff, MP_QSTR_SPEAKER >> 8,
    0x1c, MP_QSTR_open & 0xff, MP_QSTR_open >> 8,
    0xb1, 
    0x16, MP_QSTR_rb & 0xff, MP_QSTR_rb >> 8,
    0x64, 0x02, 
    0x66, 0x02, 
    0xc2, 
    0xb2, 
    0x1e, MP_QSTR_play & 0xff, MP_QSTR_play >> 8,
    0x66, 0x00, 
    0x32, 
    0x35, 0x00, 0x80, 
    0xb2, 
    0x1d, MP_QSTR_playing & 0xff, MP_QSTR_playing >> 8,
    0x36, 0xf9, 0x7f, 
    0x10, 
    0xb0, 
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express_play_file[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_file_name),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express_play_file = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express_play_file,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express_play_file,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 82,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file express.py, scope express__lt_module_gt__Express
STATIC const byte bytecode_data_express__lt_module_gt__Express[335] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x8d, 0x46, 0x40, 0x85, 0x38, 0x8a, 0x13, 0x8d, 0x0b, 0x8a, 0x37, 0x8a, 0x14, 0x89, 0x24, 0x8a, 0x14, 0x8a, 0x14, 0x8a, 0x14, 0x8a, 0x14, 0x8a, 0x14, 0x8a, 0x14, 0x8a, 0x14, 0x85, 0x19, 0x8a, 0x1e, 0x8a, 0x11, 0x8a, 0x11, 0x8a, 0x14, 0x8a, 0x17, 0x8a, 0x14, 0x8a, 0x14, 0x6d, 0x20, 0x8a, 0x07, 0x85, 0x07, 0x85, 0x15, 0x85, 0x1c, 0x85, 0x17, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    0x1b, MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x02, 
    0x64, 0x01, 
    0x24, MP_QSTR_detect_taps & 0xff, MP_QSTR_detect_taps >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x03, 
    0x64, 0x01, 
    0x24, MP_QSTR_tapped & 0xff, MP_QSTR_tapped >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x04, 
    0x64, 0x01, 
    0x24, MP_QSTR_acceleration & 0xff, MP_QSTR_acceleration >> 8,
    0x9e, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x05, 
    0x24, MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x06, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A1 & 0xff, MP_QSTR_touch_A1 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x07, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A2 & 0xff, MP_QSTR_touch_A2 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x08, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A3 & 0xff, MP_QSTR_touch_A3 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x09, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A4 & 0xff, MP_QSTR_touch_A4 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0a, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A5 & 0xff, MP_QSTR_touch_A5 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0b, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A6 & 0xff, MP_QSTR_touch_A6 >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0c, 
    0x64, 0x01, 
    0x24, MP_QSTR_touch_A7 & 0xff, MP_QSTR_touch_A7 >> 8,
    0x60, 0x0d, 
    0x24, MP_QSTR_adjust_touch_threshold & 0xff, MP_QSTR_adjust_touch_threshold >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0e, 
    0x64, 0x01, 
    0x24, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0f, 
    0x64, 0x01, 
    0x24, MP_QSTR_button_a & 0xff, MP_QSTR_button_a >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x10, 
    0x64, 0x01, 
    0x24, MP_QSTR_button_b & 0xff, MP_QSTR_button_b >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x11, 
    0x64, 0x01, 
    0x24, MP_QSTR_switch & 0xff, MP_QSTR_switch >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x12, 
    0x64, 0x01, 
    0x24, MP_QSTR_temperature & 0xff, MP_QSTR_temperature >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x13, 
    0x64, 0x01, 
    0x24, MP_QSTR_light & 0xff, MP_QSTR_light >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x14, 
    0x64, 0x01, 
    0x24, MP_QSTR_red_led & 0xff, MP_QSTR_red_led >> 8,
    0x1b, MP_QSTR_red_led & 0xff, MP_QSTR_red_led >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x15, 
    0x64, 0x01, 
    0x24, MP_QSTR_red_led & 0xff, MP_QSTR_red_led >> 8,
    0x1b, MP_QSTR_staticmethod & 0xff, MP_QSTR_staticmethod >> 8,
    0x60, 0x16, 
    0x64, 0x01, 
    0x24, MP_QSTR__sine_sample & 0xff, MP_QSTR__sine_sample >> 8,
    0x60, 0x17, 
    0x24, MP_QSTR__generate_sample & 0xff, MP_QSTR__generate_sample >> 8,
    0x60, 0x18, 
    0x24, MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    0x60, 0x19, 
    0x24, MP_QSTR_start_tone & 0xff, MP_QSTR_start_tone >> 8,
    0x60, 0x1a, 
    0x24, MP_QSTR_stop_tone & 0xff, MP_QSTR_stop_tone >> 8,
    0x60, 0x1b, 
    0x24, MP_QSTR_play_file & 0xff, MP_QSTR_play_file >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt__Express[28] = {
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express___init__),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_detect_taps),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_detect_taps2),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_tapped),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_acceleration),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_shake),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A1),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A2),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A3),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A4),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A5),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A6),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_touch_A7),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_adjust_touch_threshold),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_pixels),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_button_a),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_button_b),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_switch),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_temperature),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_light),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_red_led),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_red_led2),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express__sine_sample),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express__generate_sample),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_play_tone),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_start_tone),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_stop_tone),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express_play_file),
};
STATIC const mp_raw_code_t raw_code_express__lt_module_gt__Express = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt__Express,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt__Express,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 335,
        .n_obj = 0,
        .n_raw_code = 28,
        #endif
    },
};

// frozen bytecode for file express.py, scope express_<module>
STATIC const byte bytecode_data_express__lt_module_gt_[201] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_express_dot_py & 0xff, MP_QSTR_express_dot_py >> 8,
    0x81, 0x1a, 0x80, 0x09, 0x28, 0x28, 0x28, 0x48, 0x50, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x48, 0x25, 0x65, 0x8b, 0x0d, 0xab, 0x76, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x24, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_sys & 0xff, MP_QSTR_sys >> 8,
    0x24, MP_QSTR_sys & 0xff, MP_QSTR_sys >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x24, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1b, MP_QSTR_sys & 0xff, MP_QSTR_sys >> 8,
    0x1d, MP_QSTR_path & 0xff, MP_QSTR_path >> 8,
    0x1e, MP_QSTR_insert & 0xff, MP_QSTR_insert >> 8,
    0x80, 
    0x16, MP_QSTR__dot_frozen & 0xff, MP_QSTR__dot_frozen >> 8,
    0x66, 0x02, 
    0x32, 
    0x80, 
    0x11, 
    0x68, MP_QSTR_adafruit_lis3dh & 0xff, MP_QSTR_adafruit_lis3dh >> 8,
    0x24, MP_QSTR_adafruit_lis3dh & 0xff, MP_QSTR_adafruit_lis3dh >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_adafruit_thermistor & 0xff, MP_QSTR_adafruit_thermistor >> 8,
    0x24, MP_QSTR_adafruit_thermistor & 0xff, MP_QSTR_adafruit_thermistor >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x24, MP_QSTR_analogio & 0xff, MP_QSTR_analogio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x24, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x24, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_busio & 0xff, MP_QSTR_busio >> 8,
    0x24, MP_QSTR_busio & 0xff, MP_QSTR_busio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x24, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_neopixel & 0xff, MP_QSTR_neopixel >> 8,
    0x24, MP_QSTR_neopixel & 0xff, MP_QSTR_neopixel >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x24, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x17, 0x00, 
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x01, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR_Photocell & 0xff, MP_QSTR_Photocell >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_Photocell & 0xff, MP_QSTR_Photocell >> 8,
    0x20, 
    0x60, 0x03, 
    0x16, MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    0x1b, MP_QSTR_Express & 0xff, MP_QSTR_Express >> 8,
    0x64, 0x00, 
    0x24, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_express__lt_module_gt__0 = {{&mp_type_str}, 151, 28, (const byte*)"\x32\x2e\x32\x2e\x35\x2d\x61\x6c\x70\x68\x61\x2e\x30\x2e\x70\x6c\x75\x73\x2e\x32\x2b\x63\x66\x63\x62\x62\x33\x36"};
STATIC const mp_obj_str_t const_obj_express__lt_module_gt__1 = {{&mp_type_str}, 95, 72, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x6c\x61\x79\x67\x72\x6f\x75\x6e\x64\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_express__lt_module_gt_[4] = {
    MP_ROM_PTR(&const_obj_express__lt_module_gt__0),
    MP_ROM_PTR(&const_obj_express__lt_module_gt__1),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Photocell),
    MP_ROM_PTR(&raw_code_express__lt_module_gt__Express),
};
const mp_raw_code_t raw_code_express__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_express__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_express__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 201,
        .n_obj = 2,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file frozentest.py, scope frozentest_<module>
STATIC const byte bytecode_data_frozentest__lt_module_gt_[92] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_frozentest_dot_py & 0xff, MP_QSTR_frozentest_dot_py >> 8,
    0x2a, 0x28, 0x28, 0x28, 0x2b, 0x28, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR_uPy & 0xff, MP_QSTR_uPy >> 8,
    0x64, 0x01, 
    0x32, 
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x00, 
    0x64, 0x01, 
    0x32, 
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x01, 
    0x64, 0x01, 
    0x32, 
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x02, 
    0x64, 0x01, 
    0x32, 
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x14, 0xba, 0xef, 0x9a, 0x15, 
    0x64, 0x01, 
    0x32, 
    0x80, 
    0x35, 0x0f, 0x80, 
    0x30, 
    0x24, MP_QSTR_i & 0xff, MP_QSTR_i >> 8,
    0x1b, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x1b, MP_QSTR_i & 0xff, MP_QSTR_i >> 8,
    0x64, 0x01, 
    0x32, 
    0x81, 
    0xe9, 
    0x30, 
    0x84, 
    0xf0, 
    0x36, 0xeb, 0x7f, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_frozentest__lt_module_gt__0 = {{&mp_type_str}, 246, 34, (const byte*)"\x61\x20\x6c\x6f\x6e\x67\x20\x73\x74\x72\x69\x6e\x67\x20\x74\x68\x61\x74\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x74\x65\x72\x6e\x65\x64"};
STATIC const mp_obj_str_t const_obj_frozentest__lt_module_gt__1 = {{&mp_type_str}, 200, 38, (const byte*)"\x61\x20\x73\x74\x72\x69\x6e\x67\x20\x74\x68\x61\x74\x20\x68\x61\x73\x20\x75\x6e\x69\x63\x6f\x64\x65\x20\xce\xb1\xce\xb2\xce\xb3\x20\x63\x68\x61\x72\x73"};
STATIC const mp_obj_str_t const_obj_frozentest__lt_module_gt__2 = {{&mp_type_bytes}, 57, 11, (const byte*)"\x62\x79\x74\x65\x73\x20\x31\x32\x33\x34\x01"};
STATIC const mp_rom_obj_t const_table_data_frozentest__lt_module_gt_[3] = {
    MP_ROM_PTR(&const_obj_frozentest__lt_module_gt__0),
    MP_ROM_PTR(&const_obj_frozentest__lt_module_gt__1),
    MP_ROM_PTR(&const_obj_frozentest__lt_module_gt__2),
};
const mp_raw_code_t raw_code_frozentest__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_frozentest__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_frozentest__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 92,
        .n_obj = 3,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECd.py, scope IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__
STATIC const byte bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P01_NECd_dot_py & 0xff, MP_QSTR_IRLib_P01_NECd_dot_py >> 8,
    0x81, 0x09, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECd.py, scope IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode
STATIC const byte bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode[176] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x15,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P01_NECd_dot_py & 0xff, MP_QSTR_IRLib_P01_NECd_dot_py >> 8,
    0x81, 0x0b, 0x47, 0x30, 0x35, 0x34, 0x34, 0x25, 0x25, 0x2a, 0x42, 0x3c, 0x22, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x83, 
    0xf2, 
    0x37, 0x53, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x80, 0xc6, 0x28, 
    0x66, 0x02, 
    0x37, 0x3e, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x91, 0x50, 
    0x66, 0x02, 
    0x37, 0x2a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x82, 
    0x21, 
    0x14, 0x84, 0x34, 
    0x66, 0x02, 
    0x37, 0x16, 0x80, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x7f, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_NEC & 0xff, MP_QSTR_NEC >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0x14, 0x80, 0x43, 
    0x14, 0x80, 0xc6, 0x28, 
    0x14, 0xa3, 0x14, 
    0x14, 0x84, 0x34, 
    0x14, 0x8d, 0x1c, 
    0x14, 0x84, 0x34, 
    0x66, 0x06, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_NEC & 0xff, MP_QSTR_NEC >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 176,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECd.py, scope IRLib_P01_NECd__lt_module_gt__IRdecodeNEC
STATIC const byte bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeNEC & 0xff, MP_QSTR_IRdecodeNEC >> 8,
    MP_QSTR_IRLib_P01_NECd_dot_py & 0xff, MP_QSTR_IRLib_P01_NECd_dot_py >> 8,
    0x8d, 0x08, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeNEC & 0xff, MP_QSTR_IRdecodeNEC >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC___init__),
    MP_ROM_PTR(&raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECd.py, scope IRLib_P01_NECd_<module>
STATIC const byte bytecode_data_IRLib_P01_NECd__lt_module_gt_[62] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P01_NECd_dot_py & 0xff, MP_QSTR_IRLib_P01_NECd_dot_py >> 8,
    0x61, 0x20, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeNEC & 0xff, MP_QSTR_IRdecodeNEC >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeNEC & 0xff, MP_QSTR_IRdecodeNEC >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P01_NECd__lt_module_gt__IRdecodeNEC),
};
const mp_raw_code_t raw_code_IRLib_P01_NECd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 62,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECs.py, scope IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__
STATIC const byte bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P01_NECs_dot_py & 0xff, MP_QSTR_IRLib_P01_NECs_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECs.py, scope IRLib_P01_NECs__lt_module_gt__IRsendNEC_send
STATIC const byte bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send[126] = {
    0x12, 0x00, 0x00, 0x04, 0x00, 0x02, 0x10,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P01_NECs_dot_py & 0xff, MP_QSTR_IRLib_P01_NECs_dot_py >> 8,
    0x81, 0x09, 0x26, 0x28, 0x2b, 0x2a, 0x2a, 0x2b, 0x4a, 0x00, 0x00, 0xff,
    0xb1, 
    0x7f, 
    0xf2, 
    0x37, 0x3c, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xb3, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x80, 0xc6, 0x28, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x91, 0x50, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x84, 0x34, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x81, 0xff, 0x7f, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x35, 0x23, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0xb2, 
    0xa0, 
    0x14, 0x80, 0xc6, 0x28, 
    0x14, 0xa3, 0x14, 
    0x14, 0x84, 0x34, 
    0x14, 0x84, 0x34, 
    0x14, 0x8d, 0x1c, 
    0x14, 0x84, 0x34, 
    0xb3, 
    0x12, 
    0x14, 0x86, 0xcb, 0x60, 
    0x66, 0x0c, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_address),
    MP_ROM_QSTR(MP_QSTR_kHz),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 126,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECs.py, scope IRLib_P01_NECs__lt_module_gt__IRsendNEC
STATIC const byte bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC[46] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendNEC & 0xff, MP_QSTR_IRsendNEC >> 8,
    MP_QSTR_IRLib_P01_NECs_dot_py & 0xff, MP_QSTR_IRLib_P01_NECs_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendNEC & 0xff, MP_QSTR_IRsendNEC >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x80, 
    0xa6, 
    0x50, 0x02, 
    0x18, 
    0x61, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC___init__),
    MP_ROM_PTR(&raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECs__lt_module_gt__IRsendNEC,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 46,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P01_NECs.py, scope IRLib_P01_NECs_<module>
STATIC const byte bytecode_data_IRLib_P01_NECs__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P01_NECs_dot_py & 0xff, MP_QSTR_IRLib_P01_NECs_dot_py >> 8,
    0x61, 0x20, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendNEC & 0xff, MP_QSTR_IRsendNEC >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendNEC & 0xff, MP_QSTR_IRsendNEC >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P01_NECs__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P01_NECs__lt_module_gt__IRsendNEC),
};
const mp_raw_code_t raw_code_IRLib_P01_NECs__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P01_NECs__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P01_NECs__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonyd.py, scope IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__
STATIC const byte bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P02_Sonyd_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonyd_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonyd.py, scope IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode
STATIC const byte bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode[279] = {
    0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x21,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P02_Sonyd_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonyd_dot_py >> 8,
    0x81, 0x09, 0x27, 0x42, 0x30, 0x30, 0x30, 0x30, 0x22, 0x27, 0x34, 0x22, 0x22, 0x23, 0x34, 0x22, 0x24, 0x34, 0x29, 0x34, 0x47, 0x22, 0x34, 0x29, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x80, 
    0xc1, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x91, 
    0xf5, 
    0x37, 0x32, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x99, 
    0xf5, 
    0x37, 0x22, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x9f, 
    0xf5, 
    0x37, 0x12, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xa9, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x36, 0x16, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x92, 0x60, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x81, 
    0xc2, 
    0x35, 0x58, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb2, 
    0x21, 
    0x14, 0x84, 0x58, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb2, 
    0x81, 
    0xdc, 
    0xc2, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb2, 
    0x21, 
    0x14, 0x89, 0x30, 
    0x66, 0x02, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc1, 
    0x35, 0x1d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb2, 
    0x21, 
    0x14, 0x84, 0x58, 
    0x66, 0x02, 
    0x37, 0x07, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0xc1, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb2, 
    0x81, 
    0xdc, 
    0xc2, 
    0xb2, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xf0, 
    0x36, 0x98, 0x7f, 
    0xb2, 
    0x81, 
    0xdd, 
    0x82, 
    0xdf, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_SONY & 0xff, MP_QSTR_SONY >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 279,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonyd.py, scope IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony
STATIC const byte bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeSony & 0xff, MP_QSTR_IRdecodeSony >> 8,
    MP_QSTR_IRLib_P02_Sonyd_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonyd_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeSony & 0xff, MP_QSTR_IRdecodeSony >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony___init__),
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonyd.py, scope IRLib_P02_Sonyd_<module>
STATIC const byte bytecode_data_IRLib_P02_Sonyd__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P02_Sonyd_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonyd_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeSony & 0xff, MP_QSTR_IRdecodeSony >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeSony & 0xff, MP_QSTR_IRdecodeSony >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonyd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonyd__lt_module_gt__IRdecodeSony),
};
const mp_raw_code_t raw_code_IRLib_P02_Sonyd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonyd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonyd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonys.py, scope IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__
STATIC const byte bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P02_Sonys_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonys_dot_py >> 8,
    0x61, 0x60, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonys.py, scope IRLib_P02_Sonys__lt_module_gt__IRsendSony_send
STATIC const byte bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send[68] = {
    0x13, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0a,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P02_Sonys_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonys_dot_py >> 8,
    0x81, 0x08, 0x26, 0x00, 0x00, 0xff,
    0x80, 
    0x35, 0x26, 0x80, 
    0x30, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0x80, 
    0xb2, 
    0x14, 0x92, 0x60, 
    0x14, 0x84, 0x58, 
    0x14, 0x89, 0x30, 
    0x14, 0x84, 0x58, 
    0x14, 0x84, 0x58, 
    0x14, 0x84, 0x58, 
    0xa8, 
    0x10, 
    0x14, 0x82, 0xdf, 0x48, 
    0x66, 0x0c, 
    0x32, 
    0x81, 
    0xe9, 
    0x30, 
    0x83, 
    0xf0, 
    0x36, 0xd4, 0x7f, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_bits),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 68,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonys.py, scope IRLib_P02_Sonys__lt_module_gt__IRsendSony
STATIC const byte bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendSony & 0xff, MP_QSTR_IRsendSony >> 8,
    MP_QSTR_IRLib_P02_Sonys_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonys_dot_py >> 8,
    0x6d, 0x40, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendSony & 0xff, MP_QSTR_IRsendSony >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony___init__),
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonys__lt_module_gt__IRsendSony,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P02_Sonys.py, scope IRLib_P02_Sonys_<module>
STATIC const byte bytecode_data_IRLib_P02_Sonys__lt_module_gt_[43] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P02_Sonys_dot_py & 0xff, MP_QSTR_IRLib_P02_Sonys_dot_py >> 8,
    0x61, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendSony & 0xff, MP_QSTR_IRsendSony >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendSony & 0xff, MP_QSTR_IRsendSony >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P02_Sonys__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P02_Sonys__lt_module_gt__IRsendSony),
};
const mp_raw_code_t raw_code_IRLib_P02_Sonys__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P02_Sonys__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P02_Sonys__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5d.py, scope IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode
STATIC const byte bytecode_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode[226] = {
    0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1f,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P03_RC5d_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5d_dot_py >> 8,
    0x81, 0x09, 0x27, 0x30, 0x22, 0x25, 0x22, 0x25, 0x27, 0x30, 0x22, 0x22, 0x23, 0x27, 0x27, 0x36, 0x29, 0x36, 0x47, 0x22, 0x37, 0x25, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x8d, 
    0xf0, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x80, 
    0xc1, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0x14, 0x86, 0x79, 
    0xb0, 
    0x26, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xc2, 
    0x35, 0x50, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xc4, 
    0xb3, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xf2, 
    0x37, 0x14, 0x80, 
    0xb4, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf2, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc1, 
    0x35, 0x1f, 0x80, 
    0xb3, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf2, 
    0x37, 0x12, 0x80, 
    0xb4, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xf2, 
    0x37, 0x07, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0xc1, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb2, 
    0x81, 
    0xdc, 
    0xc2, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xf0, 
    0x36, 0x9d, 0x7f, 
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_RC5 & 0xff, MP_QSTR_RC5 >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 226,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5d.py, scope IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5
STATIC const byte bytecode_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5[35] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR_IRdecodeRC5 & 0xff, MP_QSTR_IRdecodeRC5 >> 8,
    MP_QSTR_IRLib_P03_RC5d_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5d_dot_py >> 8,
    0x8d, 0x07, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeRC5 & 0xff, MP_QSTR_IRdecodeRC5 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 35,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5d.py, scope IRLib_P03_RC5d_<module>
STATIC const byte bytecode_data_IRLib_P03_RC5d__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P03_RC5d_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5d_dot_py >> 8,
    0x61, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeRC5 & 0xff, MP_QSTR_IRdecodeRC5 >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeRC5 & 0xff, MP_QSTR_IRdecodeRC5 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5d__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P03_RC5d__lt_module_gt__IRdecodeRC5),
};
const mp_raw_code_t raw_code_IRLib_P03_RC5d__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5d__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5d__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5s.py, scope IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__
STATIC const byte bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P03_RC5s_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5s_dot_py >> 8,
    0x61, 0x60, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5s.py, scope IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send
STATIC const byte bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send[187] = {
    0x0a, 0x00, 0x00, 0x04, 0x00, 0x02, 0x19,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P03_RC5s_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5s_dot_py >> 8,
    0x81, 0x08, 0x26, 0x22, 0x26, 0x22, 0x28, 0x26, 0x28, 0x2a, 0x27, 0x2b, 0x2a, 0x4d, 0x2a, 0x2a, 0x35, 0x30, 0x00, 0x00, 0xff,
    0xb2, 
    0x80, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x8d, 
    0xc2, 
    0xb3, 
    0x80, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0xa4, 
    0xc3, 
    0xb1, 
    0x82, 
    0xb2, 
    0xe2, 
    0x81, 
    0xdd, 
    0xd9, 
    0xc1, 
    0xb1, 
    0x9c, 
    0xb2, 
    0xdd, 
    0xda, 
    0xc1, 
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xb3, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0xb2, 
    0x80, 
    0x35, 0x45, 0x80, 
    0x30, 
    0xc4, 
    0xb1, 
    0x14, 0x80, 0xc0, 0x80, 0x80, 0x00, 
    0xd9, 
    0x37, 0x17, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x14, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x81, 
    0xda, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xb5, 0x7f, 
    0x32, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0xfa, 0x50, 
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0xdd, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_numBits),
    MP_ROM_QSTR(MP_QSTR_kHz),
};
STATIC const mp_raw_code_t raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 187,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5s.py, scope IRLib_P03_RC5s__lt_module_gt__IRsendRC5
STATIC const byte bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5[46] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendRC5 & 0xff, MP_QSTR_IRsendRC5 >> 8,
    MP_QSTR_IRLib_P03_RC5s_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5s_dot_py >> 8,
    0x6d, 0x40, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendRC5 & 0xff, MP_QSTR_IRsendRC5 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x8d, 
    0xa4, 
    0x50, 0x02, 
    0x18, 
    0x61, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5___init__),
    MP_ROM_PTR(&raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5s__lt_module_gt__IRsendRC5,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 46,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P03_RC5s.py, scope IRLib_P03_RC5s_<module>
STATIC const byte bytecode_data_IRLib_P03_RC5s__lt_module_gt_[43] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P03_RC5s_dot_py & 0xff, MP_QSTR_IRLib_P03_RC5s_dot_py >> 8,
    0x61, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendRC5 & 0xff, MP_QSTR_IRsendRC5 >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendRC5 & 0xff, MP_QSTR_IRsendRC5 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P03_RC5s__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P03_RC5s__lt_module_gt__IRsendRC5),
};
const mp_raw_code_t raw_code_IRLib_P03_RC5s__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P03_RC5s__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P03_RC5s__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6d.py, scope IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode
STATIC const byte bytecode_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode[415] = {
    0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x35,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P04_RC6d_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6d_dot_py >> 8,
    0x81, 0x0a, 0x27, 0x30, 0x32, 0x22, 0x27, 0x34, 0x22, 0x34, 0x22, 0x25, 0x22, 0x22, 0x25, 0x47, 0x30, 0x22, 0x30, 0x22, 0x22, 0x23, 0x27, 0x46, 0x2b, 0x22, 0x27, 0x26, 0x2b, 0x22, 0x36, 0x29, 0x36, 0x47, 0x22, 0x26, 0x28, 0x29, 0x37, 0x26, 0x22, 0x24, 0x25, 0x25, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x97, 
    0xf0, 
    0x36, 0x12, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x14, 0x80, 0x4d, 
    0xf1, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x36, 0x16, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x94, 0x6a, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x86, 0x79, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x82, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x80, 
    0xc1, 
    0x80, 
    0xc2, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0x14, 0x83, 0x3c, 
    0xb0, 
    0x26, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xc3, 
    0x35, 0x8d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xc4, 
    0xb3, 
    0x83, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb4, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xc5, 
    0xb3, 
    0x83, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb5, 
    0xb0, 
    0x1e, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x66, 0x00, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb4, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf2, 
    0x37, 0x14, 0x80, 
    0xb5, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xf2, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc1, 
    0x35, 0x1f, 0x80, 
    0xb4, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xf2, 
    0x37, 0x12, 0x80, 
    0xb5, 
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xf2, 
    0x37, 0x07, 0x80, 
    0xb1, 
    0x81, 
    0xda, 
    0xc1, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb3, 
    0x9b, 
    0xf1, 
    0x37, 0x11, 0x80, 
    0xb2, 
    0x81, 
    0xda, 
    0xb1, 
    0x9c, 
    0xdb, 
    0xd7, 
    0xc2, 
    0xb1, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0xb3, 
    0x81, 
    0xdc, 
    0xc3, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xf0, 
    0x36, 0x60, 0x7f, 
    0xb3, 
    0xa4, 
    0xf2, 
    0x37, 0x06, 0x80, 
    0xa0, 
    0xc3, 
    0xb2, 
    0x8f, 
    0xd9, 
    0xc2, 
    0xb3, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_RC6 & 0xff, MP_QSTR_RC6 >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 415,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6d.py, scope IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6
STATIC const byte bytecode_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6[35] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR_IRdecodeRC6 & 0xff, MP_QSTR_IRdecodeRC6 >> 8,
    MP_QSTR_IRLib_P04_RC6d_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6d_dot_py >> 8,
    0x8d, 0x08, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeRC6 & 0xff, MP_QSTR_IRdecodeRC6 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 35,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6d.py, scope IRLib_P04_RC6d_<module>
STATIC const byte bytecode_data_IRLib_P04_RC6d__lt_module_gt_[62] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P04_RC6d_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6d_dot_py >> 8,
    0x61, 0x20, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeRC6 & 0xff, MP_QSTR_IRdecodeRC6 >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeRC6 & 0xff, MP_QSTR_IRdecodeRC6 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6d__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6d__lt_module_gt__IRdecodeRC6),
};
const mp_raw_code_t raw_code_IRLib_P04_RC6d__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6d__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6d__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 62,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6s.py, scope IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__
STATIC const byte bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P04_RC6s_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6s_dot_py >> 8,
    0x81, 0x09, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6s.py, scope IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits
STATIC const byte bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits[138] = {
    0x0b, 0x00, 0x00, 0x04, 0x00, 0x00, 0x14,
    MP_QSTR_sendRC6Bits & 0xff, MP_QSTR_sendRC6Bits >> 8,
    MP_QSTR_IRLib_P04_RC6s_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6s_dot_py >> 8,
    0x81, 0x0b, 0x28, 0x26, 0x27, 0x2a, 0x47, 0x24, 0x2b, 0x28, 0x4b, 0x28, 0x28, 0x00, 0x00, 0xff,
    0xb1, 
    0x82, 
    0xb2, 
    0xe2, 
    0x81, 
    0xdd, 
    0xd9, 
    0xc1, 
    0xb1, 
    0x9c, 
    0xb2, 
    0xdd, 
    0xda, 
    0xc1, 
    0xb2, 
    0x80, 
    0x35, 0x52, 0x80, 
    0x30, 
    0xc4, 
    0xb3, 
    0x37, 0x0d, 0x80, 
    0xb4, 
    0x83, 
    0xf2, 
    0x37, 0x07, 0x80, 
    0x14, 0x86, 0x78, 
    0xc5, 
    0x35, 0x04, 0x80, 
    0x14, 0x83, 0x3c, 
    0xc5, 
    0xb1, 
    0x14, 0x80, 0xc0, 0x80, 0x80, 0x00, 
    0xd9, 
    0x37, 0x13, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x10, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x81, 
    0xda, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xa8, 0x7f, 
    0x32, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_numBits),
    MP_ROM_QSTR(MP_QSTR_first),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 138,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6s.py, scope IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send
STATIC const byte bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send[156] = {
    0x0b, 0x00, 0x00, 0x04, 0x00, 0x01, 0x18,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P04_RC6s_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6s_dot_py >> 8,
    0x81, 0x1a, 0x28, 0x26, 0x22, 0x2a, 0x2a, 0x2a, 0x2a, 0x22, 0x26, 0x26, 0x2d, 0x22, 0x22, 0x2d, 0x30, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xa4, 
    0x66, 0x01, 
    0x32, 
    0xb3, 
    0x80, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x8d, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x94, 0x6a, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0x79, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x83, 0x3c, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x83, 0x3c, 
    0x66, 0x01, 
    0x32, 
    0x12, 
    0xc4, 
    0xb3, 
    0xa0, 
    0xf2, 
    0x37, 0x17, 0x80, 
    0xb2, 
    0x14, 0x81, 0x40, 
    0xdc, 
    0xc2, 
    0x1c, MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    0x1e, MP_QSTR_sendRC6Bits & 0xff, MP_QSTR_sendRC6Bits >> 8,
    0xb0, 
    0xb2, 
    0x88, 
    0xb4, 
    0x66, 0x04, 
    0x32, 
    0x10, 
    0xc4, 
    0x9c, 
    0xc3, 
    0x1c, MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    0x1e, MP_QSTR_sendRC6Bits & 0xff, MP_QSTR_sendRC6Bits >> 8,
    0xb0, 
    0xb1, 
    0xb3, 
    0xb4, 
    0x66, 0x04, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0xc3, 0x78, 
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0xdd, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_address),
    MP_ROM_QSTR(MP_QSTR_numBits),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 156,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6s.py, scope IRLib_P04_RC6s__lt_module_gt__IRsendRC6
STATIC const byte bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6[52] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    MP_QSTR_IRLib_P04_RC6s_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6s_dot_py >> 8,
    0x8d, 0x08, 0x45, 0x85, 0x0f, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_sendRC6Bits & 0xff, MP_QSTR_sendRC6Bits >> 8,
    0x94, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x02, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6[3] = {
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6___init__),
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_sendRC6Bits),
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6s__lt_module_gt__IRsendRC6,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 52,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file IRLib_P04_RC6s.py, scope IRLib_P04_RC6s_<module>
STATIC const byte bytecode_data_IRLib_P04_RC6s__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P04_RC6s_dot_py & 0xff, MP_QSTR_IRLib_P04_RC6s_dot_py >> 8,
    0x61, 0x20, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendRC6 & 0xff, MP_QSTR_IRsendRC6 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P04_RC6s__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P04_RC6s__lt_module_gt__IRsendRC6),
};
const mp_raw_code_t raw_code_IRLib_P04_RC6s__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P04_RC6s__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P04_RC6s__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Oldd.py, scope IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Oldd.py, scope IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode[66] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py >> 8,
    0x81, 0x09, 0x47, 0x39, 0x22, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0xaf, 
    0x14, 0x9a, 0x04, 
    0x14, 0x9a, 0x04, 
    0x14, 0x86, 0x41, 
    0x14, 0x93, 0x43, 
    0x14, 0x86, 0x41, 
    0x66, 0x06, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_PANASONIC_OLD & 0xff, MP_QSTR_PANASONIC_OLD >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 66,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Oldd.py, scope IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodePanasonic_Old & 0xff, MP_QSTR_IRdecodePanasonic_Old >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodePanasonic_Old & 0xff, MP_QSTR_IRdecodePanasonic_Old >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old___init__),
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Oldd.py, scope IRLib_P05_Panasonic_Oldd_<module>
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Oldd_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodePanasonic_Old & 0xff, MP_QSTR_IRdecodePanasonic_Old >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodePanasonic_Old & 0xff, MP_QSTR_IRdecodePanasonic_Old >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt__IRdecodePanasonic_Old),
};
const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Oldd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Oldd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Olds.py, scope IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py >> 8,
    0x61, 0x40, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Olds.py, scope IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send[49] = {
    0x0f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0x80, 
    0x96, 
    0x14, 0x9a, 0x04, 
    0x14, 0x9a, 0x04, 
    0x14, 0x86, 0x41, 
    0x14, 0x86, 0x41, 
    0x14, 0x93, 0x43, 
    0x14, 0x86, 0x41, 
    0x14, 0x39, 
    0x12, 
    0x66, 0x0b, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 49,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Olds.py, scope IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendPanasonic_Old & 0xff, MP_QSTR_IRsendPanasonic_Old >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py >> 8,
    0x6d, 0x20, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendPanasonic_Old & 0xff, MP_QSTR_IRsendPanasonic_Old >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old___init__),
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P05_Panasonic_Olds.py, scope IRLib_P05_Panasonic_Olds_<module>
STATIC const byte bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt_[43] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py & 0xff, MP_QSTR_IRLib_P05_Panasonic_Olds_dot_py >> 8,
    0x41, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendPanasonic_Old & 0xff, MP_QSTR_IRsendPanasonic_Old >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendPanasonic_Old & 0xff, MP_QSTR_IRsendPanasonic_Old >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt__IRsendPanasonic_Old),
};
const mp_raw_code_t raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P05_Panasonic_Olds__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P05_Panasonic_Olds__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCd.py, scope IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__
STATIC const byte bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P06_JVCd_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCd_dot_py >> 8,
    0x81, 0x08, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCd.py, scope IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode
STATIC const byte bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode[211] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x17,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P06_JVCd_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCd_dot_py >> 8,
    0x81, 0x0a, 0x47, 0x5a, 0x30, 0x22, 0x37, 0x62, 0x34, 0x30, 0x34, 0x22, 0x2a, 0x28, 0x31, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0xa3, 
    0x14, 0x80, 0xc1, 0x50, 
    0x14, 0xa0, 0x68, 
    0x14, 0x84, 0x0d, 
    0x14, 0x8c, 0x27, 
    0x14, 0x84, 0x0d, 
    0x66, 0x06, 
    0x36, 0x77, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xa1, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0x80, 
    0x14, 0x84, 0x0d, 
    0x80, 
    0x14, 0x84, 0x0d, 
    0x14, 0x8c, 0x27, 
    0x14, 0x84, 0x0d, 
    0x66, 0x06, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x8c, 0x27, 
    0x66, 0x02, 
    0x37, 0x10, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x14, 0x82, 0x80, 0x00, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x35, 0x16, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x84, 0x0d, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb0, 
    0x1d, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xa3, 
    0xf2, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_JVC & 0xff, MP_QSTR_JVC >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 211,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCd.py, scope IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC
STATIC const byte bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeJVC & 0xff, MP_QSTR_IRdecodeJVC >> 8,
    MP_QSTR_IRLib_P06_JVCd_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCd_dot_py >> 8,
    0x8d, 0x07, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeJVC & 0xff, MP_QSTR_IRdecodeJVC >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC___init__),
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCd.py, scope IRLib_P06_JVCd_<module>
STATIC const byte bytecode_data_IRLib_P06_JVCd__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P06_JVCd_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCd_dot_py >> 8,
    0x61, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeJVC & 0xff, MP_QSTR_IRdecodeJVC >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeJVC & 0xff, MP_QSTR_IRdecodeJVC >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCd__lt_module_gt__IRdecodeJVC),
};
const mp_raw_code_t raw_code_IRLib_P06_JVCd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCs.py, scope IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__
STATIC const byte bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P06_JVCs_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCs_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCs.py, scope IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send
STATIC const byte bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send[122] = {
    0x10, 0x00, 0x00, 0x03, 0x00, 0x01, 0x0e,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P06_JVCs_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCs_dot_py >> 8,
    0x81, 0x09, 0x33, 0x3c, 0x2b, 0x24, 0x3a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0x80, 
    0x90, 
    0xb2, 
    0x37, 0x07, 0x80, 
    0x14, 0x80, 0xc1, 0x50, 
    0x35, 0x01, 0x80, 
    0x80, 
    0xb2, 
    0x37, 0x06, 0x80, 
    0x14, 0xa0, 0x68, 
    0x35, 0x01, 0x80, 
    0x80, 
    0x14, 0x84, 0x0d, 
    0x14, 0x84, 0x0d, 
    0x14, 0x8c, 0x27, 
    0x14, 0x84, 0x0d, 
    0xa6, 
    0x12, 
    0x66, 0x0b, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x81, 0xb8, 0x49, 
    0x66, 0x01, 
    0x32, 
    0xb2, 
    0x37, 0x25, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0x80, 
    0x90, 
    0x80, 
    0x80, 
    0x14, 0x84, 0x0d, 
    0x14, 0x84, 0x0d, 
    0x14, 0x8c, 0x27, 
    0x14, 0x84, 0x0d, 
    0xa6, 
    0x12, 
    0x66, 0x0b, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x81, 0xb8, 0x49, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_first),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 122,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCs.py, scope IRLib_P06_JVCs__lt_module_gt__IRsendJVC
STATIC const byte bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC[45] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendJVC & 0xff, MP_QSTR_IRsendJVC >> 8,
    MP_QSTR_IRLib_P06_JVCs_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCs_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendJVC & 0xff, MP_QSTR_IRsendJVC >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x12, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC___init__),
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCs__lt_module_gt__IRsendJVC,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 45,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P06_JVCs.py, scope IRLib_P06_JVCs_<module>
STATIC const byte bytecode_data_IRLib_P06_JVCs__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P06_JVCs_dot_py & 0xff, MP_QSTR_IRLib_P06_JVCs_dot_py >> 8,
    0x61, 0x20, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendJVC & 0xff, MP_QSTR_IRsendJVC >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendJVC & 0xff, MP_QSTR_IRsendJVC >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P06_JVCs__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P06_JVCs__lt_module_gt__IRsendJVC),
};
const mp_raw_code_t raw_code_IRLib_P06_JVCs__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P06_JVCs__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P06_JVCs__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxd.py, scope IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__
STATIC const byte bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P07_NECxd_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxd_dot_py >> 8,
    0x81, 0x09, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxd.py, scope IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode
STATIC const byte bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode[195] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x16,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P07_NECxd_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxd_dot_py >> 8,
    0x81, 0x0b, 0x47, 0x30, 0x34, 0x34, 0x34, 0x34, 0x25, 0x25, 0x2a, 0x42, 0x3b, 0x22, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x85, 
    0xf2, 
    0x37, 0x66, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0xa3, 0x14, 
    0x66, 0x02, 
    0x37, 0x52, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0xa3, 0x14, 
    0x66, 0x02, 
    0x37, 0x3e, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x82, 
    0x21, 
    0x14, 0x84, 0x34, 
    0x66, 0x02, 
    0x37, 0x2a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x84, 
    0x21, 
    0x14, 0x84, 0x34, 
    0x66, 0x02, 
    0x37, 0x16, 0x80, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x7f, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_NECX & 0xff, MP_QSTR_NECX >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0x14, 0x80, 0x43, 
    0x14, 0xa3, 0x14, 
    0x14, 0xa3, 0x14, 
    0x14, 0x84, 0x34, 
    0x14, 0x8d, 0x1c, 
    0x14, 0x84, 0x34, 
    0x66, 0x06, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_NECX & 0xff, MP_QSTR_NECX >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 195,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxd.py, scope IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx
STATIC const byte bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeNECx & 0xff, MP_QSTR_IRdecodeNECx >> 8,
    MP_QSTR_IRLib_P07_NECxd_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxd_dot_py >> 8,
    0x8d, 0x08, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeNECx & 0xff, MP_QSTR_IRdecodeNECx >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx___init__),
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxd.py, scope IRLib_P07_NECxd_<module>
STATIC const byte bytecode_data_IRLib_P07_NECxd__lt_module_gt_[62] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P07_NECxd_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxd_dot_py >> 8,
    0x61, 0x20, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeNECx & 0xff, MP_QSTR_IRdecodeNECx >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeNECx & 0xff, MP_QSTR_IRdecodeNECx >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxd__lt_module_gt__IRdecodeNECx),
};
const mp_raw_code_t raw_code_IRLib_P07_NECxd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 62,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxs.py, scope IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__
STATIC const byte bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P07_NECxs_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxs_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxs.py, scope IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send
STATIC const byte bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send[142] = {
    0x10, 0x00, 0x00, 0x03, 0x00, 0x00, 0x12,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P07_NECxs_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxs_dot_py >> 8,
    0x81, 0x09, 0x26, 0x28, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2b, 0x4a, 0x00, 0x00, 0xff,
    0xb1, 
    0x7f, 
    0xf2, 
    0x37, 0x4f, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xa6, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0xa3, 0x14, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0xa3, 0x14, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x84, 0x34, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x84, 0x34, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x84, 0x34, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x81, 0xff, 0x7f, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x35, 0x1e, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0xb2, 
    0xa0, 
    0x14, 0xa3, 0x14, 
    0x14, 0xa3, 0x14, 
    0x14, 0x84, 0x34, 
    0x14, 0x84, 0x34, 
    0x14, 0x8d, 0x1c, 
    0x14, 0x84, 0x34, 
    0xa6, 
    0x12, 
    0x66, 0x0b, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_address),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 142,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxs.py, scope IRLib_P07_NECxs__lt_module_gt__IRsendNECx
STATIC const byte bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendNECx & 0xff, MP_QSTR_IRsendNECx >> 8,
    MP_QSTR_IRLib_P07_NECxs_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxs_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendNECx & 0xff, MP_QSTR_IRsendNECx >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx___init__),
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxs__lt_module_gt__IRsendNECx,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P07_NECxs.py, scope IRLib_P07_NECxs_<module>
STATIC const byte bytecode_data_IRLib_P07_NECxs__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P07_NECxs_dot_py & 0xff, MP_QSTR_IRLib_P07_NECxs_dot_py >> 8,
    0x61, 0x20, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendNECx & 0xff, MP_QSTR_IRsendNECx >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendNECx & 0xff, MP_QSTR_IRsendNECx >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P07_NECxs__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P07_NECxs__lt_module_gt__IRsendNECx),
};
const mp_raw_code_t raw_code_IRLib_P07_NECxs__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P07_NECxs__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P07_NECxs__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36d.py, scope IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__
STATIC const byte bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36d_dot_py >> 8,
    0x81, 0x08, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36d.py, scope IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits
STATIC const byte bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits[161] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x13,
    MP_QSTR_getBits & 0xff, MP_QSTR_getBits >> 8,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36d_dot_py >> 8,
    0x81, 0x0a, 0x23, 0x37, 0x22, 0x2a, 0x37, 0x2f, 0x37, 0x4d, 0x22, 0x33, 0x00, 0x00, 0xff,
    0x35, 0x79, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0x14, 0x83, 0x74, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0x14, 0x8b, 0x5c, 
    0x66, 0x02, 
    0x37, 0x0f, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xb0, 
    0x26, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x35, 0x26, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0x14, 0x83, 0x74, 
    0x66, 0x02, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x81, 
    0xda, 
    0xb0, 
    0x26, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb1, 
    0xf0, 
    0x36, 0x7e, 0x7f, 
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_lastOffset),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 161,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36d.py, scope IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode
STATIC const byte bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode[310] = {
    0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36d_dot_py >> 8,
    0x81, 0x17, 0x47, 0x32, 0x22, 0x34, 0x22, 0x34, 0x22, 0x25, 0x25, 0x2d, 0x22, 0x37, 0x22, 0x2a, 0x37, 0x22, 0x2a, 0x25, 0x65, 0x56, 0x4f, 0x36, 0x22, 0x25, 0x28, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x14, 0x80, 0x4d, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0xa3, 0x14, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0xa3, 0x14, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x82, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x1c, MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    0x1e, MP_QSTR_getBits & 0xff, MP_QSTR_getBits >> 8,
    0xb0, 
    0xa1, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0x14, 0x83, 0x74, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0x14, 0xa3, 0x14, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb0, 
    0x1d, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0xc1, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x14, 0x3e, 
    0x21, 
    0x14, 0x80, 0x44, 
    0xdd, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x14, 0x3d, 
    0x27, 
    0x1c, MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    0x1e, MP_QSTR_getBits & 0xff, MP_QSTR_getBits >> 8,
    0xb0, 
    0x14, 0x80, 0x4c, 
    0x66, 0x02, 
    0x36, 0x18, 0x80, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x14, 0x3e, 
    0x21, 
    0x14, 0x80, 0x44, 
    0xdc, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x14, 0x3d, 
    0x27, 
    0x10, 
    0x5b, 
    0xa4, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb0, 
    0x1d, MP_QSTR_data & 0xff, MP_QSTR_data >> 8,
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_SAMSUNG36 & 0xff, MP_QSTR_SAMSUNG36 >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 310,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36d.py, scope IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36
STATIC const byte bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36[48] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36d_dot_py >> 8,
    0x8d, 0x07, 0x45, 0x85, 0x0d, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_getBits & 0xff, MP_QSTR_getBits >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36[3] = {
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36___init__),
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_getBits),
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 48,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36d.py, scope IRLib_P08_Samsung36d_<module>
STATIC const byte bytecode_data_IRLib_P08_Samsung36d__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P08_Samsung36d_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36d_dot_py >> 8,
    0x61, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeSamsung36 & 0xff, MP_QSTR_IRdecodeSamsung36 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36d__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36d__lt_module_gt__IRdecodeSamsung36),
};
const mp_raw_code_t raw_code_IRLib_P08_Samsung36d__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36d__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36d__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36s.py, scope IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__
STATIC const byte bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P08_Samsung36s_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36s_dot_py >> 8,
    0x61, 0x60, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36s.py, scope IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send
STATIC const byte bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send[180] = {
    0x0b, 0x00, 0x00, 0x03, 0x00, 0x00, 0x14,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P08_Samsung36s_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36s_dot_py >> 8,
    0x81, 0x08, 0x28, 0x2a, 0x2a, 0x35, 0x2a, 0x2a, 0x37, 0x2a, 0x35, 0x2a, 0x2b, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xa6, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0xa3, 0x14, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0xa3, 0x14, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0xb2, 
    0x90, 
    0x14, 0x83, 0x74, 
    0x14, 0x83, 0x74, 
    0x14, 0x8b, 0x5c, 
    0x14, 0x83, 0x74, 
    0x66, 0x06, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x83, 0x74, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0xa3, 0x14, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0xb1, 
    0x88, 
    0xdb, 
    0x8c, 
    0x14, 0x83, 0x74, 
    0x14, 0x83, 0x74, 
    0x14, 0x8b, 0x5c, 
    0x14, 0x83, 0x74, 
    0x66, 0x06, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x80, 0x44, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0xb1, 
    0x88, 
    0x14, 0x83, 0x74, 
    0x14, 0x83, 0x74, 
    0x14, 0x8b, 0x5c, 
    0x14, 0x83, 0x74, 
    0x66, 0x06, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x83, 0x74, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x83, 0xcc, 0x78, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_address),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 180,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36s.py, scope IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36
STATIC const byte bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendSamsung36 & 0xff, MP_QSTR_IRsendSamsung36 >> 8,
    MP_QSTR_IRLib_P08_Samsung36s_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36s_dot_py >> 8,
    0x6d, 0x40, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendSamsung36 & 0xff, MP_QSTR_IRsendSamsung36 >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36___init__),
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P08_Samsung36s.py, scope IRLib_P08_Samsung36s_<module>
STATIC const byte bytecode_data_IRLib_P08_Samsung36s__lt_module_gt_[43] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P08_Samsung36s_dot_py & 0xff, MP_QSTR_IRLib_P08_Samsung36s_dot_py >> 8,
    0x61, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendSamsung36 & 0xff, MP_QSTR_IRsendSamsung36 >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendSamsung36 & 0xff, MP_QSTR_IRsendSamsung36 >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P08_Samsung36s__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P08_Samsung36s__lt_module_gt__IRsendSamsung36),
};
const mp_raw_code_t raw_code_IRLib_P08_Samsung36s__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P08_Samsung36s__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P08_Samsung36s__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICabled.py, scope IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__
STATIC const byte bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P09_GICabled_dot_py & 0xff, MP_QSTR_IRLib_P09_GICabled_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICabled.py, scope IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode
STATIC const byte bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode[174] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x15,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P09_GICabled_dot_py & 0xff, MP_QSTR_IRLib_P09_GICabled_dot_py >> 8,
    0x81, 0x09, 0x47, 0x30, 0x35, 0x34, 0x34, 0x25, 0x25, 0x2a, 0x22, 0x3a, 0x22, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x83, 
    0xf2, 
    0x37, 0x53, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x80, 0xc4, 0x74, 
    0x66, 0x02, 
    0x37, 0x3e, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x91, 0x1d, 
    0x66, 0x02, 
    0x37, 0x2a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x82, 
    0x21, 
    0x14, 0x83, 0x6a, 
    0x66, 0x02, 
    0x37, 0x16, 0x80, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x7f, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_GICABLE & 0xff, MP_QSTR_GICABLE >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0xa3, 
    0x14, 0x80, 0xc4, 0x74, 
    0x14, 0xa2, 0x3a, 
    0x14, 0x83, 0x6a, 
    0x14, 0xa2, 0x3a, 
    0x14, 0x91, 0x1d, 
    0x66, 0x06, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_GICABLE & 0xff, MP_QSTR_GICABLE >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 174,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICabled.py, scope IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable
STATIC const byte bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeGICable & 0xff, MP_QSTR_IRdecodeGICable >> 8,
    MP_QSTR_IRLib_P09_GICabled_dot_py & 0xff, MP_QSTR_IRLib_P09_GICabled_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeGICable & 0xff, MP_QSTR_IRdecodeGICable >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable___init__),
    MP_ROM_PTR(&raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICabled.py, scope IRLib_P09_GICabled_<module>
STATIC const byte bytecode_data_IRLib_P09_GICabled__lt_module_gt_[61] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P09_GICabled_dot_py & 0xff, MP_QSTR_IRLib_P09_GICabled_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeGICable & 0xff, MP_QSTR_IRdecodeGICable >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeGICable & 0xff, MP_QSTR_IRdecodeGICable >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICabled__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P09_GICabled__lt_module_gt__IRdecodeGICable),
};
const mp_raw_code_t raw_code_IRLib_P09_GICabled__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICabled__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICabled__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 61,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICables.py, scope IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__
STATIC const byte bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P09_GICables_dot_py & 0xff, MP_QSTR_IRLib_P09_GICables_dot_py >> 8,
    0x61, 0x40, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICables.py, scope IRLib_P09_GICables__lt_module_gt__IRsendGICable_send
STATIC const byte bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send[122] = {
    0x0f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P09_GICables_dot_py & 0xff, MP_QSTR_IRLib_P09_GICables_dot_py >> 8,
    0x81, 0x07, 0x26, 0x28, 0x2b, 0x2a, 0x2a, 0x2b, 0x4a, 0x00, 0x00, 0xff,
    0xb1, 
    0x7f, 
    0xf2, 
    0x37, 0x3c, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xa7, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x80, 0xc4, 0x74, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x91, 0x1d, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x83, 0x6a, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x85, 0xa9, 0x34, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x35, 0x1f, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0xb1, 
    0x80, 
    0x90, 
    0x14, 0x80, 0xc4, 0x74, 
    0x14, 0xa2, 0x3a, 
    0x14, 0x83, 0x6a, 
    0x14, 0x83, 0x6a, 
    0x14, 0xa2, 0x3a, 
    0x14, 0x91, 0x1d, 
    0xa7, 
    0x12, 
    0x66, 0x0b, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 122,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICables.py, scope IRLib_P09_GICables__lt_module_gt__IRsendGICable
STATIC const byte bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendGICable & 0xff, MP_QSTR_IRsendGICable >> 8,
    MP_QSTR_IRLib_P09_GICables_dot_py & 0xff, MP_QSTR_IRLib_P09_GICables_dot_py >> 8,
    0x6d, 0x20, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendGICable & 0xff, MP_QSTR_IRsendGICable >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable___init__),
    MP_ROM_PTR(&raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICables__lt_module_gt__IRsendGICable,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P09_GICables.py, scope IRLib_P09_GICables_<module>
STATIC const byte bytecode_data_IRLib_P09_GICables__lt_module_gt_[43] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P09_GICables_dot_py & 0xff, MP_QSTR_IRLib_P09_GICables_dot_py >> 8,
    0x41, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendGICable & 0xff, MP_QSTR_IRsendGICable >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendGICable & 0xff, MP_QSTR_IRsendGICable >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P09_GICables__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P09_GICables__lt_module_gt__IRsendGICable),
};
const mp_raw_code_t raw_code_IRLib_P09_GICables__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P09_GICables__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P09_GICables__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVd.py, scope IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__
STATIC const byte bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P10_DirecTVd_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVd_dot_py >> 8,
    0x81, 0x0a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVd.py, scope IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode
STATIC const byte bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode[313] = {
    0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x27,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P10_DirecTVd_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVd_dot_py >> 8,
    0x81, 0x0c, 0x47, 0x30, 0x42, 0x27, 0x34, 0x25, 0x34, 0x42, 0x22, 0x34, 0x22, 0x22, 0x22, 0x23, 0x34, 0x29, 0x34, 0x47, 0x22, 0x24, 0x34, 0x29, 0x34, 0x47, 0x22, 0x2a, 0x25, 0x25, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x93, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x36, 0x31, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x97, 0x38, 
    0x66, 0x02, 
    0x37, 0x05, 0x80, 
    0x10, 
    0xc1, 
    0x35, 0x18, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0xae, 0x70, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x12, 
    0xc1, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x89, 0x30, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xc2, 
    0x82, 
    0xc3, 
    0x35, 0x7c, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x89, 0x30, 
    0x66, 0x02, 
    0x37, 0x09, 0x80, 
    0xb2, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc2, 
    0x35, 0x1d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x84, 0x58, 
    0x66, 0x02, 
    0x37, 0x07, 0x80, 
    0xb2, 
    0x81, 
    0xda, 
    0xc2, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb3, 
    0x81, 
    0xdc, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x89, 0x30, 
    0x66, 0x02, 
    0x37, 0x09, 0x80, 
    0xb2, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc2, 
    0x35, 0x1d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x84, 0x58, 
    0x66, 0x02, 
    0x37, 0x07, 0x80, 
    0xb2, 
    0x81, 
    0xda, 
    0xc2, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb3, 
    0x81, 
    0xdc, 
    0xc3, 
    0xb3, 
    0x91, 
    0xf0, 
    0x36, 0x7e, 0x7f, 
    0x90, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_DIRECTV & 0xff, MP_QSTR_DIRECTV >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 313,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVd.py, scope IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV
STATIC const byte bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeDirecTV & 0xff, MP_QSTR_IRdecodeDirecTV >> 8,
    MP_QSTR_IRLib_P10_DirecTVd_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVd_dot_py >> 8,
    0x8d, 0x09, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeDirecTV & 0xff, MP_QSTR_IRdecodeDirecTV >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV___init__),
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVd.py, scope IRLib_P10_DirecTVd_<module>
STATIC const byte bytecode_data_IRLib_P10_DirecTVd__lt_module_gt_[62] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P10_DirecTVd_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVd_dot_py >> 8,
    0x61, 0x40, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeDirecTV & 0xff, MP_QSTR_IRdecodeDirecTV >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeDirecTV & 0xff, MP_QSTR_IRdecodeDirecTV >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVd__lt_module_gt__IRdecodeDirecTV),
};
const mp_raw_code_t raw_code_IRLib_P10_DirecTVd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 62,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVs.py, scope IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__
STATIC const byte bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P10_DirecTVs_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVs_dot_py >> 8,
    0x81, 0x08, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVs.py, scope IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send
STATIC const byte bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send[218] = {
    0x09, 0x00, 0x00, 0x04, 0x00, 0x02, 0x18,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P10_DirecTVs_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVs_dot_py >> 8,
    0x81, 0x0a, 0x28, 0x28, 0x34, 0x2a, 0x26, 0x29, 0x4d, 0x2a, 0x29, 0x29, 0x4d, 0x2a, 0x32, 0x2a, 0x39, 0x00, 0x00, 0xff,
    0xb1, 
    0x82, 
    0x90, 
    0xe2, 
    0x81, 
    0xdd, 
    0xd9, 
    0xc1, 
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xb3, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb2, 
    0x37, 0x06, 0x80, 
    0x14, 0xae, 0x70, 
    0x35, 0x03, 0x80, 
    0x14, 0x97, 0x38, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x89, 0x30, 
    0x66, 0x01, 
    0x32, 
    0x80, 
    0x35, 0x56, 0x80, 
    0x30, 
    0xc4, 
    0xb1, 
    0x14, 0x82, 0x80, 0x00, 
    0xd9, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x89, 0x30, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x0a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x84, 0x58, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x81, 
    0xda, 
    0x14, 0x83, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0xb1, 
    0x14, 0x82, 0x80, 0x00, 
    0xd9, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x89, 0x30, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x0a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x84, 0x58, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x81, 
    0xda, 
    0x14, 0x83, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0x81, 
    0xe9, 
    0x30, 
    0x88, 
    0xf0, 
    0x36, 0xa4, 0x7f, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x84, 0x58, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb0, 
    0x1d, MP_QSTR_longLeadOut & 0xff, MP_QSTR_longLeadOut >> 8,
    0x37, 0x07, 0x80, 
    0x14, 0x81, 0xea, 0x30, 
    0x35, 0x04, 0x80, 
    0x14, 0x80, 0xc6, 0x28, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_first),
    MP_ROM_QSTR(MP_QSTR_kHz),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 218,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVs.py, scope IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV
STATIC const byte bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV[46] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRsendDirecTV & 0xff, MP_QSTR_IRsendDirecTV >> 8,
    MP_QSTR_IRLib_P10_DirecTVs_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVs_dot_py >> 8,
    0x8d, 0x07, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendDirecTV & 0xff, MP_QSTR_IRsendDirecTV >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x12, 
    0xa6, 
    0x50, 0x02, 
    0x18, 
    0x61, 0x01, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV___init__),
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 46,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P10_DirecTVs.py, scope IRLib_P10_DirecTVs_<module>
STATIC const byte bytecode_data_IRLib_P10_DirecTVs__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P10_DirecTVs_dot_py & 0xff, MP_QSTR_IRLib_P10_DirecTVs_dot_py >> 8,
    0x61, 0x40, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendDirecTV & 0xff, MP_QSTR_IRsendDirecTV >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendDirecTV & 0xff, MP_QSTR_IRsendDirecTV >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P10_DirecTVs__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P10_DirecTVs__lt_module_gt__IRsendDirecTV),
};
const mp_raw_code_t raw_code_IRLib_P10_DirecTVs__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P10_DirecTVs__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P10_DirecTVs__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMd.py, scope IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__
STATIC const byte bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__[31] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P11_RCMMd_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMd_dot_py >> 8,
    0x81, 0x0a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMd.py, scope IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode
STATIC const byte bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode[442] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x2e,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_IRLib_P11_RCMMd_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMd_dot_py >> 8,
    0x81, 0x0c, 0x47, 0x30, 0x30, 0x30, 0x22, 0x27, 0x34, 0x22, 0x34, 0x22, 0x22, 0x22, 0x22, 0x23, 0x37, 0x29, 0x22, 0x24, 0x37, 0x27, 0x37, 0x29, 0x37, 0x29, 0x37, 0x49, 0x22, 0x26, 0x28, 0x29, 0x36, 0x34, 0x22, 0x31, 0x25, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x8f, 
    0xf5, 
    0x37, 0x22, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x9b, 
    0xf5, 
    0x37, 0x12, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xa3, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x36, 0x16, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x14, 0x83, 0x21, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x14, 0x82, 0x16, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x80, 
    0xc1, 
    0x80, 
    0xc2, 
    0x82, 
    0xc3, 
    0x35, 0xc1, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x81, 0x27, 
    0x1c, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x66, 0x03, 
    0x36, 0x0b, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x01, 
    0xb3, 
    0x64, 0x02, 
    0x32, 
    0x10, 
    0x5b, 
    0xb3, 
    0x81, 
    0xdc, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x82, 0x16, 
    0x1c, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x66, 0x03, 
    0x37, 0x07, 0x80, 
    0xb1, 
    0x82, 
    0xda, 
    0xc1, 
    0x35, 0x62, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x83, 0x3c, 
    0x1c, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x66, 0x03, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x82, 
    0xda, 
    0x81, 
    0xdc, 
    0xc1, 
    0x35, 0x42, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x84, 0x63, 
    0x1c, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x66, 0x03, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x82, 
    0xda, 
    0x82, 
    0xdc, 
    0xc1, 
    0x35, 0x22, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x86, 0x0a, 
    0x1c, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x66, 0x03, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x82, 
    0xda, 
    0x83, 
    0xdc, 
    0xc1, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb3, 
    0x9e, 
    0xf1, 
    0x37, 0x11, 0x80, 
    0xb2, 
    0x82, 
    0xda, 
    0xb1, 
    0x9c, 
    0xdb, 
    0xd7, 
    0xc2, 
    0xb1, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0xb3, 
    0x81, 
    0xdc, 
    0xc3, 
    0xb3, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x81, 
    0xdd, 
    0xf0, 
    0x36, 0x2d, 0x7f, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb3, 
    0x21, 
    0x14, 0x81, 0x27, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x83, 
    0xdd, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_RCMM & 0xff, MP_QSTR_RCMM >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode_0 = {{&mp_type_str}, 59, 23, (const byte*)"\x44\x61\x74\x61\x20\x4d\x61\x72\x6b\x20\x65\x72\x72\x6f\x72\x2e\x20\x4f\x66\x66\x73\x65\x74"};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_PTR(&const_obj_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode_0),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 442,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMd.py, scope IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM
STATIC const byte bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM[41] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_IRdecodeRCMM & 0xff, MP_QSTR_IRdecodeRCMM >> 8,
    MP_QSTR_IRLib_P11_RCMMd_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMd_dot_py >> 8,
    0x8d, 0x09, 0x45, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRdecodeRCMM & 0xff, MP_QSTR_IRdecodeRCMM >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM[2] = {
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM___init__),
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM_decode),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 41,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMd.py, scope IRLib_P11_RCMMd_<module>
STATIC const byte bytecode_data_IRLib_P11_RCMMd__lt_module_gt_[69] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P11_RCMMd_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMd_dot_py >> 8,
    0x61, 0x20, 0x28, 0x28, 0x28, 0x26, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x14, 0x80, 0x50, 
    0x24, MP_QSTR_RCMM_TOLERANCE & 0xff, MP_QSTR_RCMM_TOLERANCE >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRdecodeRCMM & 0xff, MP_QSTR_IRdecodeRCMM >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRdecodeRCMM & 0xff, MP_QSTR_IRdecodeRCMM >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMd__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMd__lt_module_gt__IRdecodeRCMM),
};
const mp_raw_code_t raw_code_IRLib_P11_RCMMd__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMd__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMd__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 69,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMs.py, scope IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__
STATIC const byte bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__[32] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLib_P11_RCMMs_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMs_dot_py >> 8,
    0x81, 0x07, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMs.py, scope IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits
STATIC const byte bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits[155] = {
    0x0a, 0x00, 0x00, 0x03, 0x00, 0x00, 0x15,
    MP_QSTR_sendRCMMBits & 0xff, MP_QSTR_sendRCMMBits >> 8,
    MP_QSTR_IRLib_P11_RCMMs_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMs_dot_py >> 8,
    0x81, 0x09, 0x28, 0x26, 0x29, 0x2a, 0x24, 0x26, 0x2d, 0x26, 0x2d, 0x26, 0x4d, 0x2a, 0x00, 0x00, 0xff,
    0xb1, 
    0x82, 
    0xb2, 
    0xe2, 
    0x81, 
    0xdd, 
    0xd9, 
    0xc1, 
    0xb1, 
    0x9c, 
    0xb2, 
    0xdd, 
    0xda, 
    0xc1, 
    0xb2, 
    0x82, 
    0xdf, 
    0x80, 
    0x35, 0x60, 0x80, 
    0x30, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x81, 0x27, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x9a, 
    0xdb, 
    0xc4, 
    0xb4, 
    0x80, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x82, 0x16, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x30, 0x80, 
    0xb4, 
    0x81, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x83, 0x3c, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x1d, 0x80, 
    0xb4, 
    0x82, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x84, 0x63, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x0a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x86, 0x0a, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x82, 
    0xda, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0x9a, 0x7f, 
    0x32, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_bits),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 155,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMs.py, scope IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send
STATIC const byte bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send[136] = {
    0x09, 0x00, 0x00, 0x04, 0x00, 0x01, 0x15,
    MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    MP_QSTR_IRLib_P11_RCMMs_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMs_dot_py >> 8,
    0x81, 0x18, 0x28, 0x26, 0x22, 0x25, 0x2a, 0x2a, 0x26, 0x2c, 0x22, 0x2c, 0x2a, 0x30, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xa4, 
    0x66, 0x01, 
    0x32, 
    0xb3, 
    0x80, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x8c, 
    0xc3, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x83, 0x21, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x82, 0x16, 
    0x66, 0x01, 
    0x32, 
    0xb3, 
    0x9c, 
    0xf1, 
    0x37, 0x0e, 0x80, 
    0x1c, MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    0x1e, MP_QSTR_sendRCMMBits & 0xff, MP_QSTR_sendRCMMBits >> 8,
    0xb0, 
    0xb2, 
    0x84, 
    0x66, 0x03, 
    0x32, 
    0x9c, 
    0xc3, 
    0x1c, MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    0x1e, MP_QSTR_sendRCMMBits & 0xff, MP_QSTR_sendRCMMBits >> 8,
    0xb0, 
    0xb1, 
    0xb3, 
    0x66, 0x03, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x14, 0x81, 0x27, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x14, 0x81, 0xd9, 0x02, 
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0xdd, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_address),
    MP_ROM_QSTR(MP_QSTR_bits),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 136,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMs.py, scope IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM
STATIC const byte bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM[52] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    MP_QSTR_IRLib_P11_RCMMs_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMs_dot_py >> 8,
    0x6d, 0x60, 0x45, 0x85, 0x0f, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_sendRCMMBits & 0xff, MP_QSTR_sendRCMMBits >> 8,
    0x8c, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x02, 
    0x24, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM[3] = {
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM___init__),
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_sendRCMMBits),
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM_send),
};
STATIC const mp_raw_code_t raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 52,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file IRLib_P11_RCMMs.py, scope IRLib_P11_RCMMs_<module>
STATIC const byte bytecode_data_IRLib_P11_RCMMs__lt_module_gt_[44] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLib_P11_RCMMs_dot_py & 0xff, MP_QSTR_IRLib_P11_RCMMs_dot_py >> 8,
    0x61, 0x20, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    0x1b, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x1d, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_IRsendRCMM & 0xff, MP_QSTR_IRsendRCMM >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLib_P11_RCMMs__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLib_P11_RCMMs__lt_module_gt__IRsendRCMM),
};
const mp_raw_code_t raw_code_IRLib_P11_RCMMs__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLib_P11_RCMMs__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLib_P11_RCMMs__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 44,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__PERCENT_LOW
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__PERCENT_LOW[30] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_PERCENT_LOW & 0xff, MP_QSTR_PERCENT_LOW >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x09, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb0, 
    0x17, 0x01, 
    0x1c, MP_QSTR_PERCENT_TOLERANCE & 0xff, MP_QSTR_PERCENT_TOLERANCE >> 8,
    0xdd, 
    0xde, 
    0x64, 0x01, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_IRLibDecodeBase__lt_module_gt__PERCENT_LOW_0 = {{&mp_type_float}, 1};
#endif
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__PERCENT_LOW[2] = {
    MP_ROM_QSTR(MP_QSTR_us),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_IRLibDecodeBase__lt_module_gt__PERCENT_LOW_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__PERCENT_LOW = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__PERCENT_LOW,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__PERCENT_LOW,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__PERCENT_HIGH
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH[30] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_PERCENT_HIGH & 0xff, MP_QSTR_PERCENT_HIGH >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x0b, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb0, 
    0x17, 0x01, 
    0x1c, MP_QSTR_PERCENT_TOLERANCE & 0xff, MP_QSTR_PERCENT_TOLERANCE >> 8,
    0xdc, 
    0xde, 
    0x64, 0x01, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH_0 = {{&mp_type_float}, 1};
#endif
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH[2] = {
    MP_ROM_QSTR(MP_QSTR_us),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__[31] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x0e, 0x25, 0x00, 0x00, 0xff,
    0x10, 
    0xb0, 
    0x26, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH[36] = {
    0x06, 0x00, 0x00, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x11, 0x00, 0x00, 0xff,
    0xb1, 
    0x1c, MP_QSTR_PERCENT_LOW & 0xff, MP_QSTR_PERCENT_LOW >> 8,
    0xb2, 
    0x64, 0x01, 
    0xf4, 
    0x39, 0x08, 0x80, 
    0xb1, 
    0x1c, MP_QSTR_PERCENT_HIGH & 0xff, MP_QSTR_PERCENT_HIGH >> 8,
    0xb2, 
    0x64, 0x01, 
    0xf3, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_v),
    MP_ROM_QSTR(MP_QSTR_e),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 36,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH[30] = {
    0x07, 0x00, 0x00, 0x04, 0x00, 0x00, 0x09,
    MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x13, 0x00, 0x00, 0xff,
    0xb1, 
    0xb2, 
    0xb3, 
    0xdd, 
    0xf4, 
    0x39, 0x05, 0x80, 
    0xb1, 
    0xb2, 
    0xb3, 
    0xdc, 
    0xf3, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_v),
    MP_ROM_QSTR(MP_QSTR_e),
    MP_ROM_QSTR(MP_QSTR_t),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder[46] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0c,
    MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x15, 0x2a, 0x25, 0x25, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_UNKNOWN & 0xff, MP_QSTR_UNKNOWN >> 8,
    0xb0, 
    0x26, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 46,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults[320] = {
    0x0b, 0x00, 0x00, 0x02, 0x00, 0x01, 0x1d,
    MP_QSTR_dumpResults & 0xff, MP_QSTR_dumpResults >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x1a, 0x1f, 0x38, 0x24, 0x22, 0x1f, 0x29, 0x31, 0x26, 0x1f, 0x41, 0x1f, 0x23, 0x28, 0x2d, 0x28, 0x30, 0x28, 0x29, 0x28, 0x30, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x02, 
    0x1e, MP_QSTR_format & 0xff, MP_QSTR_format >> 8,
    0x1c, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x1d, MP_QSTR_Pnames & 0xff, MP_QSTR_Pnames >> 8,
    0xb0, 
    0x1d, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x21, 
    0x1c, MP_QSTR_repr & 0xff, MP_QSTR_repr >> 8,
    0xb0, 
    0x1d, MP_QSTR_protocolNum & 0xff, MP_QSTR_protocolNum >> 8,
    0x64, 0x01, 
    0x1c, MP_QSTR_hex & 0xff, MP_QSTR_hex >> 8,
    0xb0, 
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x64, 0x01, 
    0x1c, MP_QSTR_hex & 0xff, MP_QSTR_hex >> 8,
    0xb0, 
    0x1d, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0x66, 0x05, 
    0x64, 0x01, 
    0x32, 
    0xb1, 
    0x36, 0x02, 0x80, 
    0x11, 
    0x5b, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x03, 
    0x1e, MP_QSTR_format & 0xff, MP_QSTR_format >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0x66, 0x03, 
    0x64, 0x01, 
    0x32, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x82, 
    0x35, 0x98, 0x80, 
    0x30, 
    0xc2, 
    0xb2, 
    0x82, 
    0xe1, 
    0x37, 0x20, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR_s_brace_open__brace_close_ & 0xff, MP_QSTR_s_brace_open__brace_close_ >> 8,
    0x1e, MP_QSTR_format & 0xff, MP_QSTR_format >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb2, 
    0x21, 
    0x66, 0x01, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x16, MP_QSTR__space_ & 0xff, MP_QSTR__space_ >> 8,
    0x64, 0x82, 0x01, 
    0x32, 
    0x35, 0x22, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR__brace_open__colon_2d_brace_close__colon_m_brace_open__brace_close_ & 0xff, MP_QSTR__brace_open__colon_2d_brace_close__colon_m_brace_open__brace_close_ >> 8,
    0x1e, MP_QSTR_format & 0xff, MP_QSTR_format >> 8,
    0xb2, 
    0x82, 
    0xdf, 
    0x81, 
    0xdd, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb2, 
    0x21, 
    0x66, 0x02, 
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x16, MP_QSTR__space_ & 0xff, MP_QSTR__space_ >> 8,
    0x64, 0x82, 0x01, 
    0x32, 
    0xb2, 
    0x82, 
    0xe1, 
    0x81, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x16, MP_QSTR__0x09_ & 0xff, MP_QSTR__0x09_ >> 8,
    0x64, 0x82, 0x00, 
    0x32, 
    0xb2, 
    0x84, 
    0xe1, 
    0x81, 
    0xf2, 
    0x37, 0x10, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR__0x09_ & 0xff, MP_QSTR__0x09_ >> 8,
    0x16, MP_QSTR_end & 0xff, MP_QSTR_end >> 8,
    0x16, MP_QSTR__space_ & 0xff, MP_QSTR__space_ >> 8,
    0x64, 0x82, 0x01, 
    0x32, 
    0xb2, 
    0x88, 
    0xe1, 
    0x81, 
    0xf2, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR__space_ & 0xff, MP_QSTR__space_ >> 8,
    0x64, 0x01, 
    0x32, 
    0xb2, 
    0xa0, 
    0xe1, 
    0x81, 
    0xf2, 
    0x37, 0x06, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x64, 0x00, 
    0x32, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0x62, 0x7f, 
    0x32, 
    0x32, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x64, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults_0 = {{&mp_type_str}, 50, 44, (const byte*)"\x44\x65\x63\x6f\x64\x65\x64\x20\x7b\x7d\x20\x28\x7b\x7d\x29\x3a\x20\x56\x61\x6c\x75\x65\x3a\x7b\x7d\x20\x41\x64\x72\x73\x3a\x20\x7b\x7d\x20\x28\x7b\x7d\x20\x62\x69\x74\x73\x29"};
STATIC const mp_obj_str_t const_obj_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults_1 = {{&mp_type_str}, 101, 31, (const byte*)"\x52\x61\x77\x20\x73\x61\x6d\x70\x6c\x65\x73\x28\x7b\x7d\x29\x3a\x20\x20\x48\x65\x61\x64\x3a\x20\x6d\x7b\x7d\x20\x73\x7b\x7d"};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_verbose),
    MP_ROM_PTR(&const_obj_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults_0),
    MP_ROM_PTR(&const_obj_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults_1),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 320,
        .n_obj = 2,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric[287] = {
    0x0f, 0x00, 0x00, 0x07, 0x00, 0x00, 0x28,
    MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x2d, 0x27, 0x22, 0x22, 0x2e, 0x24, 0x30, 0x22, 0x27, 0x24, 0x32, 0x22, 0x24, 0x32, 0x22, 0x22, 0x23, 0x32, 0x22, 0x24, 0x32, 0x29, 0x32, 0x47, 0x42, 0x27, 0x28, 0x29, 0x2a, 0x29, 0x25, 0x25, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x66, 0x00, 
    0x32, 
    0x80, 
    0xc7, 
    0x80, 
    0xc8, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0x81, 
    0xdd, 
    0xc9, 
    0xb1, 
    0x37, 0x12, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xb1, 
    0xf5, 
    0x37, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x36, 0x18, 0x80, 
    0xb2, 
    0x37, 0x14, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x80, 
    0x21, 
    0xb2, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xb3, 
    0x37, 0x14, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x81, 
    0x21, 
    0xb3, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x82, 
    0xca, 
    0x35, 0x6a, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xba, 
    0x21, 
    0xb4, 
    0x66, 0x02, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xba, 
    0x81, 
    0xdc, 
    0xca, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xba, 
    0x21, 
    0xb5, 
    0x66, 0x02, 
    0x37, 0x09, 0x80, 
    0xb7, 
    0x81, 
    0xda, 
    0x81, 
    0xd7, 
    0xc7, 
    0x35, 0x1b, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xba, 
    0x21, 
    0xb6, 
    0x66, 0x02, 
    0x37, 0x07, 0x80, 
    0xb7, 
    0x81, 
    0xda, 
    0xc7, 
    0x35, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0xba, 
    0x14, 0x39, 
    0xf1, 
    0x37, 0x11, 0x80, 
    0xb8, 
    0x81, 
    0xda, 
    0xb7, 
    0x9c, 
    0xdb, 
    0xd7, 
    0xc8, 
    0xb7, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc7, 
    0xba, 
    0x81, 
    0xdc, 
    0xca, 
    0xba, 
    0xb9, 
    0xf0, 
    0x36, 0x90, 0x7f, 
    0xba, 
    0x81, 
    0xdd, 
    0x82, 
    0xdf, 
    0xb0, 
    0x26, MP_QSTR_bits & 0xff, MP_QSTR_bits >> 8,
    0xb7, 
    0xb0, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xb8, 
    0xb0, 
    0x26, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0x12, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric[7] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_expectedLength),
    MP_ROM_QSTR(MP_QSTR_headMark),
    MP_ROM_QSTR(MP_QSTR_headSpace),
    MP_ROM_QSTR(MP_QSTR_markData),
    MP_ROM_QSTR(MP_QSTR_spaceOne),
    MP_ROM_QSTR(MP_QSTR_spaceZero),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 7,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 287,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel[221] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1c,
    MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x81, 0x50, 0x33, 0x24, 0x2c, 0x29, 0x47, 0x24, 0x2e, 0x25, 0x30, 0x25, 0x30, 0x25, 0x39, 0x45, 0x24, 0x2a, 0x29, 0x25, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x64, 0x01, 
    0xf4, 
    0x37, 0x04, 0x80, 
    0x1c, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0x5b, 
    0x1c, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1d, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x21, 
    0xc1, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x82, 
    0xe1, 
    0x37, 0x07, 0x80, 
    0x1c, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0xc2, 
    0x35, 0x04, 0x80, 
    0x1c, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0xc2, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0x66, 0x02, 
    0x37, 0x05, 0x80, 
    0x81, 
    0xc3, 
    0x35, 0x4c, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0xb1, 
    0x82, 
    0xb0, 
    0x1d, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0xde, 
    0x66, 0x02, 
    0x37, 0x05, 0x80, 
    0x82, 
    0xc3, 
    0x35, 0x37, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0xb1, 
    0x83, 
    0xb0, 
    0x1d, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0xde, 
    0x66, 0x02, 
    0x37, 0x05, 0x80, 
    0x83, 
    0xc3, 
    0x35, 0x22, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_ignoreHeader & 0xff, MP_QSTR_ignoreHeader >> 8,
    0x37, 0x17, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xf2, 
    0x37, 0x0e, 0x80, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_RCtime & 0xff, MP_QSTR_RCtime >> 8,
    0xf0, 
    0x37, 0x05, 0x80, 
    0x81, 
    0xc3, 
    0x35, 0x04, 0x80, 
    0x1c, MP_QSTR_RCERROR & 0xff, MP_QSTR_RCERROR >> 8,
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0xb0, 
    0x1d, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0xb3, 
    0xf4, 
    0x37, 0x0f, 0x80, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_used & 0xff, MP_QSTR_used >> 8,
    0xb0, 
    0x1d, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_offset & 0xff, MP_QSTR_offset >> 8,
    0xb2, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 221,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase__lt_module_gt__IRLibDecodeBase
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase[78] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12,
    MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x8d, 0x0d, 0x65, 0x45, 0x45, 0x65, 0x40, 0x89, 0x13, 0x85, 0x23, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_MATCH & 0xff, MP_QSTR_MATCH >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_ABS_MATCH & 0xff, MP_QSTR_ABS_MATCH >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR_resetDecoder & 0xff, MP_QSTR_resetDecoder >> 8,
    0x12, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x04, 
    0x24, MP_QSTR_dumpResults & 0xff, MP_QSTR_dumpResults >> 8,
    0x60, 0x05, 
    0x24, MP_QSTR_decodeGeneric & 0xff, MP_QSTR_decodeGeneric >> 8,
    0x60, 0x06, 
    0x24, MP_QSTR_RCLevel & 0xff, MP_QSTR_RCLevel >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase[7] = {
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase___init__),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_MATCH),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_ABS_MATCH),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_resetDecoder),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_dumpResults),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_decodeGeneric),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase_RCLevel),
};
STATIC const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 78,
        .n_obj = 0,
        .n_raw_code = 7,
        #endif
    },
};

// frozen bytecode for file IRLibDecodeBase.py, scope IRLibDecodeBase_<module>
STATIC const byte bytecode_data_IRLibDecodeBase__lt_module_gt_[82] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLibDecodeBase_dot_py & 0xff, MP_QSTR_IRLibDecodeBase_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x24, 0x24, 0x24, 0x45, 0x45, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x99, 
    0x14, 0x80, 0x64, 
    0xe0, 
    0x24, MP_QSTR_PERCENT_TOLERANCE & 0xff, MP_QSTR_PERCENT_TOLERANCE >> 8,
    0x80, 
    0x24, MP_QSTR_RCMARK & 0xff, MP_QSTR_RCMARK >> 8,
    0x81, 
    0x24, MP_QSTR_RCSPACE & 0xff, MP_QSTR_RCSPACE >> 8,
    0x83, 
    0x24, MP_QSTR_RCERROR & 0xff, MP_QSTR_RCERROR >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR_PERCENT_LOW & 0xff, MP_QSTR_PERCENT_LOW >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_PERCENT_HIGH & 0xff, MP_QSTR_PERCENT_HIGH >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibDecodeBase__lt_module_gt_[3] = {
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__PERCENT_LOW),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__PERCENT_HIGH),
    MP_ROM_PTR(&raw_code_IRLibDecodeBase__lt_module_gt__IRLibDecodeBase),
};
const mp_raw_code_t raw_code_IRLibDecodeBase__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibDecodeBase__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLibDecodeBase__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 82,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file IRLibProtocols.py, scope IRLibProtocols_<module>
STATIC const byte bytecode_data_IRLibProtocols__lt_module_gt_[126] = {
    0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLibProtocols_dot_py & 0xff, MP_QSTR_IRLibProtocols_dot_py >> 8,
    0x41, 0x20, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0xff,
    0x80, 
    0x24, MP_QSTR_UNKNOWN & 0xff, MP_QSTR_UNKNOWN >> 8,
    0x81, 
    0x24, MP_QSTR_NEC & 0xff, MP_QSTR_NEC >> 8,
    0x82, 
    0x24, MP_QSTR_SONY & 0xff, MP_QSTR_SONY >> 8,
    0x83, 
    0x24, MP_QSTR_RC5 & 0xff, MP_QSTR_RC5 >> 8,
    0x84, 
    0x24, MP_QSTR_RC6 & 0xff, MP_QSTR_RC6 >> 8,
    0x85, 
    0x24, MP_QSTR_PANASONIC_OLD & 0xff, MP_QSTR_PANASONIC_OLD >> 8,
    0x86, 
    0x24, MP_QSTR_JVC & 0xff, MP_QSTR_JVC >> 8,
    0x87, 
    0x24, MP_QSTR_NECX & 0xff, MP_QSTR_NECX >> 8,
    0x88, 
    0x24, MP_QSTR_SAMSUNG36 & 0xff, MP_QSTR_SAMSUNG36 >> 8,
    0x89, 
    0x24, MP_QSTR_GICABLE & 0xff, MP_QSTR_GICABLE >> 8,
    0x8a, 
    0x24, MP_QSTR_DIRECTV & 0xff, MP_QSTR_DIRECTV >> 8,
    0x8b, 
    0x24, MP_QSTR_RCMM & 0xff, MP_QSTR_RCMM >> 8,
    0x8c, 
    0x24, MP_QSTR_CYKM & 0xff, MP_QSTR_CYKM >> 8,
    0x16, MP_QSTR_UNKNOWN & 0xff, MP_QSTR_UNKNOWN >> 8,
    0x16, MP_QSTR_NEC & 0xff, MP_QSTR_NEC >> 8,
    0x16, MP_QSTR_Sony & 0xff, MP_QSTR_Sony >> 8,
    0x16, MP_QSTR_RC5 & 0xff, MP_QSTR_RC5 >> 8,
    0x16, MP_QSTR_RC6 & 0xff, MP_QSTR_RC6 >> 8,
    0x17, 0x00, 
    0x16, MP_QSTR_JVC & 0xff, MP_QSTR_JVC >> 8,
    0x16, MP_QSTR_NECx & 0xff, MP_QSTR_NECx >> 8,
    0x16, MP_QSTR_Samsung36 & 0xff, MP_QSTR_Samsung36 >> 8,
    0x16, MP_QSTR_G_dot_I_dot_Cable & 0xff, MP_QSTR_G_dot_I_dot_Cable >> 8,
    0x16, MP_QSTR_DirecTV & 0xff, MP_QSTR_DirecTV >> 8,
    0x16, MP_QSTR_rcmm & 0xff, MP_QSTR_rcmm >> 8,
    0x16, MP_QSTR_CYKM & 0xff, MP_QSTR_CYKM >> 8,
    0x51, 0x0d, 
    0x25, MP_QSTR_Pnames & 0xff, MP_QSTR_Pnames >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_IRLibProtocols__lt_module_gt__0 = {{&mp_type_str}, 228, 13, (const byte*)"\x50\x61\x6e\x61\x73\x6f\x6e\x69\x63\x20\x6f\x6c\x64"};
STATIC const mp_rom_obj_t const_table_data_IRLibProtocols__lt_module_gt_[1] = {
    MP_ROM_PTR(&const_obj_IRLibProtocols__lt_module_gt__0),
};
const mp_raw_code_t raw_code_IRLibProtocols__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibProtocols__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLibProtocols__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 126,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase___init__
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase___init__[46] = {
    0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0c,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x09, 0x28, 0x27, 0x25, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x02, 
    0x64, 0x01, 
    0x32, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0xb1, 
    0x64, 0x01, 
    0x32, 
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_outPin & 0xff, MP_QSTR_outPin >> 8,
    0x12, 
    0xb0, 
    0x26, MP_QSTR_longLeadOut & 0xff, MP_QSTR_longLeadOut >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase___init___0 = {{&mp_type_str}, 236, 17, (const byte*)"\x6e\x65\x77\x20\x49\x52\x4c\x69\x62\x53\x65\x6e\x64\x42\x61\x73\x65"};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase___init__[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_outPin),
    MP_ROM_PTR(&const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase___init___0),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase___init__,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 46,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut[111] = {
    0x09, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0e,
    MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x0e, 0x25, 0x3d, 0x30, 0x2c, 0x2f, 0x00, 0x00, 0xff,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0x1c, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x1e, MP_QSTR_PWMOut & 0xff, MP_QSTR_PWMOut >> 8,
    0xb0, 
    0x1d, MP_QSTR_outPin & 0xff, MP_QSTR_outPin >> 8,
    0x16, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0xb1, 
    0x14, 0x87, 0x68, 
    0xde, 
    0x16, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0x66, 0x84, 0x01, 
    0xb0, 
    0x26, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x1c, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x1e, MP_QSTR_PulseOut & 0xff, MP_QSTR_PulseOut >> 8,
    0xb0, 
    0x1d, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR_irSend & 0xff, MP_QSTR_irSend >> 8,
    0x82, 
    0x90, 
    0xe2, 
    0x83, 
    0xdf, 
    0xb0, 
    0x1d, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x1c, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x1e, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x16, MP_QSTR_H & 0xff, MP_QSTR_H >> 8,
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_sleep & 0xff, MP_QSTR_sleep >> 8,
    0x17, 0x02, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut_0 = {{&mp_type_float}, 0.4};
#endif
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_kHz),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbf4cccce),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 111,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_mark
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_mark[80] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0d,
    MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x15, 0x2a, 0x2a, 0x46, 0x55, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x64, 0x01, 
    0xc2, 
    0xb2, 
    0x82, 
    0xe1, 
    0x37, 0x15, 0x80, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0xb2, 
    0x81, 
    0xdd, 
    0x21, 
    0xdc, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0xb2, 
    0x81, 
    0xdd, 
    0x27, 
    0x35, 0x0b, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0xb1, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_mark[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_usec),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_mark = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_mark,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_mark,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 80,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_space
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_space[82] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0d,
    MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x1d, 0x2a, 0x2a, 0x48, 0x55, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0x81, 
    0xdc, 
    0xb0, 
    0x26, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x64, 0x01, 
    0xc2, 
    0xb2, 
    0x82, 
    0xe1, 
    0x80, 
    0xf2, 
    0x37, 0x15, 0x80, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0xb2, 
    0x81, 
    0xdd, 
    0x21, 
    0xdc, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0xb2, 
    0x81, 
    0xdd, 
    0x27, 
    0x35, 0x0b, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0xb1, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_space[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_usec),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_space = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_space,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_space,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 82,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits[114] = {
    0x0d, 0x00, 0x00, 0x07, 0x00, 0x00, 0x11,
    MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x26, 0x28, 0x26, 0x27, 0x2b, 0x28, 0x4b, 0x28, 0x28, 0x00, 0x00, 0xff,
    0xb1, 
    0x82, 
    0xb2, 
    0xe2, 
    0x81, 
    0xdd, 
    0xd9, 
    0xc1, 
    0xb1, 
    0x9c, 
    0xb2, 
    0xdd, 
    0xda, 
    0xc1, 
    0xb2, 
    0x80, 
    0x35, 0x3d, 0x80, 
    0x30, 
    0xc7, 
    0xb1, 
    0x14, 0x80, 0xc0, 0x80, 0x80, 0x00, 
    0xd9, 
    0x37, 0x13, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb3, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x10, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb4, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb6, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x81, 
    0xda, 
    0x14, 0x80, 0xff, 0xff, 0xff, 0x7f, 
    0xd9, 
    0xc1, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xbd, 0x7f, 
    0x32, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits[7] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_data),
    MP_ROM_QSTR(MP_QSTR_numBits),
    MP_ROM_QSTR(MP_QSTR_markOne),
    MP_ROM_QSTR(MP_QSTR_markZero),
    MP_ROM_QSTR(MP_QSTR_spaceOne),
    MP_ROM_QSTR(MP_QSTR_spaceZero),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 7,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 114,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_transmit
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit[75] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x32, 0x2e, 0x28, 0x2b, 0x2a, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_irSend & 0xff, MP_QSTR_irSend >> 8,
    0x1e, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0xb0, 
    0x1d, MP_QSTR_sendBuffer & 0xff, MP_QSTR_sendBuffer >> 8,
    0x66, 0x01, 
    0x32, 
    0x80, 
    0xb0, 
    0x1d, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_sleep & 0xff, MP_QSTR_sleep >> 8,
    0x17, 0x01, 
    0x66, 0x01, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR_irSend & 0xff, MP_QSTR_irSend >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit_0 = {{&mp_type_float}, 0.5};
#endif
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbf800002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 75,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric[156] = {
    0x15, 0x00, 0x00, 0x0d, 0x00, 0x01, 0x18,
    MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x81, 0x39, 0x28, 0x24, 0x28, 0x24, 0x28, 0x26, 0x2f, 0x22, 0x2d, 0x24, 0x28, 0x24, 0x50, 0x28, 0x28, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0xba, 
    0x66, 0x01, 
    0x32, 
    0xb4, 
    0x37, 0x08, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb4, 
    0x66, 0x01, 
    0x32, 
    0xb5, 
    0x37, 0x08, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb5, 
    0x66, 0x01, 
    0x32, 
    0xb3, 
    0x9c, 
    0xf1, 
    0x37, 0x11, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0xb2, 
    0xb3, 
    0x9c, 
    0xdd, 
    0xb6, 
    0xb7, 
    0xb8, 
    0xb9, 
    0x66, 0x06, 
    0x32, 
    0x9c, 
    0xc3, 
    0xb0, 
    0x1e, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0xb1, 
    0xb3, 
    0xb6, 
    0xb7, 
    0xb8, 
    0xb9, 
    0x66, 0x06, 
    0x32, 
    0xbb, 
    0x37, 0x08, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0xb6, 
    0x66, 0x01, 
    0x32, 
    0xbc, 
    0x37, 0x10, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xbc, 
    0xb0, 
    0x1d, MP_QSTR_extent & 0xff, MP_QSTR_extent >> 8,
    0xdd, 
    0x66, 0x01, 
    0x32, 
    0x35, 0x08, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0xb8, 
    0x66, 0x01, 
    0x32, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x17, 0x0d, 
    0x64, 0x01, 
    0x32, 
    0xb0, 
    0x1e, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric_0 = {{&mp_type_str}, 214, 34, (const byte*)"\x54\x72\x61\x6e\x73\x6d\x69\x74\x74\x69\x6e\x67\x20\x66\x72\x6f\x6d\x20\x49\x52\x4c\x69\x62\x53\x65\x6e\x64\x42\x61\x73\x65\x2e\x2e\x2e"};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric[14] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
    MP_ROM_QSTR(MP_QSTR_address),
    MP_ROM_QSTR(MP_QSTR_numBits),
    MP_ROM_QSTR(MP_QSTR_headMark),
    MP_ROM_QSTR(MP_QSTR_headSpace),
    MP_ROM_QSTR(MP_QSTR_markOne),
    MP_ROM_QSTR(MP_QSTR_markZero),
    MP_ROM_QSTR(MP_QSTR_spaceOne),
    MP_ROM_QSTR(MP_QSTR_spaceZero),
    MP_ROM_QSTR(MP_QSTR_kHz),
    MP_ROM_QSTR(MP_QSTR_useStop),
    MP_ROM_QSTR(MP_QSTR_maxExtent),
    MP_ROM_PTR(&const_obj_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric_0),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 13,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 156,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase__lt_module_gt__IRLibSendBase
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase[81] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15,
    MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x8d, 0x08, 0x65, 0x40, 0x85, 0x07, 0x85, 0x08, 0x85, 0x08, 0x85, 0x0c, 0x85, 0x07, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_enableIROut & 0xff, MP_QSTR_enableIROut >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_mark & 0xff, MP_QSTR_mark >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR_space & 0xff, MP_QSTR_space >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR_sendBits & 0xff, MP_QSTR_sendBits >> 8,
    0x60, 0x05, 
    0x24, MP_QSTR_transmit & 0xff, MP_QSTR_transmit >> 8,
    0x80, 
    0x50, 0x01, 
    0x18, 
    0x61, 0x06, 
    0x24, MP_QSTR_sendGeneric & 0xff, MP_QSTR_sendGeneric >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase[7] = {
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase___init__),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_enableIROut),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_mark),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_space),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_sendBits),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_transmit),
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase_sendGeneric),
};
STATIC const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt__IRLibSendBase,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt__IRLibSendBase,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 81,
        .n_obj = 0,
        .n_raw_code = 7,
        #endif
    },
};

// frozen bytecode for file IRLibSendBase.py, scope IRLibSendBase_<module>
STATIC const byte bytecode_data_IRLibSendBase__lt_module_gt_[73] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRLibSendBase_dot_py & 0xff, MP_QSTR_IRLibSendBase_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x24, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x24, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x24, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x24, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x24, MP_QSTR_IRLibProtocols & 0xff, MP_QSTR_IRLibProtocols >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_IRLibSendBase & 0xff, MP_QSTR_IRLibSendBase >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRLibSendBase__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRLibSendBase__lt_module_gt__IRLibSendBase),
};
const mp_raw_code_t raw_code_IRLibSendBase__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRLibSendBase__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRLibSendBase__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 73,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file IRrecvPCI.py, scope IRrecvPCI__lt_module_gt__IRrecvPCI___init__
STATIC const byte bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI___init__[30] = {
    0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0a,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_IRrecvPCI_dot_py & 0xff, MP_QSTR_IRrecvPCI_dot_py >> 8,
    0x81, 0x09, 0x25, 0x00, 0x00, 0xff,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR_recvPin & 0xff, MP_QSTR_recvPin >> 8,
    0x14, 0x32, 
    0xb0, 
    0x26, MP_QSTR_markExcess & 0xff, MP_QSTR_markExcess >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI___init__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI___init__,
        .const_table = (mp_uint_t*)const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRrecvPCI.py, scope IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn
STATIC const byte bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn[51] = {
    0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_enableIRIn & 0xff, MP_QSTR_enableIRIn >> 8,
    MP_QSTR_IRrecvPCI_dot_py & 0xff, MP_QSTR_IRrecvPCI_dot_py >> 8,
    0x81, 0x0d, 0x3b, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x1e, MP_QSTR_PulseIn & 0xff, MP_QSTR_PulseIn >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvPin & 0xff, MP_QSTR_recvPin >> 8,
    0x16, MP_QSTR_maxlen & 0xff, MP_QSTR_maxlen >> 8,
    0x14, 0x81, 0x16, 
    0x16, MP_QSTR_idle_state & 0xff, MP_QSTR_idle_state >> 8,
    0x12, 
    0x66, 0x84, 0x01, 
    0xb0, 
    0x26, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_prevLength & 0xff, MP_QSTR_prevLength >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn,
        .const_table = (mp_uint_t*)const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 51,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRrecvPCI.py, scope IRrecvPCI__lt_module_gt__IRrecvPCI_getResults
STATIC const byte bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults[234] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1d,
    MP_QSTR_getResults & 0xff, MP_QSTR_getResults >> 8,
    MP_QSTR_IRrecvPCI_dot_py & 0xff, MP_QSTR_IRrecvPCI_dot_py >> 8,
    0x81, 0x11, 0x20, 0x2c, 0x42, 0x31, 0x2d, 0x2c, 0x62, 0x40, 0x33, 0x2a, 0x2e, 0x2f, 0x4e, 0x23, 0x2c, 0x1f, 0x61, 0x25, 0x2a, 0x62, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x64, 0x01, 
    0x36, 0x02, 0x80, 
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_prevLength & 0xff, MP_QSTR_prevLength >> 8,
    0xf1, 
    0x37, 0x1b, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR_prevLength & 0xff, MP_QSTR_prevLength >> 8,
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_monotonic & 0xff, MP_QSTR_monotonic >> 8,
    0x66, 0x00, 
    0xb0, 
    0x26, MP_QSTR_lastTime & 0xff, MP_QSTR_lastTime >> 8,
    0x10, 
    0x5b, 
    0x1c, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x1e, MP_QSTR_monotonic & 0xff, MP_QSTR_monotonic >> 8,
    0x66, 0x00, 
    0xb0, 
    0x1d, MP_QSTR_lastTime & 0xff, MP_QSTR_lastTime >> 8,
    0xdd, 
    0x17, 0x01, 
    0xf1, 
    0x37, 0x75, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x1e, MP_QSTR_pause & 0xff, MP_QSTR_pause >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x1e, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x16, MP_QSTR_H & 0xff, MP_QSTR_H >> 8,
    0x66, 0x01, 
    0x25, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x64, 0x01, 
    0x80, 
    0x35, 0x37, 0x80, 
    0x30, 
    0xc1, 
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0xb1, 
    0x21, 
    0x14, 0x80, 0xce, 0x10, 
    0xf1, 
    0x37, 0x03, 0x80, 
    0x35, 0x2a, 0x80, 
    0x1c, MP_QSTR_decodeBuffer & 0xff, MP_QSTR_decodeBuffer >> 8,
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0xb1, 
    0x21, 
    0xb1, 
    0x82, 
    0xe1, 
    0x37, 0x07, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_markExcess & 0xff, MP_QSTR_markExcess >> 8,
    0x35, 0x05, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_markExcess & 0xff, MP_QSTR_markExcess >> 8,
    0xd4, 
    0xdc, 
    0x66, 0x01, 
    0x32, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xc3, 0x7f, 
    0x32, 
    0x32, 
    0x80, 
    0xb0, 
    0x26, MP_QSTR_prevLength & 0xff, MP_QSTR_prevLength >> 8,
    0xb0, 
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0x12, 
    0x5b, 
    0x10, 
    0x5b, 
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults_0 = {{&mp_type_float}, 0.5};
#endif
STATIC const mp_rom_obj_t const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbf800002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults,
        .const_table = (mp_uint_t*)const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 234,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file IRrecvPCI.py, scope IRrecvPCI__lt_module_gt__IRrecvPCI
STATIC const byte bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI[49] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    MP_QSTR_IRrecvPCI_dot_py & 0xff, MP_QSTR_IRrecvPCI_dot_py >> 8,
    0x8d, 0x08, 0x65, 0x20, 0x65, 0x20, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_enableIRIn & 0xff, MP_QSTR_enableIRIn >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_getResults & 0xff, MP_QSTR_getResults >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI[3] = {
    MP_ROM_PTR(&raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI___init__),
    MP_ROM_PTR(&raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI_enableIRIn),
    MP_ROM_PTR(&raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI_getResults),
};
STATIC const mp_raw_code_t raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRrecvPCI__lt_module_gt__IRrecvPCI,
        .const_table = (mp_uint_t*)const_table_data_IRrecvPCI__lt_module_gt__IRrecvPCI,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 49,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file IRrecvPCI.py, scope IRrecvPCI_<module>
STATIC const byte bytecode_data_IRrecvPCI__lt_module_gt_[64] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_IRrecvPCI_dot_py & 0xff, MP_QSTR_IRrecvPCI_dot_py >> 8,
    0x41, 0x28, 0x28, 0x28, 0x48, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x24, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x24, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x24, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x24, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x20, 
    0x60, 0x00, 
    0x16, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_IRrecvPCI__lt_module_gt_[1] = {
    MP_ROM_PTR(&raw_code_IRrecvPCI__lt_module_gt__IRrecvPCI),
};
const mp_raw_code_t raw_code_IRrecvPCI__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_IRrecvPCI__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_IRrecvPCI__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 64,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor___init__
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor___init__[29] = {
    0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0a,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x33, 0x25, 0x00, 0x00, 0xff,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor___init__[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_positive_pwm),
    MP_ROM_QSTR(MP_QSTR_negative_pwm),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor___init__,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 29,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor_throttle
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor_throttle[165] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x13,
    MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x38, 0x60, 0x38, 0x22, 0x3e, 0x27, 0x38, 0x29, 0x39, 0x2c, 0x24, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xf2, 
    0x37, 0x0e, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xf2, 
    0x37, 0x02, 0x80, 
    0x11, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x14, 0x83, 0xff, 0x7f, 
    0xf2, 
    0x37, 0x16, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x14, 0x83, 0xff, 0x7f, 
    0xf2, 
    0x37, 0x07, 0x80, 
    0x1c, MP_QSTR_float & 0xff, MP_QSTR_float >> 8,
    0x80, 
    0x64, 0x01, 
    0x5b, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xf1, 
    0x37, 0x15, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xf1, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_RuntimeError & 0xff, MP_QSTR_RuntimeError >> 8,
    0x17, 0x01, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x1c, MP_QSTR_max & 0xff, MP_QSTR_max >> 8,
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x64, 0x02, 
    0x14, 0x83, 0xff, 0x7f, 
    0xe0, 
    0xc1, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xf1, 
    0x37, 0x04, 0x80, 
    0x7f, 
    0xb1, 
    0xde, 
    0x5b, 
    0xb1, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_motor__lt_module_gt__DCMotor_throttle_0 = {{&mp_type_str}, 29, 21, (const byte*)"\x50\x57\x4d\x73\x20\x69\x6e\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x74\x61\x74\x65"};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor_throttle[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__DCMotor_throttle_0),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor_throttle = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor_throttle,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor_throttle,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 165,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor_throttle
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor_throttle2[176] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x16,
    MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x48, 0x36, 0x29, 0x26, 0x28, 0x2b, 0x26, 0x2b, 0x4e, 0x31, 0x26, 0x28, 0x4b, 0x28, 0x00, 0x00, 0xff,
    0xb1, 
    0x11, 
    0xf7, 
    0xd6, 
    0x37, 0x18, 0x80, 
    0xb1, 
    0x17, 0x02, 
    0xf1, 
    0x36, 0x08, 0x80, 
    0xb1, 
    0x17, 0x03, 
    0xd4, 
    0xf0, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x04, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb1, 
    0x11, 
    0xf7, 
    0x37, 0x13, 0x80, 
    0x80, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x35, 0x59, 0x80, 
    0xb1, 
    0x80, 
    0xf2, 
    0x37, 0x19, 0x80, 
    0x14, 0x83, 0xff, 0x7f, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x14, 0x83, 0xff, 0x7f, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x35, 0x3a, 0x80, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0x14, 0x83, 0xff, 0x7f, 
    0x1c, MP_QSTR_abs & 0xff, MP_QSTR_abs >> 8,
    0xb1, 
    0x64, 0x01, 
    0xde, 
    0x64, 0x01, 
    0xc2, 
    0xb1, 
    0x80, 
    0xf0, 
    0x37, 0x13, 0x80, 
    0x80, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0xb2, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x35, 0x10, 0x80, 
    0xb2, 
    0xb0, 
    0x1d, MP_QSTR__positive & 0xff, MP_QSTR__positive >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x80, 
    0xb0, 
    0x1d, MP_QSTR__negative & 0xff, MP_QSTR__negative >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_motor__lt_module_gt__DCMotor_throttle2_0 = {{&mp_type_float}, 1};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_motor__lt_module_gt__DCMotor_throttle2_1 = {{&mp_type_float}, 1};
#endif
STATIC const mp_obj_str_t const_obj_motor__lt_module_gt__DCMotor_throttle2_2 = {{&mp_type_str}, 238, 45, (const byte*)"\x54\x68\x72\x6f\x74\x74\x6c\x65\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x4e\x6f\x6e\x65\x20\x6f\x72\x20\x62\x65\x74\x77\x65\x65\x6e\x20\x2d\x31\x2e\x30\x20\x61\x6e\x64\x20\x31\x2e\x30"};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor_throttle2[5] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__DCMotor_throttle2_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__DCMotor_throttle2_1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__DCMotor_throttle2_2),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor_throttle2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor_throttle2,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor_throttle2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 176,
        .n_obj = 3,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor___enter__
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor___enter__[18] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x5a, 0x00, 0x00, 0xff,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor___enter__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor___enter__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor___enter__,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor___enter__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 18,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor___exit__
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor___exit__[23] = {
    0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x09,
    MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x5d, 0x00, 0x00, 0xff,
    0x11, 
    0xb0, 
    0x26, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor___exit__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_exception_type),
    MP_ROM_QSTR(MP_QSTR_exception_value),
    MP_ROM_QSTR(MP_QSTR_traceback),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor___exit__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor___exit__,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor___exit__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor_deinit
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor_deinit[24] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x60, 0x20, 0x00, 0x00, 0xff,
    0x11, 
    0xb0, 
    0x26, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor_deinit[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor_deinit = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor_deinit,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor_deinit,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 24,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor__lt_module_gt__DCMotor
STATIC const byte bytecode_data_motor__lt_module_gt__DCMotor[83] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
    MP_QSTR_DCMotor & 0xff, MP_QSTR_DCMotor >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x8d, 0x2b, 0x80, 0x07, 0x65, 0x20, 0x8a, 0x10, 0x8d, 0x13, 0x65, 0x65, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_DCMotor & 0xff, MP_QSTR_DCMotor >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x1b, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x02, 
    0x64, 0x01, 
    0x24, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    0x60, 0x05, 
    0x24, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt__DCMotor[6] = {
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor___init__),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor_throttle),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor_throttle2),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor___enter__),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor___exit__),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor_deinit),
};
STATIC const mp_raw_code_t raw_code_motor__lt_module_gt__DCMotor = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt__DCMotor,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt__DCMotor,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 83,
        .n_obj = 0,
        .n_raw_code = 6,
        #endif
    },
};

// frozen bytecode for file motor.py, scope motor_<module>
STATIC const byte bytecode_data_motor__lt_module_gt_[43] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_motor_dot_py & 0xff, MP_QSTR_motor_dot_py >> 8,
    0x81, 0x15, 0x80, 0x12, 0x25, 0x45, 0x00, 0x00, 0xff,
    0x17, 0x00, 
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x01, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR_DCMotor & 0xff, MP_QSTR_DCMotor >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_DCMotor & 0xff, MP_QSTR_DCMotor >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_motor__lt_module_gt__0 = {{&mp_type_str}, 151, 28, (const byte*)"\x32\x2e\x32\x2e\x35\x2d\x61\x6c\x70\x68\x61\x2e\x30\x2e\x70\x6c\x75\x73\x2e\x32\x2b\x63\x66\x63\x62\x62\x33\x36"};
STATIC const mp_obj_str_t const_obj_motor__lt_module_gt__1 = {{&mp_type_str}, 38, 60, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x4d\x6f\x74\x6f\x72\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_motor__lt_module_gt_[3] = {
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__0),
    MP_ROM_PTR(&const_obj_motor__lt_module_gt__1),
    MP_ROM_PTR(&raw_code_motor__lt_module_gt__DCMotor),
};
const mp_raw_code_t raw_code_motor__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_motor__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_motor__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 43,
        .n_obj = 2,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___init__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___init__[85] = {
    0x09, 0x00, 0x08, 0x03, 0x03, 0x00, 0x0f,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x50, 0x2d, 0x30, 0x25, 0x25, 0x2c, 0x25, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0xb1, 
    0x66, 0x01, 
    0xb0, 
    0x26, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Direction & 0xff, MP_QSTR_Direction >> 8,
    0x1d, MP_QSTR_OUTPUT & 0xff, MP_QSTR_OUTPUT >> 8,
    0xb0, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x26, MP_QSTR_direction & 0xff, MP_QSTR_direction >> 8,
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_n & 0xff, MP_QSTR_n >> 8,
    0xb3, 
    0xb0, 
    0x26, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x1c, MP_QSTR_bytearray & 0xff, MP_QSTR_bytearray >> 8,
    0xb2, 
    0xb3, 
    0xde, 
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb4, 
    0xb0, 
    0x26, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0xb5, 
    0xb0, 
    0x26, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___init__[6] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pin),
    MP_ROM_QSTR(MP_QSTR_n),
    MP_ROM_QSTR(MP_QSTR_bpp),
    MP_ROM_QSTR(MP_QSTR_brightness),
    MP_ROM_QSTR(MP_QSTR_auto_write),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___init__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 85,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_deinit
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_deinit[78] = {
    0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x59, 0x20, 0x2f, 0x31, 0x2e, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x01, 
    0x80, 
    0x35, 0x0b, 0x80, 
    0x30, 
    0xc1, 
    0x80, 
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb1, 
    0x27, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xef, 0x7f, 
    0x32, 
    0x32, 
    0x1c, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0xb0, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x02, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_deinit[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_deinit = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_deinit,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_deinit,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 78,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___enter__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___enter__[18] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x60, 0x00, 0x00, 0xff,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___enter__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___enter__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___enter__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___enter__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 18,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___exit__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___exit__[25] = {
    0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x09,
    MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x63, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___exit__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_exception_type),
    MP_ROM_QSTR(MP_QSTR_exception_value),
    MP_ROM_QSTR(MP_QSTR_traceback),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___exit__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___exit__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___exit__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 25,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___repr___<listcomp>
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_[36] = {
    0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR__lt_listcomp_gt_ & 0xff, MP_QSTR__lt_listcomp_gt_ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x89, 0x66, 0x00, 0x00, 0xff,
    0x51, 0x00, 
    0xb0, 
    0x47, 
    0x43, 0x0c, 0x00, 
    0xc1, 
    0x1c, MP_QSTR_str & 0xff, MP_QSTR_str >> 8,
    0xb1, 
    0x64, 0x01, 
    0x57, 0x14, 
    0x35, 0xf1, 0x7f, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_[1] = {
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 36,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___repr__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___repr__[38] = {
    0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___repr__ & 0xff, MP_QSTR___repr__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x66, 0x00, 0x00, 0xff,
    0x16, MP_QSTR__bracket_open_ & 0xff, MP_QSTR__bracket_open_ >> 8,
    0x16, MP_QSTR__comma__space_ & 0xff, MP_QSTR__comma__space_ >> 8,
    0x1e, MP_QSTR_join & 0xff, MP_QSTR_join >> 8,
    0x60, 0x01, 
    0xb0, 
    0x64, 0x01, 
    0x66, 0x01, 
    0xdc, 
    0x16, MP_QSTR__bracket_close_ & 0xff, MP_QSTR__bracket_close_ >> 8,
    0xdc, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___repr__[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___repr____lt_listcomp_gt_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___repr__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___repr__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___repr__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 38,
        .n_obj = 0,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel__set_item
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel__set_item[266] = {
    0x0d, 0x00, 0x00, 0x03, 0x00, 0x00, 0x24,
    MP_QSTR__set_item & 0xff, MP_QSTR__set_item >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x69, 0x26, 0x29, 0x2f, 0x25, 0x27, 0x22, 0x22, 0x22, 0x22, 0x2c, 0x24, 0x28, 0x26, 0x62, 0x35, 0x22, 0x22, 0x22, 0x25, 0x2e, 0x29, 0x49, 0x2a, 0x2e, 0x2e, 0x2e, 0x29, 0x00, 0x00, 0xff,
    0xb1, 
    0x80, 
    0xf0, 
    0x37, 0x09, 0x80, 
    0xb1, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x64, 0x01, 
    0xe9, 
    0xc1, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_n & 0xff, MP_QSTR_n >> 8,
    0xf4, 
    0x36, 0x06, 0x80, 
    0xb1, 
    0x80, 
    0xf0, 
    0x37, 0x05, 0x80, 
    0x1c, MP_QSTR_IndexError & 0xff, MP_QSTR_IndexError >> 8,
    0x5c, 0x01, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xde, 
    0xc3, 
    0x80, 
    0xc4, 
    0x80, 
    0xc5, 
    0x80, 
    0xc6, 
    0x80, 
    0xc7, 
    0x1c, MP_QSTR_isinstance & 0xff, MP_QSTR_isinstance >> 8,
    0xb2, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0x64, 0x02, 
    0x37, 0x34, 0x80, 
    0xb2, 
    0x90, 
    0xdb, 
    0xc4, 
    0xb2, 
    0x88, 
    0xdb, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xc5, 
    0xb2, 
    0x14, 0x81, 0x7f, 
    0xd9, 
    0xc6, 
    0x80, 
    0xc7, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x84, 
    0xf2, 
    0x37, 0x14, 0x80, 
    0xb4, 
    0xb5, 
    0xf2, 
    0x37, 0x0e, 0x80, 
    0xb5, 
    0xb6, 
    0xf2, 
    0x37, 0x08, 0x80, 
    0xb4, 
    0xc7, 
    0x80, 
    0xc4, 
    0x80, 
    0xc5, 
    0x80, 
    0xc6, 
    0x35, 0x2a, 0x80, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb2, 
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xf2, 
    0x37, 0x1c, 0x80, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x83, 
    0xf2, 
    0x37, 0x09, 0x80, 
    0xb2, 
    0x59, 0x03, 
    0xc4, 
    0xc5, 
    0xc6, 
    0x35, 0x07, 0x80, 
    0xb2, 
    0x59, 0x04, 
    0xc4, 
    0xc5, 
    0xc6, 
    0xc7, 
    0x35, 0x00, 0x80, 
    0xb4, 
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb3, 
    0xb0, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0x80, 
    0x21, 
    0xdc, 
    0x27, 
    0xb5, 
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb3, 
    0xb0, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0x81, 
    0x21, 
    0xdc, 
    0x27, 
    0xb6, 
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb3, 
    0xb0, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0x82, 
    0x21, 
    0xdc, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x84, 
    0xf2, 
    0x37, 0x0e, 0x80, 
    0xb7, 
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0xb3, 
    0xb0, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0x83, 
    0x21, 
    0xdc, 
    0x27, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel__set_item[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_index),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel__set_item = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel__set_item,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel__set_item,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 266,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___setitem__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___setitem__[169] = {
    0x12, 0x00, 0x00, 0x03, 0x00, 0x00, 0x14,
    MP_QSTR___setitem__ & 0xff, MP_QSTR___setitem__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x8a, 0x2c, 0x39, 0x24, 0x26, 0x2c, 0x2b, 0x29, 0x35, 0x51, 0x49, 0x27, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_isinstance & 0xff, MP_QSTR_isinstance >> 8,
    0xb1, 
    0x1c, MP_QSTR_slice & 0xff, MP_QSTR_slice >> 8,
    0x64, 0x02, 
    0x37, 0x69, 0x80, 
    0xb1, 
    0x1e, MP_QSTR_indices & 0xff, MP_QSTR_indices >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xdf, 
    0x66, 0x01, 
    0x59, 0x03, 
    0xc3, 
    0xc4, 
    0xc5, 
    0xb4, 
    0xb3, 
    0xdd, 
    0xc6, 
    0xb5, 
    0x80, 
    0xf5, 
    0x37, 0x0c, 0x80, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_ceil & 0xff, MP_QSTR_ceil >> 8,
    0xb6, 
    0xb5, 
    0xe0, 
    0x66, 0x01, 
    0xc6, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb2, 
    0x64, 0x01, 
    0xb6, 
    0xf5, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x03, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x1c, MP_QSTR_enumerate & 0xff, MP_QSTR_enumerate >> 8,
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0xb3, 
    0xb4, 
    0xb5, 
    0x64, 0x03, 
    0x64, 0x01, 
    0x47, 
    0x43, 0x12, 0x00, 
    0x59, 0x02, 
    0xc7, 
    0xc8, 
    0xb0, 
    0x1e, MP_QSTR__set_item & 0xff, MP_QSTR__set_item >> 8,
    0xb8, 
    0xb2, 
    0xb7, 
    0x21, 
    0x66, 0x02, 
    0x32, 
    0x35, 0xeb, 0x7f, 
    0x35, 0x09, 0x80, 
    0xb0, 
    0x1e, MP_QSTR__set_item & 0xff, MP_QSTR__set_item >> 8,
    0xb1, 
    0xb2, 
    0x66, 0x02, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x37, 0x07, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_neopixel__lt_module_gt__NeoPixel___setitem___0 = {{&mp_type_str}, 177, 43, (const byte*)"\x53\x6c\x69\x63\x65\x20\x61\x6e\x64\x20\x69\x6e\x70\x75\x74\x20\x73\x65\x71\x75\x65\x6e\x63\x65\x20\x73\x69\x7a\x65\x20\x64\x6f\x20\x6e\x6f\x74\x20\x6d\x61\x74\x63\x68\x2e"};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___setitem__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_index),
    MP_ROM_QSTR(MP_QSTR_val),
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__NeoPixel___setitem___0),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___setitem__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___setitem__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___setitem__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 169,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___getitem___<genexpr>
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_[53] = {
    0x0c, 0x00, 0x04, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR__lt_genexpr_gt_ & 0xff, MP_QSTR__lt_genexpr_gt_ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x89, 0x9d, 0x00, 0x00, 0xff,
    0x18, 
    0xb2, 
    0x18, 
    0x18, 
    0x43, 0x1c, 0x00, 
    0xc3, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x1a, 0x01, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xde, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0xb3, 
    0x21, 
    0xdc, 
    0x21, 
    0x5d, 
    0x32, 
    0x35, 0xe1, 0x7f, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_[3] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x04,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 53,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___getitem___<genexpr>
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2[47] = {
    0x0c, 0x00, 0x04, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR__lt_genexpr_gt_ & 0xff, MP_QSTR__lt_genexpr_gt_ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x89, 0xa5, 0x00, 0x00, 0xff,
    0x18, 
    0xb2, 
    0x18, 
    0x18, 
    0x43, 0x16, 0x00, 
    0xc3, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x1a, 0x01, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0xb3, 
    0x21, 
    0xdc, 
    0x21, 
    0x5d, 
    0x32, 
    0x35, 0xe7, 0x7f, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2[3] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x04,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 47,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___getitem__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem__[186] = {
    0x0f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x16,
    MP_QSTR___getitem__ & 0xff, MP_QSTR___getitem__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x84, 0x9a, 0x2c, 0x23, 0x1f, 0x23, 0x2c, 0x35, 0x22, 0x26, 0x2a, 0x30, 0x25, 0x29, 0x28, 0x00, 0x00, 0x00, 0x03, 0x04, 0xff,
    0x1c, MP_QSTR_isinstance & 0xff, MP_QSTR_isinstance >> 8,
    0xb1, 
    0x1c, MP_QSTR_slice & 0xff, MP_QSTR_slice >> 8,
    0x64, 0x02, 
    0x37, 0x48, 0x80, 
    0x51, 0x00, 
    0xc2, 
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0xb1, 
    0x1e, MP_QSTR_indices & 0xff, MP_QSTR_indices >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x01, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xdf, 
    0x66, 0x01, 
    0x18, 
    0x65, 0x00, 
    0x47, 
    0x43, 0x23, 0x00, 
    0x23, 0x03, 
    0xb2, 
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0x1c, MP_QSTR_tuple & 0xff, MP_QSTR_tuple >> 8,
    0xb0, 
    0xb3, 
    0x62, 0x02, 0x02, 
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x64, 0x01, 
    0x42, 
    0x64, 0x01, 
    0x64, 0x01, 
    0x66, 0x01, 
    0x32, 
    0x35, 0xda, 0x7f, 
    0xb2, 
    0x5b, 
    0xb1, 
    0x80, 
    0xf0, 
    0x37, 0x0a, 0x80, 
    0xb1, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1a, 0x00, 
    0x64, 0x01, 
    0xe9, 
    0xc1, 
    0xb1, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_n & 0xff, MP_QSTR_n >> 8,
    0xf4, 
    0x36, 0x06, 0x80, 
    0xb1, 
    0x80, 
    0xf0, 
    0x37, 0x05, 0x80, 
    0x1c, MP_QSTR_IndexError & 0xff, MP_QSTR_IndexError >> 8,
    0x5c, 0x01, 
    0xb1, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xde, 
    0x23, 0x04, 
    0x1c, MP_QSTR_tuple & 0xff, MP_QSTR_tuple >> 8,
    0xb0, 
    0xb4, 
    0x62, 0x03, 0x02, 
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x64, 0x01, 
    0x42, 
    0x64, 0x01, 
    0x64, 0x01, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___getitem__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_index),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___getitem____lt_genexpr_gt_2),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___getitem__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___getitem__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___getitem__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 186,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel___len__
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel___len__[31] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___len__ & 0xff, MP_QSTR___len__ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0xa9, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x01, 
    0xb0, 
    0x1d, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0xdf, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel___len__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel___len__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel___len__,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel___len__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_brightness
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_brightness[22] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0xad, 0x20, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__brightness & 0xff, MP_QSTR__brightness >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_brightness[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_brightness = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_brightness,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_brightness,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 22,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_brightness
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_brightness2[37] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0xb3, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_min & 0xff, MP_QSTR_min >> 8,
    0x1c, MP_QSTR_max & 0xff, MP_QSTR_max >> 8,
    0xb1, 
    0x17, 0x02, 
    0x64, 0x02, 
    0x17, 0x03, 
    0x64, 0x02, 
    0xb0, 
    0x26, MP_QSTR__brightness & 0xff, MP_QSTR__brightness >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_neopixel__lt_module_gt__NeoPixel_brightness2_0 = {{&mp_type_float}, 0};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_neopixel__lt_module_gt__NeoPixel_brightness2_1 = {{&mp_type_float}, 1};
#endif
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_brightness2[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_brightness),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__NeoPixel_brightness2_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0x80800002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__NeoPixel_brightness2_1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_brightness2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_brightness2,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_brightness2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 37,
        .n_obj = 2,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_fill
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_fill[72] = {
    0x0c, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10,
    MP_QSTR_fill & 0xff, MP_QSTR_fill >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0xb6, 0x20, 0x25, 0x25, 0x2e, 0x27, 0x24, 0x27, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0xc2, 
    0x10, 
    0xb0, 
    0x26, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x1c, MP_QSTR_enumerate & 0xff, MP_QSTR_enumerate >> 8,
    0xb0, 
    0x64, 0x01, 
    0x47, 
    0x43, 0x0b, 0x00, 
    0x59, 0x02, 
    0xc3, 
    0xc4, 
    0xb1, 
    0xb0, 
    0xb3, 
    0x27, 
    0x35, 0xf2, 0x7f, 
    0xb2, 
    0x37, 0x07, 0x80, 
    0xb0, 
    0x1e, MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    0x66, 0x00, 
    0x32, 
    0xb2, 
    0xb0, 
    0x26, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_fill[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_color),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_fill = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_fill,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_fill,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 72,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_write
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_write[26] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0xc0, 0x60, 0x00, 0x00, 0xff,
    0xb0, 
    0x1e, MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_write[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_write = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_write,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_write,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_show_<listcomp>
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_[42] = {
    0x0b, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR__lt_listcomp_gt_ & 0xff, MP_QSTR__lt_listcomp_gt_ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x89, 0xce, 0x00, 0x00, 0xff,
    0x51, 0x00, 
    0xb1, 
    0x47, 
    0x43, 0x12, 0x00, 
    0xc2, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb2, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0xde, 
    0x64, 0x01, 
    0x57, 0x14, 
    0x35, 0xeb, 0x7f, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_[2] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 42,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel_show
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel_show[80] = {
    0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0d,
    MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x82, 0xc6, 0x60, 0x40, 0x2b, 0x53, 0x00, 0x00, 0x00, 0xff,
    0x1a, 0x00, 
    0x1d, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x17, 0x01, 
    0xf1, 
    0x37, 0x13, 0x80, 
    0x1c, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x02, 
    0x32, 
    0x35, 0x1b, 0x80, 
    0x1c, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x1a, 0x00, 
    0x1d, MP_QSTR_pin & 0xff, MP_QSTR_pin >> 8,
    0x1c, MP_QSTR_bytearray & 0xff, MP_QSTR_bytearray >> 8,
    0xb0, 
    0x62, 0x02, 0x01, 
    0x1a, 0x00, 
    0x1d, MP_QSTR_buf & 0xff, MP_QSTR_buf >> 8,
    0x64, 0x01, 
    0x64, 0x01, 
    0x64, 0x02, 
    0x32, 
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_neopixel__lt_module_gt__NeoPixel_show_0 = {{&mp_type_float}, 0.99};
#endif
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel_show[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__NeoPixel_show_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbffd70a6),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_show__lt_listcomp_gt_),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel_show = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel_show,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel_show,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 80,
        .n_obj = 1,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel__lt_module_gt__NeoPixel
STATIC const byte bytecode_data_neopixel__lt_module_gt__NeoPixel[167] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23,
    MP_QSTR_NeoPixel & 0xff, MP_QSTR_NeoPixel >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x8d, 0x27, 0x80, 0x27, 0x29, 0x78, 0x60, 0x60, 0x85, 0x07, 0x65, 0x65, 0x65, 0x85, 0x21, 0x85, 0x10, 0x85, 0x0f, 0x65, 0x6a, 0x40, 0x6d, 0x40, 0x85, 0x0a, 0x65, 0x60, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_NeoPixel & 0xff, MP_QSTR_NeoPixel >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x81, 
    0x80, 
    0x82, 
    0x83, 
    0x50, 0x04, 
    0x24, MP_QSTR_ORDER & 0xff, MP_QSTR_ORDER >> 8,
    0x18, 
    0x53, 0x00, 
    0x83, 
    0x16, MP_QSTR_bpp & 0xff, MP_QSTR_bpp >> 8,
    0x54, 
    0x17, 0x00, 
    0x16, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x54, 
    0x12, 
    0x16, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x54, 
    0x61, 0x01, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    0x60, 0x05, 
    0x24, MP_QSTR___repr__ & 0xff, MP_QSTR___repr__ >> 8,
    0x60, 0x06, 
    0x24, MP_QSTR__set_item & 0xff, MP_QSTR__set_item >> 8,
    0x60, 0x07, 
    0x24, MP_QSTR___setitem__ & 0xff, MP_QSTR___setitem__ >> 8,
    0x60, 0x08, 
    0x24, MP_QSTR___getitem__ & 0xff, MP_QSTR___getitem__ >> 8,
    0x60, 0x09, 
    0x24, MP_QSTR___len__ & 0xff, MP_QSTR___len__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x0a, 
    0x64, 0x01, 
    0x24, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x1b, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x0b, 
    0x64, 0x01, 
    0x24, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x60, 0x0c, 
    0x24, MP_QSTR_fill & 0xff, MP_QSTR_fill >> 8,
    0x60, 0x0d, 
    0x24, MP_QSTR_write & 0xff, MP_QSTR_write >> 8,
    0x60, 0x0e, 
    0x24, MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_neopixel__lt_module_gt__NeoPixel_0 = {{&mp_type_float}, 1};
#endif
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt__NeoPixel[15] = {
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__NeoPixel_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___init__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_deinit),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___enter__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___exit__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___repr__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel__set_item),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___setitem__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___getitem__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel___len__),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_brightness),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_brightness2),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_fill),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_write),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel_show),
};
STATIC const mp_raw_code_t raw_code_neopixel__lt_module_gt__NeoPixel = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt__NeoPixel,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt__NeoPixel,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 167,
        .n_obj = 1,
        .n_raw_code = 14,
        #endif
    },
};

// frozen bytecode for file neopixel.py, scope neopixel_<module>
STATIC const byte bytecode_data_neopixel__lt_module_gt_[79] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_neopixel_dot_py & 0xff, MP_QSTR_neopixel_dot_py >> 8,
    0x81, 0x17, 0x80, 0x07, 0x48, 0x28, 0x50, 0x26, 0x45, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x24, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x80, 
    0x16, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x50, 0x01, 
    0x68, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x69, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x24, MP_QSTR_neopixel_write & 0xff, MP_QSTR_neopixel_write >> 8,
    0x32, 
    0x16, MP_QSTR_3_dot_0_dot_1 & 0xff, MP_QSTR_3_dot_0_dot_1 >> 8,
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x00, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x01, 
    0x16, MP_QSTR_NeoPixel & 0xff, MP_QSTR_NeoPixel >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_NeoPixel & 0xff, MP_QSTR_NeoPixel >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_neopixel__lt_module_gt__0 = {{&mp_type_str}, 97, 63, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x4e\x65\x6f\x50\x69\x78\x65\x6c\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_neopixel__lt_module_gt_[2] = {
    MP_ROM_PTR(&const_obj_neopixel__lt_module_gt__0),
    MP_ROM_PTR(&raw_code_neopixel__lt_module_gt__NeoPixel),
};
const mp_raw_code_t raw_code_neopixel__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_neopixel__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_neopixel__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 79,
        .n_obj = 1,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt___BaseServo___init__
STATIC const byte bytecode_data_servo__lt_module_gt___BaseServo___init__[83] = {
    0x08, 0x00, 0x08, 0x02, 0x02, 0x00, 0x0c,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x2b, 0x39, 0x31, 0x2f, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb2, 
    0xb1, 
    0x1d, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0xde, 
    0x14, 0xbd, 0x84, 0x40, 
    0xe0, 
    0x14, 0x83, 0xff, 0x7f, 
    0xde, 
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR__min_duty & 0xff, MP_QSTR__min_duty >> 8,
    0xb3, 
    0xb1, 
    0x1d, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0xde, 
    0x14, 0xbd, 0x84, 0x40, 
    0xe0, 
    0x14, 0x83, 0xff, 0x7f, 
    0xde, 
    0xc4, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb4, 
    0xb0, 
    0x1d, MP_QSTR__min_duty & 0xff, MP_QSTR__min_duty >> 8,
    0xdd, 
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR__duty_range & 0xff, MP_QSTR__duty_range >> 8,
    0xb1, 
    0xb0, 
    0x26, MP_QSTR__pwm_out & 0xff, MP_QSTR__pwm_out >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt___BaseServo___init__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pwm_out),
    MP_ROM_QSTR(MP_QSTR_min_pulse),
    MP_ROM_QSTR(MP_QSTR_max_pulse),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt___BaseServo___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt___BaseServo___init__,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt___BaseServo___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 83,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt___BaseServo__fraction
STATIC const byte bytecode_data_servo__lt_module_gt___BaseServo__fraction[34] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x32, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__pwm_out & 0xff, MP_QSTR__pwm_out >> 8,
    0x1d, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0xb0, 
    0x1d, MP_QSTR__min_duty & 0xff, MP_QSTR__min_duty >> 8,
    0xdd, 
    0xb0, 
    0x1d, MP_QSTR__duty_range & 0xff, MP_QSTR__duty_range >> 8,
    0xe0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt___BaseServo__fraction[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt___BaseServo__fraction = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt___BaseServo__fraction,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt___BaseServo__fraction,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 34,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt___BaseServo__fraction
STATIC const byte bytecode_data_servo__lt_module_gt___BaseServo__fraction2[45] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x36, 0x20, 0x31, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__min_duty & 0xff, MP_QSTR__min_duty >> 8,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR__duty_range & 0xff, MP_QSTR__duty_range >> 8,
    0xde, 
    0x64, 0x01, 
    0xdc, 
    0xc2, 
    0xb2, 
    0xb0, 
    0x1d, MP_QSTR__pwm_out & 0xff, MP_QSTR__pwm_out >> 8,
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt___BaseServo__fraction2[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt___BaseServo__fraction2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt___BaseServo__fraction2,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt___BaseServo__fraction2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 45,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt___BaseServo
STATIC const byte bytecode_data_servo__lt_module_gt___BaseServo[81] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
    MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x8d, 0x25, 0x60, 0x40, 0x76, 0x60, 0x6a, 0x20, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x14, 0x87, 0x68, 
    0x16, MP_QSTR_min_pulse & 0xff, MP_QSTR_min_pulse >> 8,
    0x54, 
    0x14, 0x8f, 0x50, 
    0x16, MP_QSTR_max_pulse & 0xff, MP_QSTR_max_pulse >> 8,
    0x54, 
    0x61, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x1b, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x02, 
    0x64, 0x01, 
    0x24, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt___BaseServo[3] = {
    MP_ROM_PTR(&raw_code_servo__lt_module_gt___BaseServo___init__),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt___BaseServo__fraction),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt___BaseServo__fraction2),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt___BaseServo = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt___BaseServo,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt___BaseServo,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 81,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__Servo___init__
STATIC const byte bytecode_data_servo__lt_module_gt__Servo___init__[52] = {
    0x0d, 0x00, 0x08, 0x03, 0x03, 0x00, 0x0b,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x43, 0x36, 0x25, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_super & 0xff, MP_QSTR_super >> 8,
    0x1a, 0x00, 
    0xb1, 
    0x1f, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb2, 
    0x16, MP_QSTR_min_pulse & 0xff, MP_QSTR_min_pulse >> 8,
    0xb4, 
    0x16, MP_QSTR_max_pulse & 0xff, MP_QSTR_max_pulse >> 8,
    0xb5, 
    0x66, 0x84, 0x01, 
    0x32, 
    0xb3, 
    0xb1, 
    0x26, MP_QSTR__actuation_range & 0xff, MP_QSTR__actuation_range >> 8,
    0xb2, 
    0xb1, 
    0x26, MP_QSTR__pwm & 0xff, MP_QSTR__pwm >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__Servo___init__[6] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_pwm_out),
    MP_ROM_QSTR(MP_QSTR_actuation_range),
    MP_ROM_QSTR(MP_QSTR_min_pulse),
    MP_ROM_QSTR(MP_QSTR_max_pulse),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__Servo___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__Servo___init__,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__Servo___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 52,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__Servo_angle
STATIC const byte bytecode_data_servo__lt_module_gt__Servo_angle[27] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x49, 0x20, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__actuation_range & 0xff, MP_QSTR__actuation_range >> 8,
    0xb0, 
    0x1d, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0xde, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__Servo_angle[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__Servo_angle = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__Servo_angle,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__Servo_angle,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 27,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__Servo_angle
STATIC const byte bytecode_data_servo__lt_module_gt__Servo_angle2[54] = {
    0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x4e, 0x2f, 0x29, 0x00, 0x00, 0xff,
    0xb1, 
    0x80, 
    0xf0, 
    0x36, 0x09, 0x80, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR__actuation_range & 0xff, MP_QSTR__actuation_range >> 8,
    0xf1, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x02, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb1, 
    0xb0, 
    0x1d, MP_QSTR__actuation_range & 0xff, MP_QSTR__actuation_range >> 8,
    0xe0, 
    0xb0, 
    0x26, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_servo__lt_module_gt__Servo_angle2_0 = {{&mp_type_str}, 28, 18, (const byte*)"\x41\x6e\x67\x6c\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65"};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__Servo_angle2[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_new_angle),
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__Servo_angle2_0),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__Servo_angle2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__Servo_angle2,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__Servo_angle2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 54,
        .n_obj = 1,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__Servo
STATIC const byte bytecode_data_servo__lt_module_gt__Servo[91] = {
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
    MP_QSTR_Servo & 0xff, MP_QSTR_Servo >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x8e, 0x3b, 0x80, 0x07, 0x7f, 0x40, 0x6a, 0x40, 0x00, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_Servo & 0xff, MP_QSTR_Servo >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x14, 0x81, 0x34, 
    0x16, MP_QSTR_actuation_range & 0xff, MP_QSTR_actuation_range >> 8,
    0x54, 
    0x14, 0x87, 0x68, 
    0x16, MP_QSTR_min_pulse & 0xff, MP_QSTR_min_pulse >> 8,
    0x54, 
    0x14, 0x8f, 0x50, 
    0x16, MP_QSTR_max_pulse & 0xff, MP_QSTR_max_pulse >> 8,
    0x54, 
    0xb0, 
    0x63, 0x00, 0x01, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    0x1b, MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x02, 
    0x64, 0x01, 
    0x24, MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__Servo[3] = {
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__Servo___init__),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__Servo_angle),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__Servo_angle2),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__Servo = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__Servo,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__Servo,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 91,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo_throttle
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo_throttle[26] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x59, 0x60, 0x00, 0x00, 0xff,
    0xb0, 
    0x1d, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x82, 
    0xde, 
    0x81, 
    0xdd, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo_throttle[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo_throttle = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo_throttle,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo_throttle,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 26,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo_throttle
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo_throttle2[70] = {
    0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0d,
    MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x60, 0x2f, 0x29, 0x26, 0x29, 0x00, 0x00, 0xff,
    0xb1, 
    0x17, 0x02, 
    0xf1, 
    0x36, 0x08, 0x80, 
    0xb1, 
    0x17, 0x03, 
    0xd4, 
    0xf0, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x04, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb1, 
    0x11, 
    0xf7, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x05, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0xb1, 
    0x81, 
    0xdc, 
    0x82, 
    0xe0, 
    0xb0, 
    0x26, MP_QSTR__fraction & 0xff, MP_QSTR__fraction >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_servo__lt_module_gt__ContinuousServo_throttle2_0 = {{&mp_type_float}, 1};
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_servo__lt_module_gt__ContinuousServo_throttle2_1 = {{&mp_type_float}, 1};
#endif
STATIC const mp_obj_str_t const_obj_servo__lt_module_gt__ContinuousServo_throttle2_2 = {{&mp_type_str}, 217, 37, (const byte*)"\x54\x68\x72\x6f\x74\x74\x6c\x65\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x62\x65\x74\x77\x65\x65\x6e\x20\x2d\x31\x2e\x30\x20\x61\x6e\x64\x20\x31\x2e\x30"};
STATIC const mp_obj_str_t const_obj_servo__lt_module_gt__ContinuousServo_throttle2_3 = {{&mp_type_str}, 90, 36, (const byte*)"\x43\x6f\x6e\x74\x69\x6e\x75\x6f\x75\x73\x20\x73\x65\x72\x76\x6f\x73\x20\x63\x61\x6e\x6e\x6f\x74\x20\x73\x70\x69\x6e\x20\x66\x72\x65\x65\x6c\x79"};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo_throttle2[6] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_value),
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__ContinuousServo_throttle2_0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__ContinuousServo_throttle2_1),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xc0000002),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__ContinuousServo_throttle2_2),
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__ContinuousServo_throttle2_3),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo_throttle2 = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo_throttle2,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo_throttle2,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 70,
        .n_obj = 4,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo___enter__
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo___enter__[18] = {
    0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x67, 0x00, 0x00, 0xff,
    0xb0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo___enter__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo___enter__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo___enter__,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo___enter__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 18,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo___exit__
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo___exit__[23] = {
    0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x09,
    MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x6a, 0x00, 0x00, 0xff,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo___exit__[4] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_exception_type),
    MP_ROM_QSTR(MP_QSTR_exception_value),
    MP_ROM_QSTR(MP_QSTR_traceback),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo___exit__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 4,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo___exit__,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo___exit__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 23,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo_deinit
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo_deinit[24] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x6d, 0x20, 0x00, 0x00, 0xff,
    0x80, 
    0xb0, 
    0x26, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo_deinit[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo_deinit = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo_deinit,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo_deinit,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 24,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo__lt_module_gt__ContinuousServo
STATIC const byte bytecode_data_servo__lt_module_gt__ContinuousServo[76] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
    MP_QSTR_ContinuousServo & 0xff, MP_QSTR_ContinuousServo >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x8d, 0x53, 0x60, 0x20, 0x8a, 0x07, 0x8d, 0x08, 0x65, 0x65, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_ContinuousServo & 0xff, MP_QSTR_ContinuousServo >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x1b, MP_QSTR_property & 0xff, MP_QSTR_property >> 8,
    0x60, 0x00, 
    0x64, 0x01, 
    0x24, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x1b, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x1d, MP_QSTR_setter & 0xff, MP_QSTR_setter >> 8,
    0x60, 0x01, 
    0x64, 0x01, 
    0x24, MP_QSTR_throttle & 0xff, MP_QSTR_throttle >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR___enter__ & 0xff, MP_QSTR___enter__ >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR___exit__ & 0xff, MP_QSTR___exit__ >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt__ContinuousServo[5] = {
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo_throttle),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo_throttle2),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo___enter__),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo___exit__),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo_deinit),
};
STATIC const mp_raw_code_t raw_code_servo__lt_module_gt__ContinuousServo = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt__ContinuousServo,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt__ContinuousServo,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 76,
        .n_obj = 0,
        .n_raw_code = 5,
        #endif
    },
};

// frozen bytecode for file servo.py, scope servo_<module>
STATIC const byte bytecode_data_servo__lt_module_gt_[76] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_servo_dot_py & 0xff, MP_QSTR_servo_dot_py >> 8,
    0x81, 0x15, 0x80, 0x0a, 0x25, 0x65, 0x20, 0x8b, 0x16, 0x8e, 0x18, 0x00, 0x00, 0xff,
    0x17, 0x00, 
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x01, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    0x20, 
    0x60, 0x03, 
    0x16, MP_QSTR_Servo & 0xff, MP_QSTR_Servo >> 8,
    0x1b, MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_Servo & 0xff, MP_QSTR_Servo >> 8,
    0x20, 
    0x60, 0x04, 
    0x16, MP_QSTR_ContinuousServo & 0xff, MP_QSTR_ContinuousServo >> 8,
    0x1b, MP_QSTR__BaseServo & 0xff, MP_QSTR__BaseServo >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_ContinuousServo & 0xff, MP_QSTR_ContinuousServo >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_servo__lt_module_gt__0 = {{&mp_type_str}, 151, 28, (const byte*)"\x32\x2e\x32\x2e\x35\x2d\x61\x6c\x70\x68\x61\x2e\x30\x2e\x70\x6c\x75\x73\x2e\x32\x2b\x63\x66\x63\x62\x62\x33\x36"};
STATIC const mp_obj_str_t const_obj_servo__lt_module_gt__1 = {{&mp_type_str}, 38, 60, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x4d\x6f\x74\x6f\x72\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_servo__lt_module_gt_[5] = {
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__0),
    MP_ROM_PTR(&const_obj_servo__lt_module_gt__1),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt___BaseServo),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__Servo),
    MP_ROM_PTR(&raw_code_servo__lt_module_gt__ContinuousServo),
};
const mp_raw_code_t raw_code_servo__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_servo__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_servo__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 76,
        .n_obj = 2,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper__lt_module_gt__StepperMotor___init___<listcomp>
STATIC const byte bytecode_data_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_[66] = {
    0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR__lt_listcomp_gt_ & 0xff, MP_QSTR__lt_listcomp_gt_ >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x89, 0x51, 0x00, 0x00, 0xff,
    0x51, 0x00, 
    0xb1, 
    0x47, 
    0x43, 0x2a, 0x00, 
    0xc2, 
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0x1c, MP_QSTR_round & 0xff, MP_QSTR_round >> 8,
    0x14, 0x83, 0xff, 0x7f, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_sin & 0xff, MP_QSTR_sin >> 8,
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1d, MP_QSTR_pi & 0xff, MP_QSTR_pi >> 8,
    0x82, 
    0x1a, 0x00, 
    0xde, 
    0xe0, 
    0xb2, 
    0xde, 
    0x66, 0x01, 
    0xde, 
    0x64, 0x01, 
    0x64, 0x01, 
    0x57, 0x14, 
    0x35, 0xd3, 0x7f, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_[2] = {
    MP_ROM_QSTR(MP_QSTR__star_),
    MP_ROM_QSTR(MP_QSTR__star_),
};
STATIC const mp_raw_code_t raw_code_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 66,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper__lt_module_gt__StepperMotor___init__
STATIC const byte bytecode_data_stepper__lt_module_gt__StepperMotor___init__[109] = {
    0x0a, 0x00, 0x08, 0x05, 0x01, 0x00, 0x12,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x82, 0x49, 0x4a, 0x25, 0x27, 0x29, 0x29, 0x29, 0x26, 0x24, 0x2f, 0x00, 0x00, 0x05, 0xff,
    0xb2, 
    0xb3, 
    0xb1, 
    0xb4, 
    0x50, 0x04, 
    0xb0, 
    0x26, MP_QSTR__coil & 0xff, MP_QSTR__coil >> 8,
    0x80, 
    0xb0, 
    0x26, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0x1a, 0x05, 
    0x82, 
    0xf0, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x06, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x1a, 0x05, 
    0x82, 
    0xe1, 
    0x81, 
    0xf2, 
    0x37, 0x09, 0x80, 
    0x1c, MP_QSTR_ValueError & 0xff, MP_QSTR_ValueError >> 8,
    0x17, 0x07, 
    0x64, 0x01, 
    0x5c, 0x01, 
    0x1a, 0x05, 
    0xb0, 
    0x26, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0xb5, 
    0x62, 0x08, 0x01, 
    0x1c, MP_QSTR_range & 0xff, MP_QSTR_range >> 8,
    0x1a, 0x05, 
    0x81, 
    0xdc, 
    0x64, 0x01, 
    0x64, 0x01, 
    0xb0, 
    0x26, MP_QSTR__curve & 0xff, MP_QSTR__curve >> 8,
    0xb0, 
    0x1e, MP_QSTR__update_coils & 0xff, MP_QSTR__update_coils >> 8,
    0x66, 0x00, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_stepper__lt_module_gt__StepperMotor___init___0 = {{&mp_type_str}, 174, 29, (const byte*)"\x4d\x69\x63\x72\x6f\x73\x74\x65\x70\x73\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x61\x74\x20\x6c\x65\x61\x73\x74\x20\x32"};
STATIC const mp_obj_str_t const_obj_stepper__lt_module_gt__StepperMotor___init___1 = {{&mp_type_str}, 30, 23, (const byte*)"\x4d\x69\x63\x72\x6f\x73\x74\x65\x70\x73\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x65\x76\x65\x6e"};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt__StepperMotor___init__[9] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_ain1),
    MP_ROM_QSTR(MP_QSTR_ain2),
    MP_ROM_QSTR(MP_QSTR_bin1),
    MP_ROM_QSTR(MP_QSTR_bin2),
    MP_ROM_QSTR(MP_QSTR_microsteps),
    MP_ROM_PTR(&const_obj_stepper__lt_module_gt__StepperMotor___init___0),
    MP_ROM_PTR(&const_obj_stepper__lt_module_gt__StepperMotor___init___1),
    MP_ROM_PTR(&raw_code_stepper__lt_module_gt__StepperMotor___init____lt_listcomp_gt_),
};
STATIC const mp_raw_code_t raw_code_stepper__lt_module_gt__StepperMotor___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 5,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt__StepperMotor___init__,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt__StepperMotor___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 109,
        .n_obj = 2,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper__lt_module_gt__StepperMotor__update_coils
STATIC const byte bytecode_data_stepper__lt_module_gt__StepperMotor__update_coils[151] = {
    0x0b, 0x00, 0x08, 0x01, 0x01, 0x00, 0x15,
    MP_QSTR__update_coils & 0xff, MP_QSTR__update_coils >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x81, 0x56, 0x27, 0x2c, 0x26, 0x2a, 0x29, 0x6e, 0x20, 0x2e, 0x28, 0x27, 0x67, 0x26, 0x00, 0x00, 0xff,
    0x80, 
    0x80, 
    0x80, 
    0x80, 
    0x51, 0x04, 
    0xc2, 
    0xb0, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb0, 
    0x1d, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0xdf, 
    0x84, 
    0xe1, 
    0xc3, 
    0xb3, 
    0x81, 
    0xdc, 
    0x84, 
    0xe1, 
    0xc4, 
    0xb0, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb0, 
    0x1d, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0xe1, 
    0xc5, 
    0xb0, 
    0x1d, MP_QSTR__curve & 0xff, MP_QSTR__curve >> 8,
    0xb5, 
    0x21, 
    0xb2, 
    0xb4, 
    0x27, 
    0xb0, 
    0x1d, MP_QSTR__curve & 0xff, MP_QSTR__curve >> 8,
    0xb0, 
    0x1d, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0xb5, 
    0xdd, 
    0x21, 
    0xb2, 
    0xb3, 
    0x27, 
    0xb1, 
    0x36, 0x20, 0x80, 
    0xb2, 
    0xb4, 
    0x21, 
    0xb2, 
    0xb3, 
    0x21, 
    0xf2, 
    0x37, 0x16, 0x80, 
    0xb2, 
    0xb4, 
    0x21, 
    0x80, 
    0xf1, 
    0x37, 0x0e, 0x80, 
    0x14, 0x83, 0xff, 0x7f, 
    0xb2, 
    0xb4, 
    0x27, 
    0x14, 0x83, 0xff, 0x7f, 
    0xb2, 
    0xb3, 
    0x27, 
    0x80, 
    0x35, 0x10, 0x80, 
    0x30, 
    0xc6, 
    0xb2, 
    0xb6, 
    0x21, 
    0xb0, 
    0x1d, MP_QSTR__coil & 0xff, MP_QSTR__coil >> 8,
    0xb6, 
    0x21, 
    0x26, MP_QSTR_duty_cycle & 0xff, MP_QSTR_duty_cycle >> 8,
    0x81, 
    0xe9, 
    0x30, 
    0x84, 
    0xf0, 
    0x36, 0xea, 0x7f, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt__StepperMotor__update_coils[2] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_microstepping),
};
STATIC const mp_raw_code_t raw_code_stepper__lt_module_gt__StepperMotor__update_coils = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt__StepperMotor__update_coils,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt__StepperMotor__update_coils,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 151,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper__lt_module_gt__StepperMotor_onestep
STATIC const byte bytecode_data_stepper__lt_module_gt__StepperMotor_onestep[235] = {
    0x0d, 0x00, 0x08, 0x01, 0x02, 0x00, 0x22,
    MP_QSTR_onestep & 0xff, MP_QSTR_onestep >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x81, 0x69, 0x80, 0x0a, 0x22, 0x26, 0x45, 0x27, 0x65, 0x27, 0x66, 0x26, 0x50, 0x2b, 0x25, 0x26, 0x45, 0x27, 0x2e, 0x2e, 0x25, 0x2c, 0x45, 0x26, 0x4e, 0x6b, 0x4e, 0x00, 0x00, 0xff,
    0x80, 
    0xc3, 
    0xb2, 
    0x84, 
    0xf2, 
    0x37, 0x05, 0x80, 
    0x81, 
    0xc3, 
    0x35, 0x83, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0x82, 
    0xdf, 
    0xc4, 
    0xb0, 
    0x1d, MP_QSTR__microsteps & 0xff, MP_QSTR__microsteps >> 8,
    0xc5, 
    0xb0, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb4, 
    0xe1, 
    0xc6, 
    0xb6, 
    0x80, 
    0xf5, 
    0x37, 0x26, 0x80, 
    0xb1, 
    0x81, 
    0xf2, 
    0x37, 0x10, 0x80, 
    0xb0, 
    0x30, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb4, 
    0xb6, 
    0xdd, 
    0xe9, 
    0x33, 
    0x26, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0x35, 0x0b, 0x80, 
    0xb0, 
    0x30, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb6, 
    0xea, 
    0x33, 
    0x26, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0x80, 
    0xc3, 
    0x35, 0x0b, 0x80, 
    0xb2, 
    0x83, 
    0xf2, 
    0x37, 0x05, 0x80, 
    0xb4, 
    0xc3, 
    0x35, 0x00, 0x80, 
    0xb0, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb4, 
    0xdf, 
    0xc7, 
    0xb2, 
    0x81, 
    0xf2, 
    0x37, 0x08, 0x80, 
    0xb7, 
    0x82, 
    0xe1, 
    0x81, 
    0xf2, 
    0x36, 0x0e, 0x80, 
    0xb2, 
    0x82, 
    0xf2, 
    0x37, 0x0d, 0x80, 
    0xb7, 
    0x82, 
    0xe1, 
    0x80, 
    0xf2, 
    0x37, 0x05, 0x80, 
    0xb4, 
    0xc3, 
    0x35, 0x11, 0x80, 
    0xb2, 
    0x81, 
    0xf2, 
    0x36, 0x06, 0x80, 
    0xb2, 
    0x82, 
    0xf2, 
    0x37, 0x05, 0x80, 
    0xb5, 
    0xc3, 
    0x35, 0x00, 0x80, 
    0xb1, 
    0x81, 
    0xf2, 
    0x37, 0x0e, 0x80, 
    0xb0, 
    0x30, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb3, 
    0xe9, 
    0x33, 
    0x26, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0x35, 0x0b, 0x80, 
    0xb0, 
    0x30, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb3, 
    0xea, 
    0x33, 
    0x26, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0xb0, 
    0x1e, MP_QSTR__update_coils & 0xff, MP_QSTR__update_coils >> 8,
    0x16, MP_QSTR_microstepping & 0xff, MP_QSTR_microstepping >> 8,
    0xb2, 
    0x84, 
    0xf2, 
    0x66, 0x82, 0x00, 
    0x32, 
    0xb0, 
    0x1d, MP_QSTR__current_microstep & 0xff, MP_QSTR__current_microstep >> 8,
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt__StepperMotor_onestep[3] = {
    MP_ROM_QSTR(MP_QSTR_self),
    MP_ROM_QSTR(MP_QSTR_direction),
    MP_ROM_QSTR(MP_QSTR_style),
};
STATIC const mp_raw_code_t raw_code_stepper__lt_module_gt__StepperMotor_onestep = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x08,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt__StepperMotor_onestep,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt__StepperMotor_onestep,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 235,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper__lt_module_gt__StepperMotor
STATIC const byte bytecode_data_stepper__lt_module_gt__StepperMotor[80] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
    MP_QSTR_StepperMotor & 0xff, MP_QSTR_StepperMotor >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x8d, 0x3c, 0x80, 0x0c, 0x8d, 0x0d, 0x8d, 0x13, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_StepperMotor & 0xff, MP_QSTR_StepperMotor >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x90, 
    0x16, MP_QSTR_microsteps & 0xff, MP_QSTR_microsteps >> 8,
    0x54, 
    0x61, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x18, 
    0x53, 0x00, 
    0x10, 
    0x16, MP_QSTR_microstepping & 0xff, MP_QSTR_microstepping >> 8,
    0x54, 
    0x61, 0x01, 
    0x24, MP_QSTR__update_coils & 0xff, MP_QSTR__update_coils >> 8,
    0x18, 
    0x53, 0x00, 
    0x81, 
    0x16, MP_QSTR_direction & 0xff, MP_QSTR_direction >> 8,
    0x54, 
    0x81, 
    0x16, MP_QSTR_style & 0xff, MP_QSTR_style >> 8,
    0x54, 
    0x61, 0x02, 
    0x24, MP_QSTR_onestep & 0xff, MP_QSTR_onestep >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt__StepperMotor[3] = {
    MP_ROM_PTR(&raw_code_stepper__lt_module_gt__StepperMotor___init__),
    MP_ROM_PTR(&raw_code_stepper__lt_module_gt__StepperMotor__update_coils),
    MP_ROM_PTR(&raw_code_stepper__lt_module_gt__StepperMotor_onestep),
};
STATIC const mp_raw_code_t raw_code_stepper__lt_module_gt__StepperMotor = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt__StepperMotor,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt__StepperMotor,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 80,
        .n_obj = 0,
        .n_raw_code = 3,
        #endif
    },
};

// frozen bytecode for file stepper.py, scope stepper_<module>
STATIC const byte bytecode_data_stepper__lt_module_gt_[106] = {
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_stepper_dot_py & 0xff, MP_QSTR_stepper_dot_py >> 8,
    0x81, 0x15, 0x80, 0x0c, 0x48, 0x50, 0x25, 0x85, 0x07, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x20, 0x24, 0x60, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x16, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x50, 0x01, 
    0x68, MP_QSTR_micropython & 0xff, MP_QSTR_micropython >> 8,
    0x69, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x24, MP_QSTR_const & 0xff, MP_QSTR_const >> 8,
    0x32, 
    0x17, 0x00, 
    0x24, MP_QSTR___version__ & 0xff, MP_QSTR___version__ >> 8,
    0x17, 0x01, 
    0x24, MP_QSTR___repo__ & 0xff, MP_QSTR___repo__ >> 8,
    0x81, 
    0x24, MP_QSTR_FORWARD & 0xff, MP_QSTR_FORWARD >> 8,
    0x82, 
    0x24, MP_QSTR_BACKWARD & 0xff, MP_QSTR_BACKWARD >> 8,
    0x81, 
    0x24, MP_QSTR_SINGLE & 0xff, MP_QSTR_SINGLE >> 8,
    0x82, 
    0x24, MP_QSTR_DOUBLE & 0xff, MP_QSTR_DOUBLE >> 8,
    0x83, 
    0x24, MP_QSTR_INTERLEAVE & 0xff, MP_QSTR_INTERLEAVE >> 8,
    0x84, 
    0x24, MP_QSTR_MICROSTEP & 0xff, MP_QSTR_MICROSTEP >> 8,
    0x20, 
    0x60, 0x02, 
    0x16, MP_QSTR_StepperMotor & 0xff, MP_QSTR_StepperMotor >> 8,
    0x64, 0x02, 
    0x24, MP_QSTR_StepperMotor & 0xff, MP_QSTR_StepperMotor >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_obj_str_t const_obj_stepper__lt_module_gt__0 = {{&mp_type_str}, 151, 28, (const byte*)"\x32\x2e\x32\x2e\x35\x2d\x61\x6c\x70\x68\x61\x2e\x30\x2e\x70\x6c\x75\x73\x2e\x32\x2b\x63\x66\x63\x62\x62\x33\x36"};
STATIC const mp_obj_str_t const_obj_stepper__lt_module_gt__1 = {{&mp_type_str}, 38, 60, (const byte*)"\x68\x74\x74\x70\x73\x3a\x2f\x2f\x67\x69\x74\x68\x75\x62\x2e\x63\x6f\x6d\x2f\x61\x64\x61\x66\x72\x75\x69\x74\x2f\x41\x64\x61\x66\x72\x75\x69\x74\x5f\x43\x69\x72\x63\x75\x69\x74\x50\x79\x74\x68\x6f\x6e\x5f\x4d\x6f\x74\x6f\x72\x2e\x67\x69\x74"};
STATIC const mp_rom_obj_t const_table_data_stepper__lt_module_gt_[3] = {
    MP_ROM_PTR(&const_obj_stepper__lt_module_gt__0),
    MP_ROM_PTR(&const_obj_stepper__lt_module_gt__1),
    MP_ROM_PTR(&raw_code_stepper__lt_module_gt__StepperMotor),
};
const mp_raw_code_t raw_code_stepper__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_stepper__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_stepper__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 106,
        .n_obj = 2,
        .n_raw_code = 1,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__send_ir
STATIC const byte bytecode_data_tslib__lt_module_gt__send_ir[237] = {
    0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1a,
    MP_QSTR_send_ir & 0xff, MP_QSTR_send_ir >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x15, 0x20, 0x20, 0x24, 0x29, 0x3e, 0x3e, 0x3f, 0x2c, 0x2a, 0x45, 0x22, 0x20, 0x3f, 0x2c, 0x2a, 0x45, 0x22, 0x00, 0x00, 0xff,
    0x94, 
    0x25, MP_QSTR_last_sent_time & 0xff, MP_QSTR_last_sent_time >> 8,
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR_SENDING & 0xff, MP_QSTR_SENDING >> 8,
    0x64, 0x01, 
    0x32, 
    0x1c, MP_QSTR_hasattr & 0xff, MP_QSTR_hasattr >> 8,
    0x1c, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x16, MP_QSTR_irSend & 0xff, MP_QSTR_irSend >> 8,
    0x64, 0x02, 
    0x37, 0x0e, 0x80, 
    0x1c, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x1d, MP_QSTR_irSend & 0xff, MP_QSTR_irSend >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x35, 0x01, 0x80, 
    0x11, 
    0x32, 
    0x1c, MP_QSTR_hasattr & 0xff, MP_QSTR_hasattr >> 8,
    0x1c, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x16, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x64, 0x02, 
    0x37, 0x0e, 0x80, 
    0x1c, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x1d, MP_QSTR_irPWM & 0xff, MP_QSTR_irPWM >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x35, 0x01, 0x80, 
    0x11, 
    0x32, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x37, 0x11, 0x80, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x35, 0x01, 0x80, 
    0x11, 
    0x32, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x37, 0x0f, 0x80, 
    0x11, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x26, MP_QSTR__sample & 0xff, MP_QSTR__sample >> 8,
    0x11, 
    0xc1, 
    0x35, 0x02, 0x80, 
    0x11, 
    0xc1, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x37, 0x11, 0x80, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x35, 0x01, 0x80, 
    0x11, 
    0x32, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x37, 0x0f, 0x80, 
    0x11, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x26, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x11, 
    0xc2, 
    0x35, 0x02, 0x80, 
    0x11, 
    0xc2, 
    0x1c, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x1e, MP_QSTR_send & 0xff, MP_QSTR_send >> 8,
    0xb0, 
    0x86, 
    0x66, 0x02, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__send_ir[1] = {
    MP_ROM_QSTR(MP_QSTR_n),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__send_ir = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__send_ir,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__send_ir,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 237,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__ir_receive
STATIC const byte bytecode_data_tslib__lt_module_gt__ir_receive[158] = {
    0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1d,
    MP_QSTR_ir_receive & 0xff, MP_QSTR_ir_receive >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x2c, 0x20, 0x20, 0x20, 0x28, 0x22, 0x23, 0x29, 0x47, 0x2b, 0x2f, 0x29, 0x27, 0x2c, 0x27, 0x24, 0x49, 0x22, 0x45, 0x28, 0x22, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_last_sent_time & 0xff, MP_QSTR_last_sent_time >> 8,
    0x80, 
    0xf2, 
    0x37, 0x66, 0x80, 
    0x10, 
    0xc0, 
    0x3f, 0x0f, 0x00, 
    0x1c, MP_QSTR_myReceiver & 0xff, MP_QSTR_myReceiver >> 8,
    0x1e, MP_QSTR_getResults & 0xff, MP_QSTR_getResults >> 8,
    0x66, 0x00, 
    0xc0, 
    0x11, 
    0xc1, 
    0x44, 
    0x35, 0x0c, 0x80, 
    0x32, 
    0x1c, MP_QSTR_reset_receiver & 0xff, MP_QSTR_reset_receiver >> 8,
    0x64, 0x00, 
    0xc1, 
    0x45, 
    0x35, 0x01, 0x80, 
    0x41, 
    0xb0, 
    0x37, 0x3b, 0x80, 
    0x1c, MP_QSTR_myDecoder & 0xff, MP_QSTR_myDecoder >> 8,
    0x1e, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x66, 0x00, 
    0x37, 0x30, 0x80, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x16, MP_QSTR_Results_bang__bang_ & 0xff, MP_QSTR_Results_bang__bang_ >> 8,
    0x64, 0x01, 
    0x32, 
    0x1c, MP_QSTR_myDecoder & 0xff, MP_QSTR_myDecoder >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0xc2, 
    0x1c, MP_QSTR_print & 0xff, MP_QSTR_print >> 8,
    0x1c, MP_QSTR_myDecoder & 0xff, MP_QSTR_myDecoder >> 8,
    0x1d, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x64, 0x01, 
    0x32, 
    0x1c, MP_QSTR_myDecoder & 0xff, MP_QSTR_myDecoder >> 8,
    0x1d, MP_QSTR_address & 0xff, MP_QSTR_address >> 8,
    0xc3, 
    0xb2, 
    0x25, MP_QSTR_current_ir_number & 0xff, MP_QSTR_current_ir_number >> 8,
    0x1c, MP_QSTR_reset_receiver & 0xff, MP_QSTR_reset_receiver >> 8,
    0x64, 0x00, 
    0xc4, 
    0x35, 0x02, 0x80, 
    0x11, 
    0xc4, 
    0xb4, 
    0xc5, 
    0x35, 0x0a, 0x80, 
    0x1c, MP_QSTR_last_sent_time & 0xff, MP_QSTR_last_sent_time >> 8,
    0x81, 
    0xdd, 
    0x25, MP_QSTR_last_sent_time & 0xff, MP_QSTR_last_sent_time >> 8,
    0x11, 
    0xc5, 
    0xb5, 
    0x5b, 
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__ir_receive = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__ir_receive,
        .const_table = NULL,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 158,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__reset_receiver
STATIC const byte bytecode_data_tslib__lt_module_gt__reset_receiver[38] = {
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
    MP_QSTR_reset_receiver & 0xff, MP_QSTR_reset_receiver >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x47, 0x2c, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_myReceiver & 0xff, MP_QSTR_myReceiver >> 8,
    0x1d, MP_QSTR_recvBuffer & 0xff, MP_QSTR_recvBuffer >> 8,
    0x1e, MP_QSTR_deinit & 0xff, MP_QSTR_deinit >> 8,
    0x66, 0x00, 
    0x32, 
    0x1c, MP_QSTR_myReceiver & 0xff, MP_QSTR_myReceiver >> 8,
    0x1e, MP_QSTR_enableIRIn & 0xff, MP_QSTR_enableIRIn >> 8,
    0x66, 0x00, 
    0x5b, 
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__reset_receiver = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__reset_receiver,
        .const_table = NULL,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 38,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__set_servo_f
STATIC const byte bytecode_data_tslib__lt_module_gt__set_servo_f[42] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR_set_servo_f & 0xff, MP_QSTR_set_servo_f >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x4c, 0x27, 0x2a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_get_pwm & 0xff, MP_QSTR_get_pwm >> 8,
    0xb0, 
    0x64, 0x01, 
    0xc2, 
    0x1c, MP_QSTR_servo & 0xff, MP_QSTR_servo >> 8,
    0x1e, MP_QSTR_Servo & 0xff, MP_QSTR_Servo >> 8,
    0xb2, 
    0x66, 0x01, 
    0xc3, 
    0xb1, 
    0xb3, 
    0x26, MP_QSTR_angle & 0xff, MP_QSTR_angle >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__set_servo_f[2] = {
    MP_ROM_QSTR(MP_QSTR_pin),
    MP_ROM_QSTR(MP_QSTR_angle),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__set_servo_f = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__set_servo_f,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__set_servo_f,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 42,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__free_servo_pin
STATIC const byte bytecode_data_tslib__lt_module_gt__free_servo_pin[48] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_free_servo_pin & 0xff, MP_QSTR_free_servo_pin >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x52, 0x2a, 0x2a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0x1e, MP_QSTR_index & 0xff, MP_QSTR_index >> 8,
    0xb0, 
    0x66, 0x01, 
    0xc1, 
    0x1c, MP_QSTR_pwms & 0xff, MP_QSTR_pwms >> 8,
    0x1e, MP_QSTR_pop & 0xff, MP_QSTR_pop >> 8,
    0xb1, 
    0x66, 0x01, 
    0x32, 
    0x1c, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0x1e, MP_QSTR_pop & 0xff, MP_QSTR_pop >> 8,
    0xb1, 
    0x66, 0x01, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__free_servo_pin[1] = {
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__free_servo_pin = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__free_servo_pin,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__free_servo_pin,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 48,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__create_new_pwm
STATIC const byte bytecode_data_tslib__lt_module_gt__create_new_pwm[57] = {
    0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0c,
    MP_QSTR_create_new_pwm & 0xff, MP_QSTR_create_new_pwm >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x58, 0x30, 0x2a, 0x2a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x1e, MP_QSTR_PWMOut & 0xff, MP_QSTR_PWMOut >> 8,
    0xb0, 
    0x16, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0x14, 0x32, 
    0x66, 0x82, 0x01, 
    0xc1, 
    0x1c, MP_QSTR_pwms & 0xff, MP_QSTR_pwms >> 8,
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0xb1, 
    0x66, 0x01, 
    0x32, 
    0x1c, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0x1e, MP_QSTR_append & 0xff, MP_QSTR_append >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0xb1, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__create_new_pwm[1] = {
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__create_new_pwm = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__create_new_pwm,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__create_new_pwm,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 57,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__fetch_existing_pwm
STATIC const byte bytecode_data_tslib__lt_module_gt__fetch_existing_pwm[33] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_fetch_existing_pwm & 0xff, MP_QSTR_fetch_existing_pwm >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x5f, 0x2a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0x1e, MP_QSTR_index & 0xff, MP_QSTR_index >> 8,
    0xb0, 
    0x66, 0x01, 
    0xc1, 
    0x1c, MP_QSTR_pwms & 0xff, MP_QSTR_pwms >> 8,
    0xb1, 
    0x21, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__fetch_existing_pwm[1] = {
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__fetch_existing_pwm = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__fetch_existing_pwm,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__fetch_existing_pwm,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 33,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__get_pwm
STATIC const byte bytecode_data_tslib__lt_module_gt__get_pwm[38] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_get_pwm & 0xff, MP_QSTR_get_pwm >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x64, 0x00, 0x00, 0xff,
    0xb0, 
    0x1c, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0xf6, 
    0x37, 0x07, 0x80, 
    0x1c, MP_QSTR_fetch_existing_pwm & 0xff, MP_QSTR_fetch_existing_pwm >> 8,
    0xb0, 
    0x64, 0x01, 
    0x5b, 
    0x1c, MP_QSTR_create_new_pwm & 0xff, MP_QSTR_create_new_pwm >> 8,
    0xb0, 
    0x64, 0x01, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__get_pwm[1] = {
    MP_ROM_QSTR(MP_QSTR_pin),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__get_pwm = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__get_pwm,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__get_pwm,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 38,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__shake
STATIC const byte bytecode_data_tslib__lt_module_gt__shake[33] = {
    0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x69, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1e, MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    0x16, MP_QSTR_shake_threshold & 0xff, MP_QSTR_shake_threshold >> 8,
    0xb0, 
    0x66, 0x82, 0x00, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__shake[1] = {
    MP_ROM_QSTR(MP_QSTR_thresh),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__shake = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__shake,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__shake,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 33,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__pin_write_f
STATIC const byte bytecode_data_tslib__lt_module_gt__pin_write_f[48] = {
    0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b,
    MP_QSTR_pin_write_f & 0xff, MP_QSTR_pin_write_f >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x6d, 0x2a, 0x2d, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0xb0, 
    0x66, 0x01, 
    0xc2, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1d, MP_QSTR_Direction & 0xff, MP_QSTR_Direction >> 8,
    0x1d, MP_QSTR_OUTPUT & 0xff, MP_QSTR_OUTPUT >> 8,
    0xb2, 
    0x26, MP_QSTR_direction & 0xff, MP_QSTR_direction >> 8,
    0xb1, 
    0xb2, 
    0x26, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__pin_write_f[2] = {
    MP_ROM_QSTR(MP_QSTR_pin),
    MP_ROM_QSTR(MP_QSTR_val),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__pin_write_f = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__pin_write_f,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__pin_write_f,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 48,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__mic_level
STATIC const byte bytecode_data_tslib__lt_module_gt__mic_level[76] = {
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
    MP_QSTR_mic_level & 0xff, MP_QSTR_mic_level >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x73, 0x34, 0x29, 0x5a, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_mic & 0xff, MP_QSTR_mic >> 8,
    0x1e, MP_QSTR_record & 0xff, MP_QSTR_record >> 8,
    0x1c, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1c, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x64, 0x01, 
    0x66, 0x02, 
    0x32, 
    0x1c, MP_QSTR_normalized_rms & 0xff, MP_QSTR_normalized_rms >> 8,
    0x1c, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x64, 0x01, 
    0xc0, 
    0x1c, MP_QSTR_log_scale & 0xff, MP_QSTR_log_scale >> 8,
    0x1c, MP_QSTR_constrain & 0xff, MP_QSTR_constrain >> 8,
    0xb0, 
    0x1c, MP_QSTR_input_floor & 0xff, MP_QSTR_input_floor >> 8,
    0x1c, MP_QSTR_input_ceiling & 0xff, MP_QSTR_input_ceiling >> 8,
    0x64, 0x03, 
    0x1c, MP_QSTR_input_floor & 0xff, MP_QSTR_input_floor >> 8,
    0x1c, MP_QSTR_input_ceiling & 0xff, MP_QSTR_input_ceiling >> 8,
    0x80, 
    0x8a, 
    0x64, 0x05, 
    0xc1, 
    0xb1, 
    0x5b, 
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__mic_level = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__mic_level,
        .const_table = NULL,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 76,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__mean
STATIC const byte bytecode_data_tslib__lt_module_gt__mean[30] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_mean & 0xff, MP_QSTR_mean >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x7b, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_sum & 0xff, MP_QSTR_sum >> 8,
    0xb0, 
    0x64, 0x01, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x64, 0x01, 
    0xe0, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__mean[1] = {
    MP_ROM_QSTR(MP_QSTR_values),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__mean = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__mean,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__mean,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__normalized_rms
STATIC const byte bytecode_data_tslib__lt_module_gt__normalized_rms[96] = {
    0x0c, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0f,
    MP_QSTR_normalized_rms & 0xff, MP_QSTR_normalized_rms >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x7f, 0x2c, 0x22, 0x2c, 0x24, 0x2d, 0x2e, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0x1c, MP_QSTR_mean & 0xff, MP_QSTR_mean >> 8,
    0xb0, 
    0x64, 0x01, 
    0x64, 0x01, 
    0xc1, 
    0x80, 
    0xc2, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x64, 0x01, 
    0x80, 
    0x35, 0x19, 0x80, 
    0x30, 
    0xc3, 
    0xb0, 
    0xb3, 
    0x21, 
    0xc4, 
    0x1c, MP_QSTR_float & 0xff, MP_QSTR_float >> 8,
    0xb4, 
    0xb1, 
    0xdd, 
    0xb4, 
    0xb1, 
    0xdd, 
    0xde, 
    0x64, 0x01, 
    0xc5, 
    0xb2, 
    0xb5, 
    0xdc, 
    0xc2, 
    0x81, 
    0xe9, 
    0x31, 
    0x33, 
    0xf0, 
    0x36, 0xe1, 0x7f, 
    0x32, 
    0x32, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_sqrt & 0xff, MP_QSTR_sqrt >> 8,
    0xb2, 
    0x1c, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0xb0, 
    0x64, 0x01, 
    0xe0, 
    0x66, 0x01, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__normalized_rms[1] = {
    MP_ROM_QSTR(MP_QSTR_values),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__normalized_rms = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__normalized_rms,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__normalized_rms,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 96,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__log_scale
STATIC const byte bytecode_data_tslib__lt_module_gt__log_scale[45] = {
    0x0b, 0x00, 0x00, 0x05, 0x00, 0x00, 0x0b,
    MP_QSTR_log_scale & 0xff, MP_QSTR_log_scale >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x89, 0x48, 0x2d, 0x00, 0x00, 0xff,
    0xb0, 
    0xb1, 
    0xdd, 
    0xb2, 
    0xb1, 
    0xdd, 
    0xe0, 
    0xc5, 
    0xb3, 
    0x1c, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_pow & 0xff, MP_QSTR_pow >> 8,
    0xb5, 
    0x1c, MP_QSTR_SCALE_EXPONENT & 0xff, MP_QSTR_SCALE_EXPONENT >> 8,
    0x66, 0x02, 
    0xb4, 
    0xb3, 
    0xdd, 
    0xde, 
    0xdc, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__log_scale[5] = {
    MP_ROM_QSTR(MP_QSTR_input_value),
    MP_ROM_QSTR(MP_QSTR_input_min),
    MP_ROM_QSTR(MP_QSTR_input_max),
    MP_ROM_QSTR(MP_QSTR_output_min),
    MP_ROM_QSTR(MP_QSTR_output_max),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__log_scale = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 5,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__log_scale,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__log_scale,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 45,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__constrain
STATIC const byte bytecode_data_tslib__lt_module_gt__constrain[30] = {
    0x08, 0x00, 0x00, 0x03, 0x00, 0x00, 0x09,
    MP_QSTR_constrain & 0xff, MP_QSTR_constrain >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x90, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_max & 0xff, MP_QSTR_max >> 8,
    0xb1, 
    0x1c, MP_QSTR_min & 0xff, MP_QSTR_min >> 8,
    0xb0, 
    0xb2, 
    0x64, 0x02, 
    0x64, 0x02, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__constrain[3] = {
    MP_ROM_QSTR(MP_QSTR_value),
    MP_ROM_QSTR(MP_QSTR_floor),
    MP_ROM_QSTR(MP_QSTR_ceiling),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__constrain = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 3,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__constrain,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__constrain,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__play_riff
STATIC const byte bytecode_data_tslib__lt_module_gt__play_riff[40] = {
    0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR_play_riff & 0xff, MP_QSTR_play_riff >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x94, 0x26, 0x00, 0x00, 0xff,
    0xb0, 
    0x47, 
    0x43, 0x10, 0x00, 
    0xc1, 
    0x1c, MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    0xb1, 
    0x80, 
    0x21, 
    0xb1, 
    0x81, 
    0x21, 
    0x64, 0x02, 
    0x32, 
    0x35, 0xed, 0x7f, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__play_riff[1] = {
    MP_ROM_QSTR(MP_QSTR_riff),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__play_riff = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__play_riff,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__play_riff,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 40,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__play_tone
STATIC const byte bytecode_data_tslib__lt_module_gt__play_tone[94] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0d,
    MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0x99, 0x2c, 0x57, 0x77, 0x22, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x36, 0x2e, 0x80, 
    0x1c, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x1e, MP_QSTR_DigitalInOut & 0xff, MP_QSTR_DigitalInOut >> 8,
    0x1c, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_SPEAKER_ENABLE & 0xff, MP_QSTR_SPEAKER_ENABLE >> 8,
    0x66, 0x01, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x26, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR__speaker_enable & 0xff, MP_QSTR__speaker_enable >> 8,
    0x1e, MP_QSTR_switch_to_output & 0xff, MP_QSTR_switch_to_output >> 8,
    0x16, MP_QSTR_value & 0xff, MP_QSTR_value >> 8,
    0x10, 
    0x66, 0x82, 0x00, 
    0xc2, 
    0x35, 0x02, 0x80, 
    0x11, 
    0xc2, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1e, MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    0xb0, 
    0xb1, 
    0x66, 0x02, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__play_tone[2] = {
    MP_ROM_QSTR(MP_QSTR_freq),
    MP_ROM_QSTR(MP_QSTR_beats),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__play_tone = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__play_tone,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__play_tone,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 94,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__set_lights
STATIC const byte bytecode_data_tslib__lt_module_gt__set_lights[56] = {
    0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0b,
    MP_QSTR_set_lights & 0xff, MP_QSTR_set_lights >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xa4, 0x26, 0x31, 0x00, 0x00, 0xff,
    0x80, 
    0x35, 0x0c, 0x80, 
    0x30, 
    0xc1, 
    0x1c, MP_QSTR_set_light & 0xff, MP_QSTR_set_light >> 8,
    0xb1, 
    0xb0, 
    0x64, 0x02, 
    0x32, 
    0x81, 
    0xe9, 
    0x30, 
    0x8a, 
    0xf0, 
    0x36, 0xee, 0x7f, 
    0x32, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0x1e, MP_QSTR_show & 0xff, MP_QSTR_show >> 8,
    0x66, 0x00, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__set_lights[1] = {
    MP_ROM_QSTR(MP_QSTR_c),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__set_lights = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__set_lights,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__set_lights,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 56,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__set_light
STATIC const byte bytecode_data_tslib__lt_module_gt__set_light[30] = {
    0x05, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR_set_light & 0xff, MP_QSTR_set_light >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xaa, 0x00, 0x00, 0xff,
    0xb1, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0xb0, 
    0x27, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__set_light[2] = {
    MP_ROM_QSTR(MP_QSTR_n),
    MP_ROM_QSTR(MP_QSTR_c),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__set_light = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__set_light,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__set_light,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 30,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__set_brightness
STATIC const byte bytecode_data_tslib__lt_module_gt__set_brightness[31] = {
    0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_set_brightness & 0xff, MP_QSTR_set_brightness >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xae, 0x00, 0x00, 0xff,
    0xb0, 
    0x1c, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0x26, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__set_brightness[1] = {
    MP_ROM_QSTR(MP_QSTR_n),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__set_brightness = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__set_brightness,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__set_brightness,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 31,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__pick_random
STATIC const byte bytecode_data_tslib__lt_module_gt__pick_random[36] = {
    0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x09,
    MP_QSTR_pick_random & 0xff, MP_QSTR_pick_random >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xb2, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_int & 0xff, MP_QSTR_int >> 8,
    0xb0, 
    0xb1, 
    0xb0, 
    0xdd, 
    0x1c, MP_QSTR_random & 0xff, MP_QSTR_random >> 8,
    0x1e, MP_QSTR_random & 0xff, MP_QSTR_random >> 8,
    0x66, 0x00, 
    0xde, 
    0xdc, 
    0x64, 0x01, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__pick_random[2] = {
    MP_ROM_QSTR(MP_QSTR_s),
    MP_ROM_QSTR(MP_QSTR_e),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__pick_random = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 2,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__pick_random,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__pick_random,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 36,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__MyDecodeClass___init__
STATIC const byte bytecode_data_tslib__lt_module_gt__MyDecodeClass___init__[32] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0a,
    MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xca, 0x2d, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1e, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0xb0, 
    0x66, 0x01, 
    0x32, 
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__MyDecodeClass___init__[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__MyDecodeClass___init__ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__MyDecodeClass___init__,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__MyDecodeClass___init__,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 32,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__MyDecodeClass_decode
STATIC const byte bytecode_data_tslib__lt_module_gt__MyDecodeClass_decode[35] = {
    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x09,
    MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x81, 0xce, 0x00, 0x00, 0xff,
    0x1c, MP_QSTR_IRLib_P01_NECd & 0xff, MP_QSTR_IRLib_P01_NECd >> 8,
    0x1d, MP_QSTR_IRdecodeNEC & 0xff, MP_QSTR_IRdecodeNEC >> 8,
    0x1e, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0xb0, 
    0x66, 0x01, 
    0x37, 0x02, 0x80, 
    0x12, 
    0x5b, 
    0x10, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__MyDecodeClass_decode[1] = {
    MP_ROM_QSTR(MP_QSTR_self),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__MyDecodeClass_decode = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 1,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__MyDecodeClass_decode,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__MyDecodeClass_decode,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 35,
        .n_obj = 0,
        .n_raw_code = 0,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib__lt_module_gt__MyDecodeClass
STATIC const byte bytecode_data_tslib__lt_module_gt__MyDecodeClass[42] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
    MP_QSTR_MyDecodeClass & 0xff, MP_QSTR_MyDecodeClass >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x8d, 0xc9, 0x65, 0x20, 0x00, 0x00, 0xff,
    0x1b, MP_QSTR___name__ & 0xff, MP_QSTR___name__ >> 8,
    0x24, MP_QSTR___module__ & 0xff, MP_QSTR___module__ >> 8,
    0x16, MP_QSTR_MyDecodeClass & 0xff, MP_QSTR_MyDecodeClass >> 8,
    0x24, MP_QSTR___qualname__ & 0xff, MP_QSTR___qualname__ >> 8,
    0x60, 0x00, 
    0x24, MP_QSTR___init__ & 0xff, MP_QSTR___init__ >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_decode & 0xff, MP_QSTR_decode >> 8,
    0x11, 
    0x5b, 
};
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt__MyDecodeClass[2] = {
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__MyDecodeClass___init__),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__MyDecodeClass_decode),
};
STATIC const mp_raw_code_t raw_code_tslib__lt_module_gt__MyDecodeClass = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt__MyDecodeClass,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt__MyDecodeClass,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 42,
        .n_obj = 0,
        .n_raw_code = 2,
        #endif
    },
};

// frozen bytecode for file tslib.py, scope tslib_<module>
STATIC const byte bytecode_data_tslib__lt_module_gt_[618] = {
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d,
    MP_QSTR__lt_module_gt_ & 0xff, MP_QSTR__lt_module_gt_ >> 8,
    MP_QSTR_tslib_dot_py & 0xff, MP_QSTR_tslib_dot_py >> 8,
    0x29, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x68, 0x85, 0x17, 0x85, 0x1b, 0x65, 0x40, 0x65, 0x60, 0x65, 0x60, 0x85, 0x07, 0x65, 0x40, 0x65, 0x40, 0x65, 0x20, 0x65, 0x60, 0x85, 0x08, 0x65, 0x20, 0x85, 0x0a, 0x85, 0x07, 0x65, 0x20, 0x65, 0x40, 0x85, 0x0b, 0x65, 0x60, 0x65, 0x20, 0x65, 0x20, 0x65, 0x20, 0x29, 0x2d, 0x2d, 0x24, 0x33, 0x26, 0x1f, 0x44, 0x35, 0x34, 0x2d, 0x2a, 0x24, 0x26, 0x25, 0x65, 0x71, 0x80, 0x07, 0x28, 0x31, 0x29, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0xff,
    0x80, 
    0x11, 
    0x68, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x24, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x24, MP_QSTR_time & 0xff, MP_QSTR_time >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_random & 0xff, MP_QSTR_random >> 8,
    0x24, MP_QSTR_random & 0xff, MP_QSTR_random >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_neopixel & 0xff, MP_QSTR_neopixel >> 8,
    0x24, MP_QSTR_neopixel & 0xff, MP_QSTR_neopixel >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x24, MP_QSTR_digitalio & 0xff, MP_QSTR_digitalio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x24, MP_QSTR_audioio & 0xff, MP_QSTR_audioio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_audiobusio & 0xff, MP_QSTR_audiobusio >> 8,
    0x24, MP_QSTR_audiobusio & 0xff, MP_QSTR_audiobusio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x24, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x24, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x24, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x24, MP_QSTR_touchio & 0xff, MP_QSTR_touchio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x24, MP_QSTR_pulseio & 0xff, MP_QSTR_pulseio >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_servo & 0xff, MP_QSTR_servo >> 8,
    0x24, MP_QSTR_servo & 0xff, MP_QSTR_servo >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_sys & 0xff, MP_QSTR_sys >> 8,
    0x24, MP_QSTR_sys & 0xff, MP_QSTR_sys >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x24, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLib_P01_NECd & 0xff, MP_QSTR_IRLib_P01_NECd >> 8,
    0x24, MP_QSTR_IRLib_P01_NECd & 0xff, MP_QSTR_IRLib_P01_NECd >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x24, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x80, 
    0x11, 
    0x68, MP_QSTR_IRLib_P01_NECs & 0xff, MP_QSTR_IRLib_P01_NECs >> 8,
    0x24, MP_QSTR_IRLib_P01_NECs & 0xff, MP_QSTR_IRLib_P01_NECs >> 8,
    0x60, 0x01, 
    0x24, MP_QSTR_send_ir & 0xff, MP_QSTR_send_ir >> 8,
    0x60, 0x02, 
    0x24, MP_QSTR_ir_receive & 0xff, MP_QSTR_ir_receive >> 8,
    0x60, 0x03, 
    0x24, MP_QSTR_reset_receiver & 0xff, MP_QSTR_reset_receiver >> 8,
    0x60, 0x04, 
    0x24, MP_QSTR_set_servo_f & 0xff, MP_QSTR_set_servo_f >> 8,
    0x60, 0x05, 
    0x24, MP_QSTR_free_servo_pin & 0xff, MP_QSTR_free_servo_pin >> 8,
    0x60, 0x06, 
    0x24, MP_QSTR_create_new_pwm & 0xff, MP_QSTR_create_new_pwm >> 8,
    0x60, 0x07, 
    0x24, MP_QSTR_fetch_existing_pwm & 0xff, MP_QSTR_fetch_existing_pwm >> 8,
    0x60, 0x08, 
    0x24, MP_QSTR_get_pwm & 0xff, MP_QSTR_get_pwm >> 8,
    0x60, 0x09, 
    0x24, MP_QSTR_shake & 0xff, MP_QSTR_shake >> 8,
    0x60, 0x0a, 
    0x24, MP_QSTR_pin_write_f & 0xff, MP_QSTR_pin_write_f >> 8,
    0x60, 0x0b, 
    0x24, MP_QSTR_mic_level & 0xff, MP_QSTR_mic_level >> 8,
    0x60, 0x0c, 
    0x24, MP_QSTR_mean & 0xff, MP_QSTR_mean >> 8,
    0x60, 0x0d, 
    0x24, MP_QSTR_normalized_rms & 0xff, MP_QSTR_normalized_rms >> 8,
    0x60, 0x0e, 
    0x24, MP_QSTR_log_scale & 0xff, MP_QSTR_log_scale >> 8,
    0x60, 0x0f, 
    0x24, MP_QSTR_constrain & 0xff, MP_QSTR_constrain >> 8,
    0x60, 0x10, 
    0x24, MP_QSTR_play_riff & 0xff, MP_QSTR_play_riff >> 8,
    0x60, 0x11, 
    0x24, MP_QSTR_play_tone & 0xff, MP_QSTR_play_tone >> 8,
    0x60, 0x12, 
    0x24, MP_QSTR_set_lights & 0xff, MP_QSTR_set_lights >> 8,
    0x60, 0x13, 
    0x24, MP_QSTR_set_light & 0xff, MP_QSTR_set_light >> 8,
    0x60, 0x14, 
    0x24, MP_QSTR_set_brightness & 0xff, MP_QSTR_set_brightness >> 8,
    0x60, 0x15, 
    0x24, MP_QSTR_pick_random & 0xff, MP_QSTR_pick_random >> 8,
    0x1b, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_NEOPIXEL & 0xff, MP_QSTR_NEOPIXEL >> 8,
    0x24, MP_QSTR_pixpin & 0xff, MP_QSTR_pixpin >> 8,
    0x10, 
    0x1b, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0x26, MP_QSTR_auto_write & 0xff, MP_QSTR_auto_write >> 8,
    0x81, 
    0x1b, MP_QSTR_express & 0xff, MP_QSTR_express >> 8,
    0x1d, MP_QSTR_cpx & 0xff, MP_QSTR_cpx >> 8,
    0x1d, MP_QSTR_pixels & 0xff, MP_QSTR_pixels >> 8,
    0x26, MP_QSTR_brightness & 0xff, MP_QSTR_brightness >> 8,
    0x82, 
    0x24, MP_QSTR_CURVE & 0xff, MP_QSTR_CURVE >> 8,
    0x1b, MP_QSTR_math & 0xff, MP_QSTR_math >> 8,
    0x1e, MP_QSTR_pow & 0xff, MP_QSTR_pow >> 8,
    0x8a, 
    0x1b, MP_QSTR_CURVE & 0xff, MP_QSTR_CURVE >> 8,
    0x17, 0x00, 
    0xd4, 
    0xde, 
    0x66, 0x02, 
    0x24, MP_QSTR_SCALE_EXPONENT & 0xff, MP_QSTR_SCALE_EXPONENT >> 8,
    0x14, 0x81, 0x20, 
    0x24, MP_QSTR_NUM_SAMPLES & 0xff, MP_QSTR_NUM_SAMPLES >> 8,
    0x1b, MP_QSTR_audiobusio & 0xff, MP_QSTR_audiobusio >> 8,
    0x1e, MP_QSTR_PDMIn & 0xff, MP_QSTR_PDMIn >> 8,
    0x1b, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_MICROPHONE_CLOCK & 0xff, MP_QSTR_MICROPHONE_CLOCK >> 8,
    0x1b, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_MICROPHONE_DATA & 0xff, MP_QSTR_MICROPHONE_DATA >> 8,
    0x16, MP_QSTR_frequency & 0xff, MP_QSTR_frequency >> 8,
    0x14, 0x80, 0xfd, 0x00, 
    0x16, MP_QSTR_bit_depth & 0xff, MP_QSTR_bit_depth >> 8,
    0x90, 
    0x66, 0x84, 0x02, 
    0x24, MP_QSTR_mic & 0xff, MP_QSTR_mic >> 8,
    0x1b, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x1e, MP_QSTR_array & 0xff, MP_QSTR_array >> 8,
    0x16, MP_QSTR_H & 0xff, MP_QSTR_H >> 8,
    0x80, 
    0x51, 0x01, 
    0x1b, MP_QSTR_NUM_SAMPLES & 0xff, MP_QSTR_NUM_SAMPLES >> 8,
    0xde, 
    0x66, 0x02, 
    0x24, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x1b, MP_QSTR_mic & 0xff, MP_QSTR_mic >> 8,
    0x1e, MP_QSTR_record & 0xff, MP_QSTR_record >> 8,
    0x1b, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x1b, MP_QSTR_len & 0xff, MP_QSTR_len >> 8,
    0x1b, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x64, 0x01, 
    0x66, 0x02, 
    0x32, 
    0x1b, MP_QSTR_normalized_rms & 0xff, MP_QSTR_normalized_rms >> 8,
    0x1b, MP_QSTR_samples & 0xff, MP_QSTR_samples >> 8,
    0x64, 0x01, 
    0x8a, 
    0xdc, 
    0x24, MP_QSTR_input_floor & 0xff, MP_QSTR_input_floor >> 8,
    0x1b, MP_QSTR_input_floor & 0xff, MP_QSTR_input_floor >> 8,
    0x14, 0x83, 0x74, 
    0xdc, 
    0x24, MP_QSTR_input_ceiling & 0xff, MP_QSTR_input_ceiling >> 8,
    0x80, 
    0x24, MP_QSTR_peak & 0xff, MP_QSTR_peak >> 8,
    0x14, 0xbe, 0x40, 
    0x24, MP_QSTR_SAMPLERATE & 0xff, MP_QSTR_SAMPLERATE >> 8,
    0x51, 0x00, 
    0x24, MP_QSTR_output_pins & 0xff, MP_QSTR_output_pins >> 8,
    0x51, 0x00, 
    0x24, MP_QSTR_pwms & 0xff, MP_QSTR_pwms >> 8,
    0x20, 
    0x60, 0x16, 
    0x16, MP_QSTR_MyDecodeClass & 0xff, MP_QSTR_MyDecodeClass >> 8,
    0x1b, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x1d, MP_QSTR_IRLibDecodeBase & 0xff, MP_QSTR_IRLibDecodeBase >> 8,
    0x64, 0x03, 
    0x24, MP_QSTR_MyDecodeClass & 0xff, MP_QSTR_MyDecodeClass >> 8,
    0x1b, MP_QSTR_MyDecodeClass & 0xff, MP_QSTR_MyDecodeClass >> 8,
    0x64, 0x00, 
    0x24, MP_QSTR_myDecoder & 0xff, MP_QSTR_myDecoder >> 8,
    0x1b, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1e, MP_QSTR_IRrecvPCI & 0xff, MP_QSTR_IRrecvPCI >> 8,
    0x1b, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_REMOTEIN & 0xff, MP_QSTR_REMOTEIN >> 8,
    0x66, 0x01, 
    0x24, MP_QSTR_myReceiver & 0xff, MP_QSTR_myReceiver >> 8,
    0x1b, MP_QSTR_myReceiver & 0xff, MP_QSTR_myReceiver >> 8,
    0x1e, MP_QSTR_enableIRIn & 0xff, MP_QSTR_enableIRIn >> 8,
    0x66, 0x00, 
    0x32, 
    0x10, 
    0x24, MP_QSTR_last_ir_number & 0xff, MP_QSTR_last_ir_number >> 8,
    0x10, 
    0x25, MP_QSTR_current_ir_number & 0xff, MP_QSTR_current_ir_number >> 8,
    0x10, 
    0x25, MP_QSTR_last_sent_time & 0xff, MP_QSTR_last_sent_time >> 8,
    0x10, 
    0x24, MP_QSTR_last_recieved_address & 0xff, MP_QSTR_last_recieved_address >> 8,
    0x1b, MP_QSTR_IRLib_P01_NECs & 0xff, MP_QSTR_IRLib_P01_NECs >> 8,
    0x1e, MP_QSTR_IRsendNEC & 0xff, MP_QSTR_IRsendNEC >> 8,
    0x1b, MP_QSTR_board & 0xff, MP_QSTR_board >> 8,
    0x1d, MP_QSTR_REMOTEOUT & 0xff, MP_QSTR_REMOTEOUT >> 8,
    0x66, 0x01, 
    0x25, MP_QSTR_mySend & 0xff, MP_QSTR_mySend >> 8,
    0x11, 
    0x5b, 
};
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
STATIC const mp_obj_float_t const_obj_tslib__lt_module_gt__0 = {{&mp_type_float}, 0.1};
#endif
STATIC const mp_rom_obj_t const_table_data_tslib__lt_module_gt_[23] = {
#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
    MP_ROM_PTR(&const_obj_tslib__lt_module_gt__0),
#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
    (mp_rom_obj_t)(0xbe4cccce),
#else
#error "MICROPY_OBJ_REPR_D not supported with floats in frozen mpy files"
#endif
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__send_ir),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__ir_receive),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__reset_receiver),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__set_servo_f),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__free_servo_pin),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__create_new_pwm),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__fetch_existing_pwm),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__get_pwm),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__shake),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__pin_write_f),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__mic_level),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__mean),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__normalized_rms),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__log_scale),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__constrain),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__play_riff),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__play_tone),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__set_lights),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__set_light),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__set_brightness),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__pick_random),
    MP_ROM_PTR(&raw_code_tslib__lt_module_gt__MyDecodeClass),
};
const mp_raw_code_t raw_code_tslib__lt_module_gt_ = {
    .kind = MP_CODE_BYTECODE,
    .scope_flags = 0x00,
    .n_pos_args = 0,
    .data.u_byte = {
        .bytecode = bytecode_data_tslib__lt_module_gt_,
        .const_table = (mp_uint_t*)const_table_data_tslib__lt_module_gt_,
        #if MICROPY_PERSISTENT_CODE_SAVE
        .bc_len = 618,
        .n_obj = 1,
        .n_raw_code = 22,
        #endif
    },
};

const char mp_frozen_mpy_names[] = {
"adafruit_bus_device/__init__.py\0"
"adafruit_bus_device/i2c_device.py\0"
"adafruit_bus_device/spi_device.py\0"
"adafruit_lis3dh.py\0"
"adafruit_thermistor.py\0"
"express.py\0"
"frozentest.py\0"
"IRLib_P01_NECd.py\0"
"IRLib_P01_NECs.py\0"
"IRLib_P02_Sonyd.py\0"
"IRLib_P02_Sonys.py\0"
"IRLib_P03_RC5d.py\0"
"IRLib_P03_RC5s.py\0"
"IRLib_P04_RC6d.py\0"
"IRLib_P04_RC6s.py\0"
"IRLib_P05_Panasonic_Oldd.py\0"
"IRLib_P05_Panasonic_Olds.py\0"
"IRLib_P06_JVCd.py\0"
"IRLib_P06_JVCs.py\0"
"IRLib_P07_NECxd.py\0"
"IRLib_P07_NECxs.py\0"
"IRLib_P08_Samsung36d.py\0"
"IRLib_P08_Samsung36s.py\0"
"IRLib_P09_GICabled.py\0"
"IRLib_P09_GICables.py\0"
"IRLib_P10_DirecTVd.py\0"
"IRLib_P10_DirecTVs.py\0"
"IRLib_P11_RCMMd.py\0"
"IRLib_P11_RCMMs.py\0"
"IRLibDecodeBase.py\0"
"IRLibProtocols.py\0"
"IRLibSendBase.py\0"
"IRrecvPCI.py\0"
"motor.py\0"
"neopixel.py\0"
"servo.py\0"
"stepper.py\0"
"tslib.py\0"
"\0"};
const mp_raw_code_t *const mp_frozen_mpy_content[] = {
    &raw_code_adafruit_bus_device___init____lt_module_gt_,
    &raw_code_adafruit_bus_device_i2c_device__lt_module_gt_,
    &raw_code_adafruit_bus_device_spi_device__lt_module_gt_,
    &raw_code_adafruit_lis3dh__lt_module_gt_,
    &raw_code_adafruit_thermistor__lt_module_gt_,
    &raw_code_express__lt_module_gt_,
    &raw_code_frozentest__lt_module_gt_,
    &raw_code_IRLib_P01_NECd__lt_module_gt_,
    &raw_code_IRLib_P01_NECs__lt_module_gt_,
    &raw_code_IRLib_P02_Sonyd__lt_module_gt_,
    &raw_code_IRLib_P02_Sonys__lt_module_gt_,
    &raw_code_IRLib_P03_RC5d__lt_module_gt_,
    &raw_code_IRLib_P03_RC5s__lt_module_gt_,
    &raw_code_IRLib_P04_RC6d__lt_module_gt_,
    &raw_code_IRLib_P04_RC6s__lt_module_gt_,
    &raw_code_IRLib_P05_Panasonic_Oldd__lt_module_gt_,
    &raw_code_IRLib_P05_Panasonic_Olds__lt_module_gt_,
    &raw_code_IRLib_P06_JVCd__lt_module_gt_,
    &raw_code_IRLib_P06_JVCs__lt_module_gt_,
    &raw_code_IRLib_P07_NECxd__lt_module_gt_,
    &raw_code_IRLib_P07_NECxs__lt_module_gt_,
    &raw_code_IRLib_P08_Samsung36d__lt_module_gt_,
    &raw_code_IRLib_P08_Samsung36s__lt_module_gt_,
    &raw_code_IRLib_P09_GICabled__lt_module_gt_,
    &raw_code_IRLib_P09_GICables__lt_module_gt_,
    &raw_code_IRLib_P10_DirecTVd__lt_module_gt_,
    &raw_code_IRLib_P10_DirecTVs__lt_module_gt_,
    &raw_code_IRLib_P11_RCMMd__lt_module_gt_,
    &raw_code_IRLib_P11_RCMMs__lt_module_gt_,
    &raw_code_IRLibDecodeBase__lt_module_gt_,
    &raw_code_IRLibProtocols__lt_module_gt_,
    &raw_code_IRLibSendBase__lt_module_gt_,
    &raw_code_IRrecvPCI__lt_module_gt_,
    &raw_code_motor__lt_module_gt_,
    &raw_code_neopixel__lt_module_gt_,
    &raw_code_servo__lt_module_gt_,
    &raw_code_stepper__lt_module_gt_,
    &raw_code_tslib__lt_module_gt_,
};
