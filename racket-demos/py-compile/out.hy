(import board) (import time) (import random) (import neopixel) (import digitalio) (import audioio) (import audiobusio) (import array) (import math) (setv initial-memory {}) (setv state {"hardware" {"audio" []} "memory" initial-memory}) (defn update () (do (if (. state ["memory"] ["blade-on"]) (if (loud-noise) (clash-fx) (flicker-fx)) (set-lights [0 0 0])))) (defn loud-noise () (do (< 5 (. state ["hardware"] ["mic-level"])))) (defn clash-fx () (do (play-tone 0.1 392.0) (play-tone 0.05 220.0) (for (n (range 2)) (set-lights [255 255 255]) (do (render state) (time.sleep 0.2)) (set-lights [255 0 0]) (do (render state) (time.sleep 0.2))))) (defn flicker-fx () (do (set-lights [(max 0 (- (. (. state ["memory"] ["color"]) [0]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [1]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [2]) (int (+ 0 (* 255 (random.random))))))]))) (defn mic-level () (do (mic.record samples (len samples)) (setv magnitude (normalized_rms samples)) (setv c (log_scale (constrain magnitude input_floor input_ceiling) input_floor input_ceiling 0 10)) c)) (defn mean (values) (do (return (/ (sum values) (len values))))) (defn normalized_rms (values) (do (setv minbuf (int (mean values))) (return (math.sqrt (/ (sum (list-comp (float (* (- sample minbuf) (- sample minbuf))) (sample values))) (len values)))))) (defn log_scale (input_value input_min input_max output_min output_max) (do (setv normalized_input_value (/ (- input_value input_min) (- input_max input_min))) (return (+ output_min (* (math.pow normalized_input_value SCALE_EXPONENT) (- output_max output_min)))))) (defn constrain (value floor ceiling) (do (return (max floor (min value ceiling))))) (defn play-file (to-play) (do (setv id (. to-play [1])) (if (already-played id) (return)) (already-played-list.append id) (setv filename (. to-play [0])) (print (+ "playing file " filename)) (setv f (open filename "rb")) (setv a (audioio.AudioOut board.A0 f)) (a.play) (while a.playing (setv dummy 0)))) (defn already-played (id) (do (for (p already-played-list) (if (= p id) (return True))) (return False))) (defn play-tone (beats freq) (do (setv length (int (/ SAMPLERATE freq))) (setv sine_wave (array.array "H" (* [0] length))) (for (i (range length)) (setv (. sine_wave [i]) (+ (* (int (* (math.sin (/ (* math.pi 2 i) 18)) (** 2 15)))) (** 2 15)))) (setv sample (audioio.AudioOut board.SPEAKER sine_wave)) (setv sample.frequency SAMPLERATE) (sample.play :loop True) (time.sleep beats) (sample.stop))) (defn set-lights (c) (do (for (n (range 10)) (set-light n c)))) (defn set-light (n c) (do (do (setv (. state ["hardware"] ["light"] [n]) c) state))) (defn hardware-update-lights () (do (if (not (in "lights" (. state ["hardware"]))) (do (setv (. state ["hardware"] ["light"]) [0 0 0 0 0 0 0 0 0 0]) state) (setv dummy "dummy")) (for (n (range 10)) (do (setv (. state ["hardware"] ["light"] [n]) (. strip [n])) state)))) (setv pixpin board.NEOPIXEL) (setv numpix 10) (setv strip (neopixel.NeoPixel pixpin numpix :brightness 0.3 :auto_write False)) (setv already-played-list []) (setv CURVE 2) (setv SCALE_EXPONENT (math.pow 10 (* CURVE -0.1))) (setv NUM_SAMPLES 160) (setv mic (audiobusio.PDMIn board.MICROPHONE_CLOCK board.MICROPHONE_DATA :frequency 16000 :bit_depth 16)) (setv samples (array.array "H" (* [0] NUM_SAMPLES))) (mic.record samples (len samples)) (setv input_floor (+ (normalized_rms samples) 10)) (setv input_ceiling (+ input_floor 500)) (setv peak 0) (setv SAMPLERATE 8000) (setv spkrenable (digitalio.DigitalInOut board.SPEAKER_ENABLE)) (setv spkrenable.direction digitalio.Direction.OUTPUT) (setv spkrenable.value True) (setv BUTTON_A (digitalio.DigitalInOut board.BUTTON_A)) (setv BUTTON_A.direction digitalio.Direction.INPUT) (setv BUTTON_A.pull digitalio.Pull.DOWN) (setv BUTTON_A_prev BUTTON_A.value) (do (setv (. state ["memory"] ["color"]) [0 255 0]) state) (do (setv (. state ["memory"] ["blade-on"]) False) state) (setv start-time (time.monotonic)) (defn time-since-start () (- (time.monotonic) start-time)) (defn hardware-update (state) (global strip) (hardware-update-lights) (do (setv (. state ["hardware"] ["audio"]) []) state) (do (setv (. state ["hardware"] ["mic-level"]) (mic-level)) state)) (defn render (state) (global strip) (for (n (range 10)) (setv (. strip [n]) (. state ["hardware"] ["light"] [n]))) (strip.show) (while (< 0 (len (. state ["hardware"] ["audio"]))) (do (play_file ((. (. state ["hardware"] ["audio"]) pop)))))) (while True (if (not (= BUTTON_A.value BUTTON_A_prev)) (if BUTTON_A.value (do (setv (. state ["memory"] ["blade-on"]) (not (. state ["memory"] ["blade-on"]))) state))) (setv BUTTON_A_prev BUTTON_A.value) (hardware-update state) (update) (render state))