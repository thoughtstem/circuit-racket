(import board) (import time) (import random) (import neopixel) (import digitalio) (import audioio) (import audiobusio) (import array) (import math) (import IRLibDecodeBase) (import IRLib_P01_NECd) (import IRLib_P02_Sonyd) (import IRLib_P03_RC5d) (import IRrecvPCI) (import IRLib_P01_NECs) (setv initial-memory {}) (setv state {"hardware" {"audio" []} "memory" initial-memory}) (defn update () (do (if (. state ["memory"] ["blade-on"]) (if (loud-noise) (clash-fx) (flicker-fx)) (set-lights [0 0 0])))) (defn loud-noise () (do (< 5 (. state ["hardware"] ["mic-level"])))) (defn clash-fx () (do (play-tone 0.1 392.0) (play-tone 0.05 220.0) (for (n (range 2)) (set-lights [255 255 255]) (do (render state) (time.sleep 0.2)) (set-lights [255 0 0]) (do (render state) (time.sleep 0.2))))) (defn flicker-fx () (do (set-lights [(max 0 (- (. (. state ["memory"] ["color"]) [0]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [1]) (int (+ 0 (* 255 (random.random)))))) (max 0 (- (. (. state ["memory"] ["color"]) [2]) (int (+ 0 (* 255 (random.random))))))]))) (defn blade-off () (do (for (n (range 10)) (set-light n [0 0 0]) (do (render state) (time.sleep 0.025))) (do (setv (. state ["memory"] ["blade-on"]) False) state))) (defn blade-on () (do (for (n (range 10)) (set-light n (. state ["memory"] ["color"])) (do (render state) (time.sleep 0.05))) (do (setv (. state ["memory"] ["blade-on"]) True) state))) (defn hardware-update-ir () (do (global last-ir-number) (global current-ir-number) (do (setv (. state ["hardware"] ["last-ir-number"]) last-ir-number) state) (do (setv (. state ["hardware"] ["current-ir-number"]) current-ir-number) state))) (defn send-ir (n) (do (global mySend) (global last-sent-time) (setv last-sent-time 20) (mySend.send n 0x6))) (defn hardware-update-sound () (do (do (setv (. state ["hardware"] ["audio"]) []) state) (do (setv (. state ["hardware"] ["mic-level"]) (mic-level)) state))) (defn mic-level () (do (mic.record samples (len samples)) (setv magnitude (normalized_rms samples)) (setv c (log_scale (constrain magnitude input_floor input_ceiling) input_floor input_ceiling 0 10)) c)) (defn mean (values) (do (return (/ (sum values) (len values))))) (defn normalized_rms (values) (do (setv minbuf (int (mean values))) (setv sum 0) (for (i (range (len values))) (setv sample (. values [i])) (setv curr (float (* (- sample minbuf) (- sample minbuf)))) (setv sum (+ sum curr))) (return (math.sqrt (/ sum (len values)))))) (defn log_scale (input_value input_min input_max output_min output_max) (do (setv normalized_input_value (/ (- input_value input_min) (- input_max input_min))) (return (+ output_min (* (math.pow normalized_input_value SCALE_EXPONENT) (- output_max output_min)))))) (defn constrain (value floor ceiling) (do (return (max floor (min value ceiling))))) (defn already-played (id) (do (for (p already-played-list) (if (= p id) (return True))) (return False))) (defn play-tone (beats freq) (do (setv length (int (/ SAMPLERATE freq))) (setv sine_wave (array.array "H" (* [0] length))) (for (i (range length)) (setv (. sine_wave [i]) (+ (* (int (* (math.sin (/ (* math.pi 2 i) 18)) (** 2 15)))) (** 2 15)))) (setv sample (audioio.AudioOut board.SPEAKER sine_wave)) (setv sample.frequency SAMPLERATE) (sample.play :loop True) (time.sleep beats) (sample.stop))) (defn set-lights (c) (do (for (n (range 10)) (set-light n c)))) (defn set-light (n c) (do (do (setv (. state ["hardware"] ["light"] [n]) c) state))) (defn hardware-update-lights () (do (if (not (in "lights" (. state ["hardware"]))) (do (setv (. state ["hardware"] ["light"]) [0 0 0 0 0 0 0 0 0 0]) state) (setv dummy "dummy")) (for (n (range 10)) (do (setv (. state ["hardware"] ["light"] [n]) (. strip [n])) state)))) (setv pixpin board.NEOPIXEL) (setv numpix 10) (setv strip (neopixel.NeoPixel pixpin numpix :brightness 0.3 :auto_write False)) (setv already-played-list []) (setv CURVE 2) (setv SCALE_EXPONENT (math.pow 10 (* CURVE -0.1))) (setv NUM_SAMPLES 10) (setv mic (audiobusio.PDMIn board.MICROPHONE_CLOCK board.MICROPHONE_DATA :frequency 16000 :bit_depth 16)) (setv samples (array.array "H" (* [0] NUM_SAMPLES))) (mic.record samples (len samples)) (setv input_floor (+ (normalized_rms samples) 10)) (setv input_ceiling (+ input_floor 500)) (setv peak 0) (setv SAMPLERATE 8000) (setv spkrenable (digitalio.DigitalInOut board.SPEAKER_ENABLE)) (setv spkrenable.direction digitalio.Direction.OUTPUT) (setv spkrenable.value True) (setv BUTTON_A (digitalio.DigitalInOut board.BUTTON_A)) (setv BUTTON_A.direction digitalio.Direction.INPUT) (setv BUTTON_A.pull digitalio.Pull.DOWN) (setv BUTTON_A_prev BUTTON_A.value) (defclass MyDecodeClass (IRLibDecodeBase.IRLibDecodeBase) (defn __init__ (self) (IRLibDecodeBase.IRLibDecodeBase.__init__ self)) (defn decode (self) (if (IRLib_P01_NECd.IRdecodeNEC.decode self) True False))) (setv myDecoder (MyDecodeClass)) (setv myReceiver (IRrecvPCI.IRrecvPCI board.REMOTEIN)) (myReceiver.enableIRIn) (setv last-ir-number False) (setv current-ir-number False) (setv last-sent-time False) (setv last-recieved-address False) (setv mySend (IRLib_P01_NECs.IRsendNEC board.REMOTEOUT)) (do (setv (. state ["memory"] ["color"]) [0 255 0]) state) (do (setv (. state ["memory"] ["blade-on"]) False) state) (setv start-time (time.monotonic)) (defn time-since-start () (- (time.monotonic) start-time)) (defn hardware-update (state) (global strip) (hardware-update-lights) (hardware-update-sound) (hardware-update-ir)) (defn render (state) (global strip) (for (n (range 10)) (setv (. strip [n]) (. state ["hardware"] ["light"] [n]))) (strip.show) (while (< 0 (len (. state ["hardware"] ["audio"]))) (do (play_file ((. (. state ["hardware"] ["audio"]) pop)))))) (while True (if (not (= BUTTON_A.value BUTTON_A_prev)) (if BUTTON_A.value (if (. state ["memory"] ["blade-on"]) (blade-off) (blade-on)))) (setv BUTTON_A_prev BUTTON_A.value) (try (if (= last-sent-time 0) (do (myReceiver.getResults) (if (myDecoder.decode) (do (setv last-ir-number myDecoder.value) (setv last-received-address myDecoder.address) (setv current-ir-number myDecoder.value)) (setv current-ir-number False)) (myReceiver.enableIRIn)) (do (setv last-sent-time (- last-sent-time 1)) (print last-sent-time) (myReceiver.getResults))) (except [] (setv current-ir-number False))) (hardware-update state) (update) (render state))