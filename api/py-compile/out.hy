(import board) (import time) (import random) (import IRLibDecodeBase) (import IRLib_P01_NECd) (import IRLib_P02_Sonyd) (import IRLib_P03_RC5d) (import IRrecvPCI) (import IRLib_P01_NECs) (setv initial-memory {}) (setv state {"hardware" {"audio" []} "memory" initial-memory}) (defclass MyDecodeClass (IRLibDecodeBase.IRLibDecodeBase) (defn __init__ (self) (IRLibDecodeBase.IRLibDecodeBase.__init__ self)) (defn decode (self) (if (IRLib_P01_NECd.IRdecodeNEC.decode self) True False))) (setv myDecoder (MyDecodeClass)) (setv myReceiver (IRrecvPCI.IRrecvPCI board.REMOTEIN)) (myReceiver.enableIRIn) (print "send a signal") (setv start-time (time.monotonic)) (defn time-since-start () (- (time.monotonic) start-time)) (defn hardware-update (state) (global strip) (hardware-update-lights) (do (setv (. state ["hardware"] ["audio"]) []) state) (do (setv (. state ["hardware"] ["mic-level"]) (mic-level)) state)) (defn render (state) (global strip) (for (n (range 10)) (setv (. strip [n]) (. state ["hardware"] ["light"] [n]))) (strip.show) (while (< 0 (len (. state ["hardware"] ["audio"]))) (do (play_file ((. (. state ["hardware"] ["audio"]) pop)))))) (while True (try (if (myDecoder.decode) (print "success") (print "failed")) (print "HEX?") (print (hex myDecoder.value)) (myReceiver.enableIRIn) (except [] (print "ERROR") time.sleep (2))) (hardware-update state) (update) (render state))